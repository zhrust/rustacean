<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Rust å’Œé»˜è®¤å‚æ•° - be Rustaceans</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../favicon.svg">
    <link rel="shortcut icon" href="../favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->

</head>

<body>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script>
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="../abt/index.html"><strong aria-hidden="true">1.</strong> æœ‰å…³</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../abt/gh-pages.html"><strong aria-hidden="true">1.1.</strong> gh-pages</a></li><li class="chapter-item expanded "><a href="../abt/zhrust.html"><strong aria-hidden="true">1.2.</strong> zhrust</a></li></ol></li><li class="chapter-item expanded "><a href="../dev/index.html"><strong aria-hidden="true">2.</strong> å¼€å‘</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/20-things-ive-learned-in-my-20-years-as-a-software-engineer.html"><strong aria-hidden="true">2.1.</strong> 20å¹´æ¥ä½œä¸ºè½¯ä»¶å·¥ç¨‹å¸ˆå­¦åˆ°çš„10ä»¶äº‹</a></li><li class="chapter-item expanded "><a href="../dev/concepts-i-wish-i-learned-earlier.html"><strong aria-hidden="true">2.2.</strong> å¸Œæœ›ä¸€æ—©çŸ¥é“çš„å…³é”®æ¦‚å¿µ</a></li></ol></li><li class="chapter-item expanded "><a href="../tip/index.html"><strong aria-hidden="true">3.</strong> æŠ€å·§</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tip/rust6fun-operator-overloading.html"><strong aria-hidden="true">3.1.</strong> è¿ç®—ç¬¦é‡è½½å…­ä»¶è¶£äº‹</a></li><li class="chapter-item expanded "><a href="../tip/default-params.html" class="active"><strong aria-hidden="true">3.2.</strong> Rust å’Œé»˜è®¤å‚æ•°</a></li></ol></li><li class="chapter-item expanded "><a href="../101/index.html"><strong aria-hidden="true">4.</strong> å­¦ä¹ </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../101/exercism.html"><strong aria-hidden="true">4.1.</strong> Exercism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../101/ex42all-your-base.html"><strong aria-hidden="true">4.1.1.</strong> 42:all-your-base</a></li><li class="chapter-item expanded "><a href="../101/ex43Allergies.html"><strong aria-hidden="true">4.1.2.</strong> 43:Allergies</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../log/index.html"><strong aria-hidden="true">5.</strong> ç¬”è®°</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../log/rust-s-ugly-syntax.html"><strong aria-hidden="true">5.1.</strong> Rust ä¸‘å¥æ³•</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">be Rustaceans</h1>

                <div class="right-buttons">
                    <a href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/zhrust/rustacean/tree/main/src" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script>
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="rust-å’Œé»˜è®¤å‚æ•°"><a class="header" href="#rust-å’Œé»˜è®¤å‚æ•°">Rust å’Œé»˜è®¤å‚æ•°</a></h1>
<p>åŸæ–‡: <a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></p>
<blockquote>
<p>å¿«è¯‘</p>
</blockquote>
<p>Rust ä¸æ”¯æŒå‡½æ•°å£°æ˜ä¸­çš„é»˜è®¤å‚æ•°;
è€Œä¸”å’Œå¾ˆå¤šè¯­è¨€ä¸åŒ, æ— æ³•é€šè¿‡å‡½æ•°é‡è½½æ¥æ¨¡æ‹Ÿ;
è¿™è®©å¾ˆå¤šæ¥è‡ªå…¶å®ƒç¼–ç¨‹è¯­è¨€çš„ Rustacean æ–°äººæ„Ÿåˆ°æ²®ä¸§,
æ‰€ä»¥, å°±æƒ³è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆè¿™å…¶å®æ˜¯ä»¶å¥½äº‹å„¿,
ä»¥åŠ,å¦‚æœä½¿ç”¨é»˜è®¤ trait å’Œç»“æ„æ›´æ–°è¯­æ³•æ¥å®ç°ç±»ä¼¼çš„æ•ˆæœ;</p>
<p>é»˜è®¤å‚æ•°(å’Œå‡½æ•°é‡è½½)ä¸æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹çš„ä¸€éƒ¨åˆ†,
ä½†æ˜¯,åˆæ˜¯è®¸å¤š Rustaceans æ–°äººåŸå…ˆç¼–ç¨‹è¯­è¨€çš„å…±åŒç‰¹å¾;
å› æ­¤, è¿™ç¯‡æ–‡ç« åœ¨æŸäº›æ–¹é¢å’Œæˆ‘æ­£åœ¨è¿›è¡Œçš„å…³äº Rust å¦‚ä½•ä¸æ˜¯é¢å‘å¯¹è±¡çš„ç³»åˆ—æ–‡ç« ç›¸å»åˆ,
æ•…è€Œ, è¢«æ ‡å‡†ä¸ºè¿™ä¸ªç³»åˆ—çš„æ–‡ç« ;
è¿˜å—åˆ° Reddit ä¸­å¯¹æˆ‘ç¬¬ä¸€ç¯‡ OOP ç›¸å…³è´´å­å›å¤çš„å¯å‘;</p>
<h2 id="é»˜è®¤ç§‹ç²®æ˜¯å¦‚ä½•å·¥ä½œå’¯æ¯”å¦‚-c"><a class="header" href="#é»˜è®¤ç§‹ç²®æ˜¯å¦‚ä½•å·¥ä½œå’¯æ¯”å¦‚-c">é»˜è®¤ç§‹ç²®æ˜¯å¦‚ä½•å·¥ä½œå’¯(æ¯”å¦‚ C++)</a></h2>
<p>åœ¨å¼€å§‹è®¨è®ºä¸ºä»€ä¹ˆ Rust æ²¡æœ‰é»˜è®¤å‚æ•°ä»¥åŠæˆ‘ä»¬å¯ä»¥æŠ˜è…¾ä»€ä¹ˆä¹‹å‰,
å¾—å…ˆèŠæ˜ç™½ä»€ä¹ˆæ˜¯é»˜è®¤å‚æ•°ä»¥åŠåœ¨å“ªäº›æƒ…å†µä¸‹æœ‰ç”¨;</p>
<p>å‡è®¾ä½ æœ‰ä¸€ä¸ªå¸¦æœ‰å¾ˆå¤šå‚æ•°çš„å‡½æ•°,
æ¯”å¦‚(ä»¥ Reddit å›å¤ä¸­çš„ç¤ºä¾‹)åœ¨ GUI ä¸­åˆ›å»ºä¸€ä¸ªçª—å£:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible)

auto handle = createWindow(10, 30, false); // Create invisible window
auto handle2 = createWindow(100, 500, true); // Create visible window
</code></pre>
<p>ç°åœ¨, å‡è®¾ä½ å‡†å¤‡åˆ›å»ºçš„å¤§å¤šæ•°çª—å£éƒ½æ˜¯å¯è§çš„,
å¹¶ä¸”,ä½ ä¸æƒ³è®©ç¨‹åºå‘˜è´Ÿæ‹…å¿…é¡»æŒ‡å®šçª—å£æ˜¯å¦å¯è§çš„æ‹…å¿ƒ --- ç”šè‡³äºä¸æƒ³æ˜ç¡®çš„è€ƒè™‘è¿™äº‹å„¿ --- åœ¨æ­£å¸¸æƒ…å†µä¸‹,
åœ¨æ”¯æŒé»˜è®¤å‚æ•°çš„ç¼–ç¨‹è¯­è¨€ä¸­,ä½ å¯ä»¥ä¸ºå¯è§æ€§æä¾›é»˜è®¤å€¼:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true)

auto handle = createWindow(10, 30, false); // Create invisible window!

auto handle2 = createWindow(100, 500, true); // Create visible window!

auto handle3 = createWindow(100, 500); // Also create visible window!
auto handle4 = createWindow(100, 500); // Most of the time, that's what
auto handle5 = createWindow(100, 500); // you want, so why have to say it?
Default parameters can also be simulated with function overloading for programming languages where function overloading is available but default parameters are not:

WindowHandle createWindow(int width, int height, bool visible);

WindowHandle createWindow(int width, int height) {
    return createWindow(width, height, true);
}
</code></pre>
<p>Rust ä¹Ÿæ²¡æœ‰å‡½æ•°é‡è½½,è¿™æ˜¯ä¸ªå¤æ‚çš„å¤šçš„é—®é¢˜,
ä½†æ˜¯, å¾ˆå¤šç›¸åŒçš„è®ºç‚¹éƒ½é€‚ç”¨è¿™ä¸ªä¹ æƒ¯ç”¨æ³•çš„ç†è§£;</p>
<h2 id="benefits-and-detriments-of-default-parameters"><a class="header" href="#benefits-and-detriments-of-default-parameters">Benefits (and Detriments) of Default Parameters</a></h2>
<p>Defaults are good, and default parameters in this style are one way to implement them and reap their benefits.</p>
<p>Defaults are good because they uphold the DRY principle â€“ Donâ€™t Repeat Yourself. If we didnâ€™t have defaults, weâ€™d have to repeat parameters that donâ€™t actually contribute to understanding of the goals of the code. And if the best default parameters changed in such a way that the best way to update the code was to continue using the default â€“ perhaps because of a change of best practices â€“ weâ€™d have to update every call rather than just changing it once, where the default parameter is defined.</p>
<p>Defaults are also good because they decrease the programmerâ€™s cognitive load. Programmers have to keep a lot of information in their brain at a time, and defaults help programmers by not forcing them to think about extra details when they donâ€™t matter â€“ which is the usual situation for most defaults.</p>
<p>Default parameters also make the code more concise, and are popular for that reason. But this isnâ€™t a particular value that I have. I believe the DRY principle is important, and that often amounts to more concise code, but given modern editors and IDE, and modern expectations of typing and reading speed, a moderate amount of verbosity in exchange for other benefits (such as clarity and explicitness) is completely acceptable to me. I believe that default parameters, as they are implemented in C++ and Python, have a substantial cost in clarity and explicitness, and therefore conciseness isnâ€™t a good enough reason to justify them.</p>
<p>In this case, what particularly bothers me about the lack of clarity is that the reader of the code doesnâ€™t know that there are potentially more parameters; there is no hint that there might be other parameters. If a maintenance programmer wants to change one of these calls to make invisible windows instead, they might not realize they should check the documentation for create_window: after all, it only seems to take two parameters, and neither of them have anything remotely to do with invisible windows.</p>
<p>Fortunately, Rust has alternative features that allow us to reap the benefits for cognitive load and DRY without sacrificing explicitness and clarity.</p>
<h2 id="defaults-in-rust-the-default-trait"><a class="header" href="#defaults-in-rust-the-default-trait">Defaults in Rust: the Default trait</a></h2>
<p>Rather than allowing default parameters, Rust allows you to optionally specify default values for your types using the Default trait. Hereâ€™s how it works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
}

impl Default for Foo {
    fn default() -&gt; Self {
        Foo::Bar
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Or, written using the more concise derive syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum Foo {
    #[default]
    Bar,

    Baz,
}
<span class="boring">}
</span></code></pre></pre>
<p>Once this default is defined, Foo::default() or even (in a context where the type is clear) Default::default() can stand in for Foo::Bar.</p>
<p>If you are used to re-using existing types for your function parameters, this might seem worse than useless. After all, the parameter we defaulted was of type bool, and the orphan rule (explained in the Rust bookâ€™s chapter on traits) forbids us from defining the Default trait on bool â€“ as I alluded to above, Default allows you to define default values for your types. And even if we could, setting a default on booleans is way too overpowered a thing to do just to give this one function parameter have a default! After all, some other function might also have a boolean parameter with a different default.</p>
<p>But this makes more sense if you consider that in Rust, it is common â€“ even idiomatic and preferred â€“ to create custom types for things like configuration and function parameters. After all, if youâ€™re not looking at the documentation, it can be unclear what true means. Itâ€™s not even clear that it has anything to do with visibility, let alone that true means that the window is to be visible when the parameter could just as easily be called invisible.</p>
<p>In Rust, we would prefer to define a new type for this situation, an enum listing the visibility options â€“ which will also help if a new visibility option is created. And on this enum, it would be reasonable to declare a default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum WindowVisibility {
    #[default]
    Visible,

    Invisible,
}
<span class="boring">}
</span></code></pre></pre>
<p>Yes, this is more verbosity, but it is more clear, and no less DRY, than our original code. Conciseness is again not a value in and of itself. Explicitly listing the options is preferred to leaving them implicit.</p>
<p>Then, when we call the function, we can use this default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_window(width: u32, height: u32, visibility: WindowVisibility) -&gt; WindowHandle;

let handle = create_window(10, 30, WindowVisibility::Invisible);
let handle2 = create_window(100, 500, WindowVisibility::Visible);

let handle3 = create_window(100, 500, WindowVisibility::default());
let handle4 = create_window(100, 500, WindowVisibility::default());
let handle5 = create_window(100, 500, Default::default()); // Also permitted
<span class="boring">}
</span></code></pre></pre>
<p>This is, as promised, more verbose, but equally DRY, and much more explicit and clear.</p>
<p>NB: Iâ€™m using free-standing functions for example purposes only. In reality, this particular function is just as likely to be part of a typeâ€™s intrinsic methods, something like WindowHandle::new or WindowHandle::create_window.</p>
<h3 id="scaling-defaults-in-rust-struct-update-syntax"><a class="header" href="#scaling-defaults-in-rust-struct-update-syntax">Scaling defaults in Rust: Struct update syntax</a></h3>
<p>So this is all well and good for one default. But it doesnâ€™t scale that well. What if we want to add another 3 parameters to our window creation function? In a language like C++, we can give them defaults, and the callers donâ€™t even need to be updated (parameters are for example purposes only and do not represent a well-thought out list of what you might want to specify in creating a window):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WindowHandle createWindow(int width, int height, bool visible = true,
                          WindowStyle windowStyle = WindowStyle::Standard,
                          int z_position = -1,
                          bool autoclose = false);

createWindow(100, 500); // Still works identically
createWindow(100, 500, false); // Also still works
createWindow(100, 500, false, WindowStyle::Standard, 2, true); // Specify everything
<span class="boring">}
</span></code></pre></pre>
<p>This is a useful feature. In Rust, with the techniques weâ€™ve discussed so far, weâ€™d have to write Default::default() repeatedly for however many parameters there are. This is a DRY violation, and interferes with the ability to add new parameters.</p>
<p>There is a flaw with this feature, however. Youâ€™ve now constrained yourself to specifying parameters to the left in order to specify parameters on the right. In the last example call to createWindow, we violate DRY by explicitly specifying a value when we probably wanted to use the default, but that wasnâ€™t available because we wanted to override the default for a later parameter.</p>
<p>Fortunately, Rust has a version of this too. Just as we created an enum just for the purposes of this function call, it is idiomatic in Rust to create structures for configuration parameters like this. The structure would look something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowConfig {
    pub width: u32,
    pub height: u32,
    pub visibility: WindowVisibility,
    pub window_style: WindowStyle,
    pub z_position: i32,
    pub autoclose: AutoclosePolicy,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, we can implement Default for that entire struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for WindowConfig {
    fn default() -&gt; Self {
        Self {
            width: 100,
            height: 100,
            visibility: WindowVisibility::Visible,
            window_style: WindowStyle::Standard,
            z_position: -1,
            autoclose: AutoclosePolicy::Disable,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, this might seem to be extremely tedious to use. You might imagine using it something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = WindowConfig::default();
config.width = 500;
config.z_position = 2;
config.autoclose = AutoclosePolicy::Enable;
let handle = create_window(config);
<span class="boring">}
</span></code></pre></pre>
<p>I would argue that even this is preferable to default parameters, because again, it is explicit. However, Rust has a syntactic construct designed exactly for situations like this, struct update syntax. With it, we get something very similar to default parameters, but a little more verbose, a lot more explicit, and a lot more flexible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = create_window(WindowConfig {
    width: 500,
    z_position: 2,
    autoclose: AutoclosePolicy::Enable,
    ..Default::default()
});
<span class="boring">}
</span></code></pre></pre>
<p>Unlike C++-style default parameters, we can override exactly the defaults we want to. It is also explicitly clear that there are other parameters we could modify if we wanted to, without forcing the maintenance programmer to check the documentation.</p>
<p>But beyond that, this allows there to be other sets of defaults defined. In addition to WindowConfig::default, there might be another set of configuration parameters for creating dialog boxes, like WindowConfig::dialog() or WindowConfig::default_dialog. An app where the programmer usually creates invisible windows, or windows all of the same height, might define its own default set, config::app_local_default_window_config(). These wouldnâ€™t be mediated through the Default trait, but Default is just a trait, and Default::default() is just a method call. You can call your own methods instead, and still use this struct update syntax.</p>
<p>So now, we have a system of idioms in Rust to replace default parameters. Itâ€™s just as DRY, and decreases the cognitive load just as much. More importantly, it does so without sacrificing explicitness and clarity as to exactly whatâ€™s going on â€“ a given function always takes the same number of parameters, which is an invariant that Rust maintenance programmers can (and do) rely on.</p>
<h3 id="the-builder-pattern"><a class="header" href="#the-builder-pattern">The Builder Pattern</a></h3>
<p>At this point, the old-hand Rustaceans in the audience will note that I havenâ€™t discussed one common Rust approach to designing these configuration structs, the builder pattern.</p>
<p>Thatâ€™s for a reason: I donâ€™t like it. I personally prefer to use Default and struct update syntax where others might reach for the builder pattern. I think itâ€™s less explicit, and since I have a lot of experience in non-OOP programming languages, it feels to me like a solution without a problem, the primary upshot of which is to make the code look more object-oriented.</p>
<p>But it is a commonly used pattern in Rust, and you will use crates that use the builder pattern, so itâ€™s worth being familiar with it. Itâ€™s the same concept as before: using a struct full of parameters to send configuration to a constructor or to a function call. Itâ€™s probably going to be called something like WindowBuilder instead of WindowConfig.</p>
<p>However, instead of using the struct update syntax directly, a bunch of helper methods are added to do the struct update:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Or, as I would notate it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(self, height: u32) -&gt; Self {
        Self {
            height,
            ..self
        }
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Sometimes, enumerations are split into multiple update methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn autoclose_enable(mut self) -&gt; Self {
        self
        self.autoclose = AutoclosePolicy::Enable;
    }

    fn autoclose_disable(mut self) -&gt; Self {
        self.autoclose = AutoclosePolicy::Disable;
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, normally, instead of calling e.g. the window constructor, you call a build method defined on the builder (and at this point I cringe at the gratuitous OOP philosophy influencing the design):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn build(self) {
        window_create(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, instead of using struct update syntax, you chain together calls to these methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = WindowBuilder::new()
    .width(500)
    .z_position(2)
    .autoclose_enable()
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>I still prefer this to default parameters, but I also find it tacky. I donâ€™t like being forced to think in terms of abstract â€œobjectsâ€ like builders, and I donâ€™t like the presumption that this style is more intuitive. Why is a â€œbuilderâ€ an object that does something? Why is that prefered to a structure that is â€œconfigurationâ€? Are OOP programmers aware that in real life, the vast majority of objects literally donâ€™t do things, and certainly donâ€™t build other objects?</p>
<p>But for people familiar with the idioms of object-oriented programming, this might be preferable. It is a commonly chosen option, so itâ€™s important at least to recognize it.</p>
<h2 id="conclusion-and-application"><a class="header" href="#conclusion-and-application">Conclusion and Application</a></h2>
<p>Rust has a lot of idioms that are different from those in other programming languages. I often see proposals from new Rustaceans to add default parameters â€“ and other similar features â€“ to Rust, and these new Rustaceans are confused that the strong demand they feel is not as widely felt in the greater Rust community.</p>
<p>And normally, itâ€™s similar to this situation with default parameters. There are alternative idioms that accomplish the same goals, to the extent that those goals are in line with Rustâ€™s values: in this case, DRYness, and reducing developers' cognitive loads. They are also better solutions in some other ways, according to Rusty values: the additional explicitness is worth a little more verbosity.</p>
<p>But often, the new Rustaceans making these proposals are unaware of the Rusty way of doing things. And if they are aware of it, they are approaching it from the goals of other programming languages, and donâ€™t see how the solution measures up.</p>
<p>So I hope this can serve as a case study to help people understand that there often are Rusty ways of accomplishing the goals of popular features from OOP land, and why Rustaceans prefer these solutions to blind accumulation of features.</p>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<blockquote>
<p>ç‰ˆæœ¬è®°è¦</p>
</blockquote>
<ul>
<li>..</li>
<li>230212 ZQ init.</li>
</ul>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../tip/rust6fun-operator-overloading.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../101/index.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../tip/rust6fun-operator-overloading.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../101/index.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script>
        window.playground_copyable = true;
    </script>


    <script src="../elasticlunr.min.js" charset="utf-8"></script>
    <script src="../mark.min.js" charset="utf-8"></script>
    <script src="../searcher.js" charset="utf-8"></script>

    <script src="../clipboard.min.js" charset="utf-8"></script>
    <script src="../highlight.js" charset="utf-8"></script>
    <script src="../book.js" charset="utf-8"></script>

    <!-- Custom JS scripts -->


    <hr />

    <p style="text-align:center">

        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="çŸ¥è¯†å…±äº«è®¸å¯åè®®"
                style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
        æœ¬ä½œå“é‡‡ç”¨<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">çŸ¥è¯†å…±äº«ç½²å-ç›¸åŒæ–¹å¼å…±äº« 4.0 å›½é™…è®¸å¯åè®®</a>è¿›è¡Œè®¸å¯;-)

    </p>
    <hr />

    <script src="https://utteranc.es/client.js" repo="zhrust/comments" issue-term="pathname" label="âœ¨ğŸ’¬âœ¨"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>

</html>