<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>BMP:最小bug模式 - be Rustaceans</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="如何成为一名合格的 Rustacean ? 肯定有个过程, 这儿记录了私人这个转化过程...">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../favicon.svg">
    <link rel="shortcut icon" href="../favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../theme/style.css">


</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="../abt/index.html">成为 Rustacean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../abt/gh-pages.html">gh-pages</a></li><li class="chapter-item "><a href="../abt/zhrust.html">zhrust</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">自学练习</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../101/index.html">Rust 学习</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../101/chatgpt101.html">伴学ChatGPT</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../101/chat_dyn101.html">dyn 初步</a></li></ol></li><li class="chapter-item "><a href="../101/idioms.html">idioms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../101/idiom325_create_a_queue.html">idiom#325:构造队列</a></li></ol></li><li class="chapter-item "><a href="../101/quiz.html">Quiz.rs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../101/quiz_1.html">Quiz#1</a></li></ol></li><li class="chapter-item "><a href="../101/exercism.html">Exercism</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../101/ex42all-your-base.html">42:all-your-base</a></li><li class="chapter-item "><a href="../101/ex43Allergies.html">43:Allergies</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">实践🌚🌘🌗🌖🌝</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../dev/index.html">Rust 开发</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/dama-projects.html">小作品</a></li><li class="chapter-item "><a href="../dev/tui4cli.html">TUI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/cli_nnera.html">🌖 NNera</a></li><li class="chapter-item "><a href="../dev/cli_ferris_art.html">🌝 Ferris艺术</a></li><li class="chapter-item "><a href="../dev/cli_bxmr.html">🌝 BXMr</a></li><li class="chapter-item "><a href="../dev/cli_rss4mdbook.html">🌝 RSS4mdbook</a></li><li class="chapter-item "><a href="../dev/cli_yuzu.html">🌚 Yuzu</a></li></ol></li><li class="chapter-item "><a href="../dev/web4async.html">异步</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/tokio.html">Tokio</a></li><li class="chapter-item "><a href="../dev/graphql.html">GraphQL</a></li></ol></li><li class="chapter-item "><div>TTD</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/rust-unit-test-everything-wanted-know.html">Rust 单元测试得知道的一切</a></li><li class="chapter-item "><a href="../dev/debug_rust_with_codelldb.html">CodeLLDB</a></li></ol></li><li class="chapter-item "><a href="../dev/gui4web.html">GUI</a></li><li class="chapter-item "><a href="../dev/embedded_rs.html">嵌入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/emb_rp2040pico.html">Pico</a></li></ol></li><li class="chapter-item "><div>CI/CD</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/cross-compiling.html">交叉编译?</a></li></ol></li><li class="chapter-item "><a href="../dev/20-things-ive-learned-in-my-20-years-as-a-software-engineer.html">20年来作为软件工程师学到的10件事</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/concepts-i-wish-i-learned-earlier.html">希望一早知道的关键概念</a></li></ol></li><li class="chapter-item "><div>实用工具推荐...</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dev/cli_btm.html">Bottom</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">工程经验</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../tip/index.html">Rust 技能</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tip/awesome4rs.html">Awesome.rs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tip/aw4rs_handlebars.html">Handlebars</a></li><li class="chapter-item "><a href="../tip/tracing.html">tracing 初步</a></li><li class="chapter-item "><a href="../tip/open_big_file_speed.html">文件加速打开</a></li></ol></li><li class="chapter-item expanded "><a href="../tip/rust_min_bug_patterns.html" class="active">BMP:最小bug模式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tip/manag_growing_proj_with_crates_modules.html">Crate中合理划分目录</a></li></ol></li><li class="chapter-item "><div>anti-OOP</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tip/default-params.html">OOP:Rust 和默认参数</a></li><li class="chapter-item "><a href="../tip/oop-1-encapsulation.html">Rust 超越OOP,第1部分</a></li><li class="chapter-item "><a href="../tip/oop-2-polymorphism.html">Rust 超越OOP,第2部分</a></li></ol></li><li class="chapter-item "><a href="../tip/rust6fun-operator-overloading.html">运算符重载六件趣事</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">笔记嗯哼</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../log/index.html">笔记</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../log/rust101logging.html">Rust 课程笔记</a></li><li class="chapter-item "><a href="../log/rust-s-ugly-syntax.html">Rust 丑句法</a></li><li class="chapter-item "><a href="../log/graph-rust-move-copy-borrow.html">图形描述 Rust 中所有权和借用</a></li><li class="chapter-item "><div>Choas嗯哼</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../log/c101.html">0基础入门C?</a></li><li class="spacer"></li></ol></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">be Rustaceans</h1>

                <div class="right-buttons">
                    <a href="https://github.com/zhrust/rustacean/tree/main/src" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    <a href="https://github.com/zhrust/rustacean/blob/main/src/src/tip/rust_min_bug_patterns.md" title="Suggest an edit" aria-label="Suggest an edit">
                        <i id="git-edit-button" class="fa fa-edit"></i>
                    </a>

                    <a href="/rss.xml" title="RSS.xml" aria-label=""RSS.xml">
                        <b id="git-edit-button" class="fa fa-feed"></b>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <h1 id="bmp最小bug模式"><a class="header" href="#bmp最小bug模式">BMP:最小bug模式</a></h1>
<p>原文: <a href="http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/">Rust Bug Minimization Patterns - The {pnk}f(eli)x Blog</a></p>
<blockquote>
<p>Update 19 November 2019: fixed miscellaneous typos and a bug in the invariance example pointed out by readers both privately and on reddit thread. I also added a section near the beginning to draw attention to techniques that are somewhat Rust-specific and may not be broadly known.</p>
</blockquote>
<blockquote>
<p>快译:</p>
</blockquote>
<p>嗯哼, 俺来也!</p>
<p>之前一直忙于 Rust 编译器任务,
所以,这几个月没更新; 现在有了!</p>
<p>最近当俺处理一些特别讨厌的 bug 时,
在 bug 最小化并上投入了大量精力:
采用大型测试用例并找到从测试中删除代码的办法,
同时保留测试显露相同 bug 的能力过程;</p>
<p>在我工作时, 突然意识到, 其实自己在遵循一个有点儿机械的过程;
我使用常规模式进行代码转换;
在某个时刻, 我想说:&quot;
你知道, 我不确定是否每个入都知道这些模式;
我只记得其中一些,
而我正在进行错误最小化过程/BMS;
&quot;</p>
<p>由于 Rust 编译团队总是希望帮助新手学习他们可以为项目作出贡献的方式,
我意识到这可能就是 blog 文章的理想主题;</p>
<p>而且,为了尽量使事情具体化,
我将尝试通过展示一个被最小化的实际错误来推动演示;
(或者更加确切的说,我将重新复现已经完成过的 BMS/最小化;
因此,如果我似乎能很精确的选择总是有效的转换:
你感觉对了, 的确在作弊, 并没告诉你所有的错误路径,
其实都在第一次 BSM 过程中都遭受过, 就象odyssey听过的海妖魔音...
)</p>
<h2 id="rust-细节"><a class="header" href="#rust-细节">Rust 细节</a></h2>
<blockquote>
<p>The Rust specifics</p>
</blockquote>
<p>嗯哼,还有件事儿: 
这儿的很多想法其实适用各种语言,
因此,你们已经听说过, 又或是独立发现过了;</p>
<p>然而, 一些技术使用了 Rust 之外不通用的语言特性;</p>
<p>具体来说:</p>
<ul>
<li>“cfgmenting” 利用 Rust 的属性系统以轻快的方式删除条目;</li>
<li>“loopification” 利用 Rust 允许分散表达式循环 {} 能被分配任何类型的事实;</li>
<li>“loopification” 通过 pretty-printer 能循环利用编译器 (unstable) 能力为所有函数体注入循环 {}</li>
<li>将模块树一分为二, 利用 Rust 混合支持内联和外联模块, 能允许快速交换代码块进出;</li>
</ul>
<p>那么,事不宜迟: 这就是我最小化 rust-lang/rust#65774 的探险之旅:</p>
<hr />
<h2 id="曲折的哲学"><a class="header" href="#曲折的哲学">曲折的哲学</a></h2>
<blockquote>
<p>Philosophical meandering</p>
</blockquote>
<h3 id="最小到底什么意思"><a class="header" href="#最小到底什么意思">&quot;最小&quot;到底什么意思?</a></h3>
<blockquote>
<p>What does “minimal” mean anyway?</p>
</blockquote>
<p>&quot;最小&quot;测试用例的目标可能意味着代码行最小; 又或是字符数;
尽量减少源文件数量也有好处:
一个文件, 可以剪切并粘贴到 play.rust-lang.org 就很好;</p>
<blockquote>
<p>还有入甚至可以争辩说, 在最小化时, 抽象语法树中的节点数是比面向文本层次的指标要更加好;</p>
</blockquote>
<p>以这种正式最小化源代码测试可以产生一个良好的回归测试候选,
以便在(希望是)最终修复错误时,将其追加到编译器测试套件中;</p>
<p>但是, 那些最小化语法树节点指标忽略了一些东西:
当最小化错误代码时, 我自己的最终目标是更好的理解错误, 
也就是更好的理解我自己, 以及阅读测试用例的其它开发者;</p>
<blockquote>
<p>我是从 rustc 开发者角度来写这篇文章的;
所以, 我可能对什么是有用的, 或是什么是最小的, 有轻微的偏见;</p>
</blockquote>
<p>基于这种理解, 还有其它指标需要牢记:</p>
<ul>
<li>Minimize the amount of time the compiler runs before it hits the bug.</li>
</ul>
<p>Minimizing the compiler’s execution time before failure serves two purposes:</p>
<ol>
<li>It makes every future run of this test faster, which can accelerate your pace of minimization.</li>
<li>When the rustc developers themselves examine the behavior of the compiler on the test, they will be grateful to have a shorter execution trace of the compiler to analyze.</li>
</ol>
<p>(Such time reduction often occurs anyway when you remove lines of code and/or dependencies; I just want to point out that it has value in its own right.)</p>
<blockquote>
<p>As a concrete example of how reducing imports may help expose a bug’s root cause: some people will have a bug that occurs with some combination of #[derive(Debug)] and a call to format! or write, and the test showing the problem may be only a few lines long. But it hides a lot of complexity behind those uses of derive, macros, and std::io trait machinery; a longer test that defines its own trait, a local impl of that trait, and a small function illustrating the same bug, may make the bug more immediately apparent to a rustc developer.</p>
</blockquote>
<ul>
<li>Minimize dependencies: reduce the number of language features in use and the number of imports your test uses from other crates (including the std library!).</li>
</ul>
<p>This can help expose the essential cause of the bug, potentially making it immediately apparent what is occurring.</p>
<ul>
<li>Minimize your jumping around in the source code.</li>
</ul>
<p>If you can fit all the code needed to recreate the bug onto your monitor screen at once, by any means necessary, that is a serious accomplishment. Less time spent scrolling through a file or switching editor windows is more time you can spend thinking about the bug itself.</p>
<p>To be clear: Often a minimum amount of code needed for understanding does correlate with a minimum amount of code needed for reproduction. (This explains why using lines-of-code or the size of the syntax tree as a metric can be useful when reporting a bug.)</p>
<p>The over-arching goal in minification is to remove all distractions: to reduce the problematic input (in this case, Rust source code) to its essence: a minimal amount necessary to understand the problem.</p>
<h3 id="why-not-build-it-up-from-scratch"><a class="header" href="#why-not-build-it-up-from-scratch">Why not build it up from scratch?</a></h3>
<p>Its worth pointing out that at some point, maybe even at the outset, you may have a sufficiently rich understanding of the bug that you can go straight to building up a minimal example from scratch. And that’s great , go for it!</p>
<p>However, this post is dedicated to the problem of what you can do when you haven’t hit that level of understanding. When you’re looking at a set of files that make up over 90,000 lines of code, you want a set of semi-mechanical techniques to take that test input and strip it down to its essence.</p>
<p>To be honest, the most effective methodology is going to use a blend of build-up and tear-down. As you are tearing down the 90,000 lines of code, there should be a voice in the back of your head asking “can we now try what we’ve learned to try to build up a minimal example?”</p>
<hr />
<h2 id="assumptions-and-conventions"><a class="header" href="#assumptions-and-conventions">Assumptions and Conventions</a></h2>
<blockquote>
<p>Some of the techniques may also be applicable to cases where the compiler is accepting code that it should be rejecting; but I am little wary of advertising these tools for use in that context, which is why you’re reading this in the margin and not the main text.</p>
</blockquote>
<p>The tests I am talking about minimizing in this post are cases where the compiler itself fails in some way: an ICE, a link failure, or rejecting code that it should be accepting. Bugs that are witnessed by actually running the generated code are, for the most part, not covered by the patterns here. In particular: many of the patterns presented here rely on making semantic changes to the input: changing values, or replacing complex expressions with something trivial like loop { }.</p>
<p>I named each transformation, usually with absurd made-up words like “unusedification”. They are all in explicit quotation marks to try to make it clear that I am speaking nonsense, deliberately.</p>
<blockquote>
<p>I had originally planned to structure this post so that all transformations for a given theme would be present together, so that you’d see all the transformations for that theme at once. But as I wrote, it became clear over the course of actually doing a reduction, then we often bounce around between transformations, and it usually does not end up being nicely grouped with all transformations for one theme colocated in time. So rather than using that hierarchical presentation, I am instead just going to try to mention the grouping by marking each as transformation being part of a “theme”.Several of the transformations serve similar goals, like “delete the unnecessary”. I have attempted to categorize the different tranformations according to what purpose they serve in the minimization process. Over the course of documenting these transformations, I identified the following themes:</p>
</blockquote>
<ul>
<li>Simplify Workflow: Make your own life easier.
<ul>
<li>Enable Incremental Steps</li>
</ul>
</li>
<li>Delete the Unnecessary: Remove items not related to bug!</li>
<li>Identify the Unnecessary: Eliminate accidental necessity.</li>
<li>Trivialize Content: Turn complex expressions to trivial ones.</li>
<li>Eliminate Coupling: Break links between items.</li>
</ul>
<h2 id="notes-on-notation"><a class="header" href="#notes-on-notation">Notes on Notation</a></h2>
<p>In this post, I follow typical notation by using ... as a placeholder for (possibly relevant) code that will be kept approximately the same (modulo mechanical updates like alpha-renaming) by a transformation. However, I also use the non-standard notation of ---- for irrelevant code that removed via a transformation. This is meant to draw attention to the distinct kinds of code, so that you can more easily tell which code is being removed by a particular transformation.</p>
<p>Sometimes I will show an explicit regexp that I am feeding to a tool to do the transformation, but usually I will stick to informal patterns with the aforementioned ... and ---- placeholders.</p>
<p>When a given item or expression can appear within the context of a middle of a sequence (e.g. consider { ... THING ... }), I often use the standard shorthand of just writing { THING ... } or { ... THING }, to simplify the textual presentation and focus attention on the transformation itself.</p>
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="record-your-steps"><a class="header" href="#record-your-steps">Record your steps</a></h2>
<p>Before you do any reduction, move the test case into its own local git repository (or whatever versioning tool you prefer: SVN, RCS, etc). Being able to backtrack through previous reduction steps is an incredibly important option when doing this kind of of work.</p>
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="continuously-test-the-test"><a class="header" href="#continuously-test-the-test">Continuously test the test.</a></h2>
<p>Finally: A crucial part of reduction is to continuously double-check that the bug still reproduces after every reduction step. I’ll show the command line invocation on occasion, but not every command line build invocation (the output is usually the same on every run, so it would just clog up the flow of the presentation here). But even though I don’t show every invocation, you can believe that I was doing the runs. (And in the cases where I tried to skip doing a run, I usually regretted it and had to backtrace my steps to the state before an attempted reduction.)</p>
<p>Make it easy to do your runs. Use your IDE. I use emacs, so I make a M-x compile invocation that runs the compiler with the right arguments, and then you can hit g in the <em>compilation</em> buffer to re-run the compile.</p>
<hr />
<h2 id="the-test-case"><a class="header" href="#the-test-case">The test case</a></h2>
<p>As I mentioned at the start: The presentation here will be driven by referencing a concrete test case that I reduced recently: we have been given a crate graph, and we can observe a bug when we build as follows:</p>
<pre><code>
% ( cd tock/boards/arty-e21/ &amp;&amp; \
    RUSTFLAGS=&quot;-C link-arg=-Tlayout.ld&quot; \
    cargo build --target riscv32imac-unknown-none-elf )
   Compiling tock-registers v0.4.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-register-interface)
   Compiling tock-cells v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-cells)
   Compiling tock_rt0 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-rt0)
   Compiling enum_primitive v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/enum_primitive)
   Compiling kernel v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/kernel)
   Compiling riscv-csr v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/riscv-csr)
   Compiling rv32i v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/arch/rv32i)
   Compiling capsules v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/capsules)
   Compiling sifive v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/sifive)
   Compiling arty_e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/arty_e21)
   Compiling components v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/boards/components)
   Compiling arty-e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/boards/arty-e21)
error: internal compiler error: src/librustc/traits/codegen/mod.rs:127: Encountered errors `[FulfillmentError(Obligation(predicate=Binder(TraitPredicate(&lt;() as core::fmt::Display&gt;)), depth=1),Unimplemented)]` resolving bounds after type-checking
</code></pre>
<p>In reality the command line was a little more complicated:</p>
<pre><code class="language-shell">
% ( cd tock/boards/arty-e21/ &amp;&amp; \
    RUSTFLAGS=&quot;-C link-arg=-Tlayout.ld -C linker=rust-lld -C linker-flavor=ld.lld -C relocation-model=dynamic-no-pic -C link-arg=-zmax-page-size=512&quot; \
    cargo build --target riscv32imac-unknown-none-elf   )
...
error: internal compiler error: src/librustc/traits/codegen/mod.rs:127: Encountered errors `[FulfillmentError(Obligation(predicate=Binder(TraitPredicate(&lt;() as core::fmt::Display&gt;)), depth=1),Unimplemented)]` resolving bounds after type-checking
</code></pre>
<blockquote>
<p>An eagle-eyed reader might look at that ICE message and immediately consider grepping the source code, such as uses of the trait bound core::fmt::Display. A fine idea, but intuitive jumping to an answer is not what I’m focusing on here.</p>
</blockquote>
<p>but for the purposes of the experiments presented in this blog post I will use the simplified invocation. (The difference only matters once we hit cases where the bug goes away.)</p>
<p>Remember that 90,000 lines of code number that I mentioned a few paragraphs ago? It didn’t come out of nowhere:</p>
<pre><code class="language-shell">% find tock/ -name *.rs | xargs wc
...
   91958  317229 3150451 total

</code></pre>
<p>So this is an excellent example of an input that we really want to reduce down to something smaller.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="tactic-reduce-the-driving-code-first"><a class="header" href="#tactic-reduce-the-driving-code-first">Tactic: Reduce the driving code first</a></h2>
<p>We have many input files, and they make up a crate graph with at least 13 crates in it.</p>
<p>We know from our command line invocation that it is the build of boards/arty-e21 that is exposing the ICE. It would be good to remove unnecessary crates from the crate graph for boards/arty-e21. But to do that most effectively, we need to first discard as many imports as possible from boards/arty-e21, and then work our way backwards through the dependency chain.</p>
<p>So, will start by reducing the boards/arty-e21 crate to the minimum necessary to reproduce the bug.</p>
<p>This single crate is a much easier thing to work with:</p>
<pre><code class="language-shell">% find tock/boards/arty-e21/ -name '*.rs' | xargs wc
       4       6     124 tock/boards/arty-e21//build.rs
      27      68     565 tock/boards/arty-e21//src/timer_test.rs
      40     101     959 tock/boards/arty-e21//src/io.rs
     279     667    9135 tock/boards/arty-e21//src/main.rs
     350     842   10783 total

</code></pre>
<p>However, we still want to reduce it as much as we can: Every import we can remove from arty-e21 represents swaths of code that we might be able to remove in the rest of the crate graph.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="technique-mod-inlining"><a class="header" href="#technique-mod-inlining">Technique: “mod-inlining”</a></h2>
<p>This technique may surprise some: I like to reduce the number of files involved early in the game, if I can. An easy way to do this is to replace the out-of-line mod foo; item with its inline counterpart: mod foo { ... }. Here the out-of-line module file content has been cut-and-pasted into an inline mod item.</p>
<p>Strictly speaking, moving from mod foo; to mod foo { ... }does not reduce the input: You still have all the same content that you started with, the compiler has to do the same amount of work, et cetera.</p>
<p>However, I still prefer to do it, because I find that it helps with later reduction steps if I can do my transformations on a single file.</p>
<p>There two techniques I use for “mod-inlining”:</p>
<ol>
<li>Manually cut-and-paste: take each instance of mod foo; in the root file, and find that module’s contents. Then replace the ; with { and }, and finally paste the contents in between the curly brackets you just added. You don’t even have to re-indent it if you don’t want to.</li>
</ol>
<blockquote>
<p>Its not like this is Python!</p>
</blockquote>
<p>For a small module tree, such as we find in boards/arty-e21, manually cut-and-pasting is entirely reasonable. But if you have a large module tree, with many directories and files, it can become tedious and error-prone.</p>
<ol start="2">
<li>Alternative: use rustc to expand the module-tree. You can add --verbose to the cargo build invocation to see the actual rustc command line invocation cargo is using, and then you can add -Z unstable-options --pretty=expanded to that rustc invocation, piping the output to a new rust source</li>
</ol>
<blockquote>
<p>Warning: this will not only expand the module tree: it will also expand all the macro invocations, including #[derive] attributes. This can be a bit overwhelming. (I am continually tempted to add a new unstable --pretty variant that just expands the module tree but does not expand the macros otherwise.)</p>
</blockquote>
<p>I will show a concrete example of using rustc in this way later in the blog post. But for now I will just manually cut-and-paste the contents of boards/arty-e21/src/timer_test.rs and boards/arty-e21/src/io.rs into main.rs</p>
<p>After doing the inline, make sure the bug reproduces.</p>
<p>It is up to you whether you want to delete the out-of-line module files. Today, Rust does not treat their presence as some sort of conflict with the inline definition. You will see later in the post cases where keeping them around on the file-system can be useful. But for the case of boards/arty-e21, I will go ahead and delete them.</p>
<blockquote>
<p>Checking for unused out-of-line module files might be a nice lint for someone to add to rustc.</p>
</blockquote>
<pre><code class="language-shell">% find tock/boards/arty-e21/ -name *.rs | xargs wc
       4       6     124 tock/boards/arty-e21//build.rs
     348     840   10665 tock/boards/arty-e21//src/main.rs
     352     846   10789 total

</code></pre>
<p>As expected, this didn’t reduce the line count. But it did make it so we can work with a single file at the leaf. That simplifies my own workflow.</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="tactic-decommentification"><a class="header" href="#tactic-decommentification">Tactic: “Decommentification”</a></h2>
<p>This may be obvious, but it is a step that I often forget to do at the outset of test reduction, even though it is easy and pays off handsomely.</p>
<p>Comments in code are typically there to explain or justify some detail of the implementation. When diagnosing compiler bugs, the purpose of the original code is usually not relevant. You are better off increasing the number of lines of actual code that you can fit on your screen at once.</p>
<p>In short, the transformation looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>^        //...$

<span class="boring">}</span></code></pre></pre>
<p>to <empty-string></p>
<p>In this case, I have used ^ and $ as markers for the beginning and end of lines (just like in regexps).</p>
<p>Or, as an Emacs M-x query-replace-regexp input: ^ <em>//.</em>^J* (and empty string as replacement text).</p>
<blockquote>
<p>The ^J there is a carriage-return inserted via M-x quoted-insert (aka C-q) in Emacs.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Why I use M-x query-replace-regexp: it previews the matches, I verify a few by eye, and then hit ! to do all the remaining replacements.</p>
</blockquote>
</blockquote>
<p>Another related transformation: get rid of the other blank lines that are not preceded by comments. I leave that regexp as an exercise for the reader.</p>
<p>In the case of boards/arty-e21, this got rid of 53 lines of comments (and blank lines succeeding them):</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
     295     575    8551 tock/boards/arty-e21/src/main.rs

</code></pre>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h2 id="tactic-body-loopification"><a class="header" href="#tactic-body-loopification">Tactic: “Body Loopification”</a></h2>
<blockquote>
<p>see also: “none-defaulting”“Loopification” </p>
</blockquote>
<p>removes the body of a given function or method item, replacing it with loop { }.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(...) -&gt; ReturnType { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(...) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>You might choose to use alternatives like unimplemented!(). I personally like loop { } because its something you almost never see in other people’s code, so its easy to search for and be pretty certain that it was introduced as part of reduction. Also loop { } relies on less machinery from the core library than unimplemented! does.</p>
</blockquote>
<p>The use of loop { } is deliberate: since loop { } is known by the compiler to diverge, it can be assigned any type at all. So this transformation can be performed blindly.</p>
<ul>
<li>Note that this does not work for const fn; the compiler currently rejects const fn foo() { loop { } } as invaild syntax.</li>
<li>Also, it generally will not work for impl Trait in return position: the compiler needs a concrete type to assign to the impl Trait, and loop { } will not suffice for that unless you ascribed it a non-! type in some manner.</li>
</ul>
<p>When it comes to replacing a function body with loop { }, you may be able to get help from your IDE. In my own case, I have often used Emacs M-x kill-sexp to delete the { ---- } block in fn foo { ---- }</p>
<blockquote>
<p>More specifically, I have used Emacs to define a keyboard macro (via C-x () that: 1. searches for the next occurrence of fn, 2. searches forward from there for the first {, which often (but not always) corresponds to the start of the function’s body, 3. runs M-x kill-sexp to delete the { ---- } and 4. types in { loop { } }, replacing the method body. This is incredibly satisfying to watch in action.</p>
</blockquote>
<p>If you want to take a risk, you can ask rustc to do the replacement of fn bodies with loop { } for you as part of pretty-printing via the -Z unpretty=everybody_loops flag. I’ll speak more on that later.</p>
<p>Once the body has been removed, you can optionally replace all of the formal parameters with _:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: A, b: B, ...) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: A, _: B, ...) -&gt; ReturnType { loop { } }
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>These explicit marks can be useful as hints for future reduction steps; see “genertrification”)</p>
</blockquote>
<p>This is essentially a special case of “unusedification”; we do not delete the parameters outright yet (see “param-elimination” for that), but we mark them as completely useless by writing them as _: ParamType.</p>
<p>In the case of board/argy-e21/main.rs, there was one const fn, and you cannot “loopify” that. For the other fn’s, I was able to replace all but the last fn body with loop { }. (Replacing the last one made the bug go away.)</p>
<ul>
<li>In practice, the ICE diangostic often gives me some hint about which fn is the problem, and therefore I can blindly replace the other fn bodies with loop { }.</li>
<li>But even without such a hint, once can often bisect over the set of fn’s to try to identify a maximal subset that can have their bodies replaced with loop { }. We will talk more about how to do such bisection later.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>% wc tock/boards/arty-e21/src/main.rs
     262     523    7584 tock/boards/arty-e21/src/main.rs

<span class="boring">}</span></code></pre></pre>
<p>(Okay, only removing 33 lines of code might not be very impressive. The technique will pay off more as we move further along.)</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h2 id="tactic-expr-elimination"><a class="header" href="#tactic-expr-elimination">Tactic: “Expr-elimination”</a></h2>
<p>Even if you were not able to replace a whole fn body with loop { }, you can usually simplify the fn bodies that remain now.</p>
<blockquote>
<p>themes: Trivialize Content, Identify the Unnecessary</p>
</blockquote>
<h3 id="technique-suffix-bisection"><a class="header" href="#technique-suffix-bisection">Technique: Suffix-bisection</a></h3>
<p>In this case, I recommend a form of bisection where you first comment out the bottom half of the original fn-body, and see if the problem reproduces.</p>
<ul>
<li>Why comment out the latter half? Well, if you comment out the top half, you’re almost certainly going to comment out let-bindings that the bottom half relies on. The top half very rarely relies on items in the bottom half.</li>
<li>If the fn in question has a return type, then you can usually use a loop { } as a tail-expression at the end of the fn-body to satisfy the return-type; a natural variant of “loopification”.</li>
</ul>
<p>If it does reproduce without the bottom half, then you can delete that half, and recursively process the top half.</p>
<p>If it doesn’t reproduce, then the bug relies on something in the bottom half. If you’re lucky, it only relies on stuff in the latter half, and you can try deleting the top half now. But even if you’re “unlucky” and the bottom half relies on stuff in the top half, you leave the top half in place (at least for now) and recursively process the bottom half, narrowing the code until you can identify a single statement whose presence or absence is the line between triggering the ICE or not.</p>
<p>If the fn is too large for fit on one screen, then I use M-x forward-sexp to identify the start and end of the fn-body. Then I jump to a line in the middle, and search around for the start of a statment in the body, and then comment out everything from that statement forward in /* ... */</p>
<p>In the case of boards/arty-e21/src/main.rs, this meant commenting out from line 191 through 263.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
    let gpio_pins = static_init!(
    ...

    board_kernel.kernel_loop(&amp;artye21, chip, None, &amp;main_loop_cap);
*/

<span class="boring">}</span></code></pre></pre>
<p>And, “darn”: It didn’t work. The bug disappeared. But: This is okay! We still have learned something: Something in the latter half is causing the bug. So bisect that latter half (again, favoring commenting out second halves).</p>
<p>Eventually, by recursively processing the suffix statements, we identify that the bug does not reproduce with this code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    ...
/*
    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;_sapps as *const u8,
        &amp;mut APP_MEMORY,
        &amp;mut PROCESSES,
        FAULT_RESPONSE,
        &amp;process_mgmt_cap,
    );

    board_kernel.kernel_loop(&amp;artye21, chip, None, &amp;main_loop_cap);
*/
}

<span class="boring">}</span></code></pre></pre>
<p>but does reproduce with this code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    ...
    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;_sapps as *const u8,
        &amp;mut APP_MEMORY,
        &amp;mut PROCESSES,
        FAULT_RESPONSE,
        &amp;process_mgmt_cap,
    );

/*
    board_kernel.kernel_loop(&amp;artye21, chip, None, &amp;main_loop_cap);
*/
}

<span class="boring">}</span></code></pre></pre>
<p>So, now we have identified a function call to load_processes that seems to be intimately related to the bug.</p>
<p>Unfortunately, load_processes is an item defined in an external crate. (We will deal with that eventually.)</p>
<p>Now that we’ve identified this function call to load_processes as part of the cause of the bug, the new goal is to simplify the earlier part of the function to the bare minimum necessary to support this function call.</p>
<blockquote>
<p>In all of these cases, if an otherwise unused statement or expression influences the type-inference for the body, you may need to keep it around, or some variant of it.</p>
</blockquote>
<ul>
<li>Get rid of all non-binding statements. (We should not need any side-effecting computations to reproduce the bug.)</li>
<li>Initialize things to their default values (see “Defaultification” below).</li>
<li>Eliminate unused lets (see “Unusedification” below).</li>
</ul>
<p>After applying those steps repeatedly, and further “decommentification”, we are left with this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn reset_handler() {
    let chip = static_init!(arty_e21::chip::ArtyExx, arty_e21::chip::ArtyExx::new());
    let process_mgmt_cap = create_capability!(capabilities::ProcessManagementCapability);
    let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&amp;PROCESSES));

    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;0u8 as *const u8,
        &amp;mut [0; 8192], // APP_MEMORY,
        &amp;mut PROCESSES,
        kernel::procs::FaultResponse::Panic,
        &amp;process_mgmt_cap,
    );

}

<span class="boring">}</span></code></pre></pre>
<p>Just checking: the bug still reproduces, and we now have:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
     111     289    2807 tock/boards/arty-e21/src/main.rs

</code></pre>
<p>Its not 100% minimized yet, but its about as far as we can go in changes to fn reset_handler without making changes to crates upstream in dependency graph.</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="tactic-unusedification"><a class="header" href="#tactic-unusedification">Tactic: “Unusedification”</a></h2>
<p>Another way to remove distractions: remove them.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>non_pub_locally_unused_item(----) { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to <empty-string></p>
<p>At this point, after our initial round of “loopification”, we should have a lot of unused stuff: variables, struct fields, imports, etc. And even better, the compiler is probably already telling you about all of them!</p>
<p>In the specific case of arty-e21, I am currently seeing 25 warnings: 13 unused import warnings, 4 unused variable warnings, 2 static item is never used warnings, 1 constant item is never used warning, and 5 field is never used warnings.</p>
<p>If you’re doing the compilation runs in your IDE, then you should be able to just jump to each unused item and remove it in some way.</p>
<ul>
<li>In the case of fn parameters, you can replace it with _ as previously discussed.</li>
<li>ADT contents (struct and enum fields) may require more subtlety; see “ADT-reduction” below. For now, you can prefix their names with _.</li>
<li>Warning: Items with attributes like #[no_mangle] or #[link_section] may also want special treatment: you may be able to remove them without causing the bug to go away, but once the bug does go away, their absence may cause a confusing linker error.</li>
</ul>
<p>Make sure to check periodically that the bug still reproduces (Sometimes supposedly unused things still matter)!</p>
<p>This got boards/arty-e21 down to 95 lines:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>% wc tock/boards/arty-e21/src/main.rs
      95     254    2382 tock/boards/arty-e21/src/main.rs
<span class="boring">}</span></code></pre></pre>
<p>Again, not so impressive yet. But as with optimizations, sometimes the effect of these techniques only becomes apparent when they are combined together.</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="technique-cfgments"><a class="header" href="#technique-cfgments">Technique: “Cfgments”</a></h2>
<p>As a note: As a test run, you can easilly preview the effects of “unusedification” and “demodulification” (discussed below) transformations without actually deleting code. (After all, you may quickly discover that you need to put it back.) One classic approach for this is a comment block:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
non_pub_locally_unused_item(----) { ---- }
*/

<span class="boring">}</span></code></pre></pre>
<p>But it not always easy to toggle such comments on and off, since you need add and remove the /* and matching */ each time you want to toggle it. Some IDEs help with this, but I still prefer to use more local changed if I can.</p>
<p>A less used option that is more specific to Rust (and that I use all the time), is to use a #[cfg] attribute to temporarily remove the code:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unused_or_little_used_item { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not_now)]
unused_or_little_used_item { ---- }

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>No, I do not know how to pronounce “cfgment”; I have only typed it, never uttered it. Iä! Sheol-Nugganoth!I call this “cfgmenting” out code (as opposed to “commenting out code”).</p>
</blockquote>
<p>Whether or not you choose to use comments, “cfgments”, or just delete code outright is up to you, (though I do recommend you eventually delete the lines in question, as discussed in “decommentification”).</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="tactic-demodulification"><a class="header" href="#tactic-demodulification">Tactic: “Demodulification”</a></h2>
<p>In addition to “unusedifying” each identified unused item, you might try this: You may also be lucky enough to be able to just remove whole modules from this crate at this point. If the compiler is telling you that a lot of the items in a given module are unused, maybe you can get rid of the whole module. Go ahead and try it!</p>
<p>There can be a bit of guesswork involved here. For various reasons the compiler’s lints do not identify some definitions as unused even though it may seem obvious that they are not used.</p>
<ul>
<li>This can be a consequence of the impls in the source; see “Deimplification” below.</li>
<li>Also some cases are only identified after doing “depublification” of the contents of such modules, which is also discussed below.</li>
</ul>
<p>In the case of boards/arty-e21 I was able to identify mod timer_test as entirely unsed.</p>
<p>After “cfgmenting” it out and further “decommentification”, we have this:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
      73     191    1967 tock/boards/arty-e21/src/main.rs
</code></pre>
<p>(For now we have to keep the mod io { ... }; it defines a panic-handler, and we won’t be able to get rid of that until we do more reduction elsewhere.)</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="technique-adt-reduction"><a class="header" href="#technique-adt-reduction">Technique: “ADT-reduction”</a></h2>
<p>What more is there to reduce here? Well, there is a struct ArtyE21 all of whose fields are unused:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ArtyE21 {
    _console: &amp;'static capsules::console::Console&lt;'static&gt;,
    _gpio: &amp;'static capsules::gpio::GPIO&lt;'static&gt;,
    _alarm: &amp;'static capsules::alarm::AlarmDriver&lt;
        'static,
        VirtualMuxAlarm&lt;'static, rv32i::machine_timer::MachineTimer&lt;'static&gt;&gt;,
    &gt;,
    _led: &amp;'static capsules::led::LED&lt;'static&gt;,
    _button: &amp;'static capsules::button::Button&lt;'static&gt;,
}

<span class="boring">}</span></code></pre></pre>
<p>We got lucky here: This struct has no lifetime or type parameters, so we can just do a trivial replacement, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S { }

<span class="boring">}</span></code></pre></pre>
<p>This, combined with “unusedification” of a now-unused import, leaves us with:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
      63     170    1549 tock/boards/arty-e21/src/main.rs

</code></pre>
<h3 id="adt-reduction-in-general"><a class="header" href="#adt-reduction-in-general">“ADT-reduction” in general</a></h3>
<p>In the general case, if there is a generic parameter on the struct, you will need it to retain a field (to allow the compiler to compute the variance of the parameter).</p>
<p>Usually lifetime parameters are (co)variant, in which case this suffices:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ _inner: &amp;'a () }

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>struct S&lt;'a&gt;(Cell&lt;&amp;'a ()) is another option for encoding invariance, note it imports std::cell::Cell.</p>
</blockquote>
<p>If you need an invariant lifetime parameter to reproduce the bug, then you can do it this way:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ _inner: &amp;'a mut &amp;'a () }

<span class="boring">}</span></code></pre></pre>
<p>Likewise, type parameters can usually be encoded like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T&gt; { _inner: Option&lt;T&gt; }

<span class="boring">}</span></code></pre></pre>
<p>If the type parameter has the ?Sized (anti)bound, then you can use this variant:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T: ?Sized&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T&gt; { _inner: Option&lt;Box&lt;T&gt;&gt; }
<span class="boring">}</span></code></pre></pre>
<p>Often if there is both a lifetime and a type parameter, then I will combine them into one field:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { _inner: Option&lt;&amp;'a T&gt; }

<span class="boring">}</span></code></pre></pre>
<p>but in general that might not reflect the contentsfor example, it implicitly requires that T outlive 'a, which may not have been the case originaly of the original struct, and thus may cause the original bug to be masked. So in general you may have to do:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { _inner1: &amp;'a (), _inner2: Option&lt;T&gt; }

<span class="boring">}</span></code></pre></pre>
<p>or some variation thereof.</p>
<p>Having said that, its pretty rare that struct S&lt;'a, T&gt; { _inner: Option&lt;&amp;'a T&gt; } doesn’t suffice.</p>
<hr />
<blockquote>
<p>themes: Delete the Unnecessary, Identify the Unnecessary</p>
</blockquote>
<h2 id="tactic-deimplificiation"><a class="header" href="#tactic-deimplificiation">Tactic: “Deimplificiation”</a></h2>
<p>After “loopification”, often whole impl blocks can be eliminated.</p>
<p>In the case of arty-e21, we have this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Write for Writer {
    fn write_str(&amp;mut self, _: &amp;str) -&gt; ::core::fmt::Result { loop { } }
}

<span class="boring">}</span></code></pre></pre>
<p>which is entirely unused.</p>
<p>So we can “cfgment” it out, and now the compiler identifies two unused imports (since this impl-block was their only use); more importantly, it now also identifies that the struct Writer is never constructed. (Which we already knew since we were able to revise its fields at will during “ADT-reduction”; but the point is that we couldn’t have removed its definition without first removing all of its associated impl blocks. Thus, “deimplification” is an important step in our reduction odysssey.</p>
<p>That, plus more “unusedification” gets us to 55 lines:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
      55     146    1396 tock/boards/arty-e21/src/main.rs

</code></pre>
<h3 id="fine-grained-deimplification"><a class="header" href="#fine-grained-deimplification">Fine-grained “deimplification”</a></h3>
<p>In general you may not be able to remove the whole impl block. But you can still try to remove individual items from it, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
   fn method(----) { ---- }
   ...
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
   ...
}

<span class="boring">}</span></code></pre></pre>
<h4 id="technique-split-impls"><a class="header" href="#technique-split-impls">Technique: “split-impls”</a></h4>
<blockquote>
<p>aka Regroup fn items in inherent impls.</p>
</blockquote>
<p>I sometimes like to employ As a special technique to remove individual methods from an inherent impl: Rust lets you define multiple inherent impls for a given type. So rather than deleting code or using “cfgments” for each item, I will instead take an impl and break it into two, where one of them is “cfgmented” out:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
    fn method1(----) { ---- }
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not_now)]
impl Foo {
    fn method1(----) { ---- }
}
impl Foo {
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>Here, you can now move items freely between the “cfgmented”-out impl and the still present impl. It has a similar effect to “cfgmenting” out the individual items, but in practice it feels a lot more like an easy bisection process, at least for my fingers.</p>
<ul>
<li>Especially since you can start with the whole impl “cfgmented”-out, and let the compiler tell you which methods you need to put back (e.g. due to downstream uses.)</li>
</ul>
<p>You can also sometimes do this impl as a way to make more fine-grained impl-blocks that have looser constraints, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;X: Bound&gt; Foo&lt;X&gt; {
    fn method1(...) { ... }
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;X: Bound&gt; Foo {
    fn method1(...) { ... }
}
impl&lt;X&gt; Foo&lt;X&gt; {
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>(where here we assume method2 and method3 do not require the X: Bound).</p>
<hr />
<h2 id="a-pause"><a class="header" href="#a-pause">A pause</a></h2>
<p>This is about as far as we can usefully get in reducing arty-e21 on its own.</p>
<p>To make further progress, we need to start making changes to upstream dependencies.</p>
<p>Lets look at the situation there.</p>
<hr />
<blockquote>
<p>theme: Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-dep-reduction"><a class="header" href="#tactic-dep-reduction">Tactic: “dep-reduction”</a></h3>
<blockquote>
<blockquote>
<p>aka “eliminate upstream dependencies”</p>
</blockquote>
</blockquote>
<p>We have not yet changed anything about the crate graph as a whole. Technicaly, building arty-e21 still builds 12 crates before starting on arty-e21. (Maybe cargo has some flag to inform you about unused dependencies?)</p>
<p>In any case, from inspecting arty-e21, we can see that it directly uses only two dependencies now: kernel and chips/arty_e21.</p>
<p>We can remove other dependencies from the Cargo.toml and see where it gets us:</p>
<pre><code class="language-toml">[dependencies]
kernel = { path = &quot;../../kernel&quot; }
arty_e21 = { path = &quot;../../chips/arty_e21&quot; }

</code></pre>
<p>A build after a cargo clean now shows just nine crates being built before arty-e21</p>
<pre><code class="language-shell">   Compiling tock-registers v0.4.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-register-interface)
   Compiling tock-cells v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-cells)
   Compiling tock_rt0 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-rt0)
   Compiling arty-e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/boards/arty-e21)
   Compiling riscv-csr v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/riscv-csr)
   Compiling kernel v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/kernel)
   Compiling rv32i v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/arch/rv32i)
   Compiling sifive v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/sifive)
   Compiling arty_e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/arty_e21)
</code></pre>
<p>If we want to make more progress here, we’ll need to start working on upstream crates.</p>
<p>Looking at chips/arty_e21/Cargo.toml, we can see it also depends on the kernel crate:</p>
<pre><code class="language-toml">[dependencies]
sifive = { path = &quot;../sifive&quot; }
rv32i = { path = &quot;../../arch/rv32i&quot; }
kernel = { path = &quot;../../kernel&quot; }

</code></pre>
<p>So this gives us a hint where to go next: Simplify chips/arty_e21 as much as we can, before we tackle trying to simplify the (hopefully root) kernel crate.</p>
<p>So lets see what we need from chips/arty_e21. It has a very small lib.rs file:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Drivers and chip support for the E21 soft core.

#![feature(asm, concat_idents, const_fn)]
#![feature(exclusive_range_pattern)]
#![no_std]
#![crate_name = &quot;arty_e21&quot;]
#![crate_type = &quot;rlib&quot;]

mod interrupts;

pub mod chip;
pub mod gpio;
pub mod uart;

<span class="boring">}</span></code></pre></pre>
<p>Now I have a choice: do I go ahead and inline these module defintions like we did with boards/arty-e21? Well, lets figure out if we can first isolate its exports to a bare minimum before doing that.</p>
<hr />
<blockquote>
<p>theme: Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-depublification"><a class="header" href="#tactic-depublification">Tactic: “Depublification”</a></h3>
<p>As I already mentioned, the compiler is probably already tellling you about some of these (see “unusedification”).</p>
<p>But if you want to maximize the set of unused things that the compiler will identify for you, you might need to help it along the way by removing pub annotations, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod foo { ... }
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo { ... }
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use foo;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use foo;
<span class="boring">}</span></code></pre></pre>
<p>or struct, enum, type, trait, fn, etc; basically any pub item.</p>
<p>This can help compiler see that items or imports are in fact not used outside of the current crate, and thus can be eliminated.</p>
<p>For chips/arty_e21, I was able to successfully do this replacement:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod chip;
pub mod gpio;
pub mod uart;

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod chip;
mod gpio;
mod uart;

<span class="boring">}</span></code></pre></pre>
<p>and everything still built.</p>
<p>After this point, I attempted blind “demodulification” each of mod interrupts, mod gpio, and mod uart (since its so easy to try when they are declared as out-of-line modules). Unfortunately, pub mod chip; currently depends on all of them being present.</p>
<p>So that’s when I went ahead and inlined the module definitions, leaving me with a 371-line lib.rs for chips/arty_e21:</p>
<pre><code class="language-shell">% wc tock/chips/arty_e21/src/lib.rs
     371    1354   12137 tock/chips/arty_e21/src/lib.rs
</code></pre>
<blockquote>
<blockquote>
<p>Maybe this argues for a strategy where one should attempt targetted “loopification” on your reachable (pub) modules in the crate, and then do subsequent “demodulification” of the out-of-line modules before jumping into “mod-inlining”. I have not tried that workflow too seriously yet, though; its not that hard to “demodulify” a module, since its just a matter of “cfgmenting” out the mod declaration.</p>
</blockquote>
</blockquote>
<p>Then I “loopified” it; in this case, I was lucky and was able to loopify everything in chips/arty_e21, and the bug still reproduces.</p>
<p>After “loopification”, I was able to successfully “demodulify” all of mod interrupts, mod gpio, and mod uart.</p>
<p>Finally, I did some “deimplification”, and managed to remove everything except for a impl kernel::Chip for ArtyExx { ... } and one inherent method on struct ArtyExx.</p>
<p>Those steps, plus “decommentification”, removed about 320 lines.</p>
<pre><code class="language-shell">% wc tock/chips/arty_e21/src/lib.rs
      52     163    1180 tock/chips/arty_e21/src/lib.rs
</code></pre>
<p>Perhaps most importantly, it got the source code to the point where it fits on a screen.</p>
<hr />
<blockquote>
<p>themes: Enable Incremental Steps, Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-simpl-impl"><a class="header" href="#tactic-simpl-impl">Tactic: “simpl-impl”</a></h3>
<blockquote>
<blockquote>
<p>aka use trait defaults</p>
</blockquote>
</blockquote>
<p>I did just mention that I had to keep an impl kernel::Chip for ArtyExx { ... }.</p>
<p>In general, the impl blocks we are trying to eliminate may be trait impls rather than inherent ones. In those cases, we cannot just remove methods from the impls willy-nilly, as that would cause the compiler to reject the trait implementation.</p>
<blockquote>
<blockquote>
<p>Did you see this coming?</p>
</blockquote>
</blockquote>
<p>So, you have to keep that impl entirely intact… unless you do some work up front …</p>
<p>Here’s the trick around that. First add a trait default implementation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr { ... fn m(); }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr { ... fn m() { loop { } } }

<span class="boring">}</span></code></pre></pre>
<p>This enables the subsequent transformation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Tr for C { ... fn m() { ---- } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Tr for C { ... }

<span class="boring">}</span></code></pre></pre>
<p>Thats right, you can turn a non-default trait method into a “loopified” default trait method, and that enables you to freely remove instances of that method from all of that trait’s impls. You can do this transformation piecewise, or for the whole trait definition, as you like.</p>
<p>And (I think) you can do it pretty much as freely as you like: you should not need to worry about changing a trait method to a “loopified” default causing breakage elsewhere when compiling the crate graph (unless there is some potential interaction with specialization that I have not considered).</p>
<p>If you apply the transformation repeatedly, it can often result in</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr { ---- } // all methods loopified
impl Tr for C { }

<span class="boring">}</span></code></pre></pre>
<p>which is simply awesome.</p>
<p>In our specific case, the trait in question is upstream: impl kernel::Chip for ArtyExx { ... }</p>
<p>So we are going to make an exception to our earler rule about trying to work at the leaves first: Here, we are justified in jumping upstream, to kernel/src/platform/mod.rs, and changing the definition of kernel::Chip, doing M-x query-replace of ; with { loop { } } to easily jump through the fn-items and add a “loopified” body to each one.</p>
<p>(In my case, I’m going to decommentify the relevant file first too.)</p>
<p>After adding “loopified” default methods to the traits in kernel::platform, we can return to chips/arty_e21 and further simplify the impl there to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl kernel::Chip for ArtyExx {
    type MPU = ();
    type UserspaceKernelBoundary = rv32i::syscall::SysCall;
    type SysTick = ();
}

<span class="boring">}</span></code></pre></pre>
<p>Now we need to apply a bit of artistry.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="tactic-type-trivialization"><a class="header" href="#tactic-type-trivialization">Tactic: “Type-trivialization”</a></h3>
<p>This associated type in impl kernel::Chip for ArtyExx is forcing dependency on rv32i:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type UserspaceKernelBoundary = rv32i::syscall::SysCall;

<span class="boring">}</span></code></pre></pre>
<p>But we have removed all the methods! Chances are actually quite good that there is no longer anyone that relies on that type defintion. (Its not a certainty, of course; clients of the trait might be extracting the type directly, and the associated may have trait bounds that will force us to use a non-trivial type there.)</p>
<p>But lets try it and see:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl kernel::Chip for ArtyExx {
    type MPU = ();
    type UserspaceKernelBoundary = ();
    type SysTick = ();
}

<span class="boring">}</span></code></pre></pre>
<p>yields:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0277]: the trait bound `(): kernel::syscall::UserspaceKernelBoundary` is not satisfied
  --&gt; /Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/arty_e21/src/lib.rs:22:6
   |
22 | impl kernel::Chip for ArtyExx {
   |      ^^^^^^^^^^^^ the trait `kernel::syscall::UserspaceKernelBoundary` is not implemented for `()`

error: aborting due to previous error

<span class="boring">}</span></code></pre></pre>
<p>So, what to do about this?</p>
<p>Honestly, I figure this is another case where we are justified in going upstream and removing the bound in question, just to see what happens:</p>
<pre><code class="language-diff">diff --git a/tock/kernel/src/platform/mod.rs b/tock/kernel/src/platform/mod.rs
index 9544899..dd107dd 100644
--- a/tock/kernel/src/platform/mod.rs
+++ b/tock/kernel/src/platform/mod.rs
@@ -13,7 +13,7 @@ pub trait Platform {
 pub trait Chip {
     type MPU: mpu::MPU;

-    type UserspaceKernelBoundary: syscall::UserspaceKernelBoundary;
+    type UserspaceKernelBoundary;

     type SysTick: systick::SysTick;

</code></pre>
<p>And the answer is:</p>
<pre><code>error[E0277]: the trait bound `&lt;C as platform::Chip&gt;::UserspaceKernelBoundary: syscall::UserspaceKernelBoundary` is not satisfied
   --&gt; /Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/kernel/src/process.rs:468:5
    |
468 | /     stored_state:
469 | |         Cell&lt;&lt;&lt;C as Chip&gt;::UserspaceKernelBoundary as UserspaceKernelBoundary&gt;::StoredState&gt;,
    | |____________________________________________________________________________________________^ the trait `syscall::UserspaceKernelBoundary` is not implemented for `&lt;C as platform::Chip&gt;::UserspaceKernelBoundary`
    |
    = help: consider adding a `where &lt;C as platform::Chip&gt;::UserspaceKernelBoundary: syscall::UserspaceKernelBoundary` bound

error: aborting due to previous error

</code></pre>
<p>Darn. (We could take the compilers advice and add the aforementioned where clause, but that stands a good chance of just shifting the blame around without actually helping us make progress on reduction itself.)</p>
<p>You might think: “Lets try removing that field from the struct”; but note that the struct Process lives in the kernel crate, and that code has not yet been “loopified.” So there’s a good chance that there’s existing code that relies on that field being there, and we have to get rid of that code first.</p>
<p>Well, we did a good job getting chips/arty_e21 as small as we did. Let us take this as a sign that we should keep moving up, to now focus on reducing the kernel crate.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="technique-mod-inlining-and-loopification-via-pretty-printer"><a class="header" href="#technique-mod-inlining-and-loopification-via-pretty-printer">Technique: “mod-inlining” and “loopification” via pretty-printer</a></h3>
<p>I want to simplify the kernel crate.</p>
<p>However, its module hierarchy is a bit larger than the other two crates we’ve looked at so far:</p>
<pre><code>% find tock/kernel -name '*.rs'
tock/kernel/src/tbfheader.rs
tock/kernel/src/ipc.rs
tock/kernel/src/memop.rs
tock/kernel/src/lib.rs
tock/kernel/src/platform/mod.rs
tock/kernel/src/platform/systick.rs
tock/kernel/src/platform/mpu.rs
tock/kernel/src/callback.rs
tock/kernel/src/common/static_ref.rs
tock/kernel/src/common/list.rs
tock/kernel/src/common/peripherals.rs
tock/kernel/src/common/queue.rs
tock/kernel/src/common/ring_buffer.rs
tock/kernel/src/common/dynamic_deferred_call.rs
tock/kernel/src/common/mod.rs
tock/kernel/src/common/math.rs
tock/kernel/src/common/deferred_call.rs
tock/kernel/src/common/utils.rs
tock/kernel/src/hil/symmetric_encryption.rs
tock/kernel/src/hil/dac.rs
tock/kernel/src/hil/rng.rs
tock/kernel/src/hil/i2c.rs
tock/kernel/src/hil/pwm.rs
tock/kernel/src/hil/sensors.rs
tock/kernel/src/hil/watchdog.rs
tock/kernel/src/hil/led.rs
tock/kernel/src/hil/time.rs
tock/kernel/src/hil/crc.rs
tock/kernel/src/hil/ninedof.rs
tock/kernel/src/hil/entropy.rs
tock/kernel/src/hil/spi.rs
tock/kernel/src/hil/nonvolatile_storage.rs
tock/kernel/src/hil/mod.rs
tock/kernel/src/hil/usb.rs
tock/kernel/src/hil/adc.rs
tock/kernel/src/hil/gpio_async.rs
tock/kernel/src/hil/analog_comparator.rs
tock/kernel/src/hil/gpio.rs
tock/kernel/src/hil/radio.rs
tock/kernel/src/hil/eic.rs
tock/kernel/src/hil/flash.rs
tock/kernel/src/hil/uart.rs
tock/kernel/src/hil/ble_advertising.rs
tock/kernel/src/driver.rs
tock/kernel/src/component.rs
tock/kernel/src/sched.rs
tock/kernel/src/introspection.rs
tock/kernel/src/debug.rs
tock/kernel/src/process.rs
tock/kernel/src/syscall.rs
tock/kernel/src/returncode.rs
tock/kernel/src/grant.rs
tock/kernel/src/capabilities.rs
tock/kernel/src/mem.rs
</code></pre>
<p>I don’t want to manually-inline all those modules into kernel.</p>
<p>I’m also not too eager to manually “loopify” it (though that would be easier if the “mod-inlining” were done).</p>
<p>Luckily, we can leverage the compiler here.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="mod-inlining-via-pretty-printer"><a class="header" href="#mod-inlining-via-pretty-printer">“mod-inlining” via pretty-printer</a></h3>
<p>As mentioned earlier, we can add -Z unstable-options --pretty=expanded to the relevant rustc invocation (in ths case, the one compiling kernel/src/lib.rs) to get the content of the crate as one module tree.</p>
<ul>
<li>(Unfortunately for our immediate purposes, the macros in it are also expanded. But since macros could expand into mod-declarations, this is tough to avoid in the general case for solving this problem.)</li>
</ul>
<p>Pipe that output to a file, copy that file to tock/kernel/src/lib.rs, and you’re don- … well, no; you’re not done yet.</p>
<p>If you try to compile that as is, you get a slew of errors. Because some of the macros that expanded came from Rust’s core library, and make use of features that are not available in stable Rust. So you have to add feature-gates to enable each one. Luckily, the nightly compiler tells us which gates to add, so I was able to get away with adding this line to the top of the generated file:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(derive_clone_copy, compiler_builtins_lib, fmt_internals, core_panic, derive_eq)]

<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>Then the compilation of this expanded kernel worked, and the downstream problem continued to reproduce. Success!</p>
<p>At least, success if your definition of success is this:</p>
<pre><code>% wc tock/kernel/src/lib.rs
   10238   40254  540987 tock/kernel/src/lib.rs

</code></pre>
<p>Yikes, 10K lines.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="loopification-via-pretty-printer"><a class="header" href="#loopification-via-pretty-printer">“loopification” via pretty-printer</a></h3>
<blockquote>
<blockquote>
<p>aka -Z everybody_loops</p>
</blockquote>
</blockquote>
<p>Well, that’s okay: There are some steps we haven’t taken yet. Specifically, we haven’t done “loopification.”</p>
<p>Now, its not so much fun to “loopify” a file like this by hand. The keyboard macro I described above isn’t tha robust; it can end up really messing up the code if you apply it blindly.</p>
<p>But luckily, we have another option:</p>
<p>rustc -Z unpretty=everybody_loops is your friend.</p>
<p>Basically, take the command line we used up above for macro-expanding pretty-printing, but replace the --pretty=expanded with -Zunpretty=everybody_loops.</p>
<p>As before, pipe the output to a temporary file, and then copy that over to kernel/src/lib.rs.</p>
<p>And then we build … and … oh. The bug didn’t replicate.</p>
<ul>
<li>This is okay. It is not a disaster.</li>
</ul>
<p>It in fact motivates another technique: bisecting “loopification”.</p>
<h3 id="bisecting-the-module-tree"><a class="header" href="#bisecting-the-module-tree">Bisecting the module tree</a></h3>
<p>Warning: this technique may seem… strange. But I love it so.</p>
<p>The three steps are as follows:</p>
<ol>
<li>Unify modules into a single source file (which we did up above, via the pretty-printer). But in particular, leave leave the original source files for the mod tree in place. (You’ll see why in a moment.)</li>
<li>Replace all function bodies with loop { }(which we just did, again via the pretty-printer).</li>
</ol>
<blockquote>
<blockquote>
<p>If after doing this, you still get the same failure again, then congratulations: You have a single file (with a potentially huge module tree) and all of its function bodies are trivial loop { }. But of course, in our case of kernel, we know that we are not in this scenario. </p>
</blockquote>
</blockquote>
<ol start="3">
<li>Finally, swap modules in and out via “cfgmenting”.</li>
</ol>
<p>Remember up above when I suggested leaving the source files in place? This is where that comes into play.</p>
<p>A relatively tiny (and easily mechanized) change to the source code readily reverts individual modules back to their prior form:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod child_mod_1 {
    use import::stuff;
    fn some_function() -&gt; ReturnType {
        loop { }
    }

    mod even_more_inner {
       ...
    }
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod child_mod_1;

#[cfg(commented_out_for_bisection)]
mod child_mod_1 {
    use import::stuff;
    fn some_function() -&gt; ReturnType {
        loop { }
    }

    mod even_more_inner {
       ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This effectively puts back in the original code for child_mod_1.</p>
<p>You can search through your single lib.rs (or main.rs) file that holds the whole module tree (where function bodies are replaced with loop { }), and then choose a subset of these modules and apply the above transformation to point them at their original source file.</p>
<p>You can do this for, e.g., the first half the modules, and then re-run the compiler to see if the failure re-arises. If so, huzzah!</p>
<p>I successfully used this methodology to identify which mod in kernel we needed to keep in non-loopified form in order to reproduce the bug: mod process;.</p>
<p>And that gets us down to:</p>
<pre><code>wc tock/kernel/src/lib.rs
    3253   11085  112858 tock/kernel/src/lib.rs

</code></pre>
<p>Yeah, still 3K lines. But that’s a lot better than 10K, and there’s plenty more stuff to remove.</p>
<p>First, lets see if we can further narrow down which methods in mod process are the ones that we need for replicating the bug. For this, we can do bisection over the fn items within the (still out-of-line) mod process.</p>
<hr />
<h3 id="reduction-via-bisection"><a class="header" href="#reduction-via-bisection">Reduction via Bisection</a></h3>
<p>Sometimes you cannot simply remove all (or all but one) of the method bodies. For one reason or another (e.g. impl Trait in return position) you need to preserve the bodies of one or more methods that are not directly relevant to the bug at hand.</p>
<p>In this scenario, it can stil be useful to use the techniques above to eliminate irrelevant details in the other methods. But what is the best way to identify which methods are relevant and which aren’t? Well, that’s a fine segue to our original topic.</p>
<p>(… a significant amount of time has passed.)</p>
<p>Okay: after spending a lot of time doing pseudo-bisection, I managed to isolate three methods in process.rs that are necessary to reproduce the issue.</p>
<p>Part of my own process here (not process, ha ha) was to switch mindset away from trying to bisect to find the “one fn body” that causes the faiure. Instead, I had to focus on identifying a minimal subset of bodies that are necessary to cause it to arise.</p>
<p>That is, starting with N fn items, I’d “loopify” N/2 of them, and if the bug went away on that half, I’d put back in the previous bodies, cut that set in in half, and repeat until the bug came back. This tended to narrow things down to one fn item that, when “loopified”, made the bug go away.</p>
<p>Then I’d mark that one fn as strictly necessary, and repeat the process on the N-1 fn-items that still remained.</p>
<p>To be clear: this switch in mindset changes so-called “bisection” from a O(log n) process to an O(n log n) one: because you are going to do a separate O(log n) bisection step on O(n) fn-items. But on the plus side, its still a pretty mindless process (and probably could be mechanically automated).</p>
<p>Eventually, this led me to identify the three functions in process.rs whose non-“loopified” definitions are needed to witness the bug:</p>
<ul>
<li>load_processes</li>
<li><Process as ProcessType>::process_detail_fmt, and</li>
<li>Process::create.</li>
</ul>
<p>With that done, I redid the “mod-inlining” of mod process into kernel.</p>
<h2 id="popping-the-stack"><a class="header" href="#popping-the-stack">Popping the stack</a></h2>
<p>Now, as a reminder: the reason we dived into kernel was to see if we could remove the stored_state field from struct Process:</p>
<pre><code>stored_state:
    Cell&lt;&lt;&lt;C as Chip&gt;::UserspaceKernelBoundary as UserspaceKernelBoundary&gt;::StoredState&gt;,
</code></pre>
<p>The answer is unfortuately still no: two of the three methods we kept from mod process refer to that field.</p>
<p>But we can do some directed editing to see if the bug repreoduces after removing those references:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3067,12 +3067,6 @@ impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
             flash_start
         ));

-        self.chip.userspace_kernel_boundary().process_detail_fmt(
-            self.sp(),
-            &amp;self.stored_state.get(),
-            writer,
-        );
-
         self.mpu_config.map(|config| {
             let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
         });
@@ -3205,7 +3199,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {

             process.flash = slice::from_raw_parts(app_flash_address, app_flash_size);

-            process.stored_state = Cell::new(Default::default());
+            // process.stored_state = Cell::new(Default::default());
             process.state = Cell::new(State::Unstarted);
             process.fault_response = fault_response;

@@ -3246,6 +3240,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
                 }));
             });

+            /*
             let mut stored_state = process.stored_state.get();
             match chip.userspace_kernel_boundary().initialize_new_process(
                 process.sp(),
@@ -3263,6 +3258,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
                     return (None, app_flash_size, 0);
                 }
             };
+             */
</code></pre>
<p>And the answer is: YES. The bug reproduces!</p>
<p>And now we can move forward with removing that field… YES, still reproduces:</p>
<pre><code class="language-diff">
--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2809,9 +2809,6 @@ pub struct Process&lt;'a, C: 'static + Chip&gt; {

     header: tbfheader::TbfHeader,

-    stored_state:
-        Cell&lt;&lt;&lt;C as Chip&gt;::UserspaceKernelBoundary as UserspaceKernelBoundary&gt;::StoredState&gt;,
-
     state: Cell&lt;State&gt;,

     fault_response: FaultResponse,

</code></pre>
<p>And then see about removed the bound on the associated type that sent us on this path… YES</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2525,7 +2525,7 @@ mod platform {
         type
         MPU: mpu::MPU;
         type
-        UserspaceKernelBoundary: syscall::UserspaceKernelBoundary;
+        UserspaceKernelBoundary;
         type
         SysTick: systick::SysTick;
         fn service_pending_interrupts(&amp;self) { loop  { } }

</code></pre>
<p>So now we can pop our stack: We can go back to chips/arty_e21, and apply “type-trivialization”:</p>
<pre><code class="language-diff">
--- a/tock/chips/arty_e21/src/lib.rs
+++ b/tock/chips/arty_e21/src/lib.rs
@@ -21,7 +21,7 @@ impl ArtyExx {

 impl kernel::Chip for ArtyExx {
     type MPU = ();
-    type UserspaceKernelBoundary = rv32i::syscall::SysCall;
+    type UserspaceKernelBoundary = ();
     type SysTick = ();
 }
</code></pre>
<p>We did it!</p>
<p>With that in place, we can do more “dep-reduction”, by removing the rv32i dependency from chips/arty_e21.</p>
<p>At this point, we could continue with the above transformations to further reduce kernel.</p>
<p>But I want to switch to showing a different kind of minimization transformation, one that will let us make further simplifications to boards/arty-e21.</p>
<hr />
<h3 id="simplfying-the-existing-code"><a class="header" href="#simplfying-the-existing-code">Simplfying the existing code</a></h3>
<p>Looking again at boards/arty-e21, we have this method body:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn reset_handler() {
    let chip = static_init!(arty_e21::chip::ArtyExx, arty_e21::chip::ArtyExx::new());
    let process_mgmt_cap = create_capability!(capabilities::ProcessManagementCapability);
    let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&amp;PROCESSES));

    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;0u8 as *const u8,
        &amp;mut [0; 8192], // APP_MEMORY,
        &amp;mut PROCESSES,
        kernel::procs::FaultResponse::Panic,
        &amp;process_mgmt_cap,
    );
}
<span class="boring">}</span></code></pre></pre>
<p>It would be nice to figure out which parts of this are actually relevant.</p>
<p>Unfortunately, kernel::procs::load_processes was one of the functions where we could not apply “loopification” without masking the rustc bug.</p>
<p>Let us see if we can at least simplfify the API of load_processes itself.</p>
<p>It currently looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(
    kernel: &amp;'static Kernel,
    chip: &amp;'static C,
    start_of_flash: *const u8,
    app_memory: &amp;mut [u8],
    procs: &amp;'static mut [Option&lt;&amp;'static dyn ProcessType&gt;],
    fault_response: FaultResponse,
    _capability: &amp;dyn ProcessManagementCapability,
) {
    let mut apps_in_flash_ptr = start_of_flash;
    let mut app_memory_ptr = app_memory.as_mut_ptr();
    let mut app_memory_size = app_memory.len();
    for i in 0..procs.len() {
        unsafe {
            let (process, flash_offset, memory_offset) = Process::create(
                kernel,
                chip,
                apps_in_flash_ptr,
                app_memory_ptr,
                app_memory_size,
                fault_response,
                i,
            );

            if process.is_none() {
                if flash_offset == 0 &amp;&amp; memory_offset == 0 {
                    break;
                }
            } else {
                procs[i] = process;
            }

            apps_in_flash_ptr = apps_in_flash_ptr.add(flash_offset);
            app_memory_ptr = app_memory_ptr.add(memory_offset);
            app_memory_size -= memory_offset;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The fact that Process::create was another function that we could not “loopify” gives us a hint has to how to simplfy this further: can we reduce this method body to just a Process::create call, and see if the bug persists?</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2586,31 +2586,17 @@ pub fn load_processes&lt;C: Chip&gt;(
     let mut apps_in_flash_ptr = start_of_flash;
     let mut app_memory_ptr = app_memory.as_mut_ptr();
     let mut app_memory_size = app_memory.len();
-    for i in 0..procs.len() {
         unsafe {
-            let (process, flash_offset, memory_offset) = Process::create(
+            Process::create(
                 kernel,
                 chip,
                 apps_in_flash_ptr,
                 app_memory_ptr,
                 app_memory_size,
                 fault_response,
-                i,
+                0,
             );
-
-            if process.is_none() {
-                if flash_offset == 0 &amp;&amp; memory_offset == 0 {
-                    break;
-                }
-            } else {
-                procs[i] = process;
-            }
-
-            apps_in_flash_ptr = apps_in_flash_ptr.add(flash_offset);
-            app_memory_ptr = app_memory_ptr.add(memory_offset);
-            app_memory_size -= memory_offset;
         }
-    }
 }
</code></pre>
<p>And yes, the bug still reproduces.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="tactic-rhs-inlining"><a class="header" href="#tactic-rhs-inlining">Tactic: “RHS-inlining”</a></h3>
<p>This is just the classic transformation of taking the right-hand side of a let or const and copying it into the usage sites for the variable defined by the let or const. Once all uses of the variable have been replaced, you can try removing the let or const itself (i.e. “unusedification”)</p>
<p>In our specific case, we can apply this to load_processes:</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2583,16 +2583,13 @@ pub fn load_processes&lt;C: Chip&gt;(
     fault_response: FaultResponse,
     _capability: &amp;dyn ProcessManagementCapability,
 ) {
-    let mut apps_in_flash_ptr = start_of_flash;
-    let mut app_memory_ptr = app_memory.as_mut_ptr();
-    let mut app_memory_size = app_memory.len();
         unsafe {
             Process::create(
                 kernel,
                 chip,
-                apps_in_flash_ptr,
-                app_memory_ptr,
-                app_memory_size,
+                start_of_flash,
+                app_memory.as_mut_ptr(),
+                app_memory.len(),
                 fault_response,
                 0,
             );

</code></pre>
<p>However, this technique on its own does not tend to actually reduce the problem at hand, in terms of making it possible for us to remove imports or simplify fn API signatures.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="tactic-defaultification"><a class="header" href="#tactic-defaultification">Tactic: “Defaultification”</a></h3>
<blockquote>
<blockquote>
<p>aka “Scalars Gotta Scale”</p>
</blockquote>
</blockquote>
<p>If you really want to simplify, then you should replace the occurences of the variable with some “obvious” value based on its type.</p>
<p>(This is the obvious alternative to “loopification” when it comes to simplifying const fn.)</p>
<p>More specifically: frequently, the return type of a const fn (or the type of a const item) is some scalar type (like u32, f64, or bool). These all have “obvious” values that you can just plug in (respectively 0, 0.0, or false).</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn cfoo(----) -&gt; u32 { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn cfoo(----) -&gt; u32 { 0 }

<span class="boring">}</span></code></pre></pre>
<p>In the case of load_processes, “defaultification” yields this:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2587,9 +2587,9 @@ pub fn load_processes&lt;C: Chip&gt;(
             Process::create(
                 kernel,
                 chip,
-                start_of_flash,
-                app_memory.as_mut_ptr(),
-                app_memory.len(),
+                0 as *const u8,
+                (&amp;mut []).as_mut_ptr(),
+                0,
                 fault_response,
                 0,
             );
</code></pre>
<p>That means we’ve gotten rid of the uses of three fn parameters in the body of load_processes. Lets see what that can buy us for further reduction.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-genertrification"><a class="header" href="#technique-genertrification">Technique: “Genertrification”</a></h3>
<blockquote>
<blockquote>
<p>aka “Type Freedom”</p>
</blockquote>
</blockquote>
<p>Once you remove all uses of parameter (which is readily identifiable via either lint diagnostics or if the parameter has just _: ParamType for its declaration), you can “genertrify” it to get rid of the use of ParamType.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: ParamType, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;A&gt;(_: A, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>or even more simply (in terms of locality of the transformation):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: impl Sized, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>The beauty of this is that it can almost always be applied even if there remain uses of foo elsewhere in the code.</p>
<p>Therefore, I tend to recommend it over “param-elimination”, described below.</p>
<ul>
<li>However, this transformation does not work if fn foo must not carry any generic type parameters; e.g., if fn foo needs to be object-safe, then you cannot add the type parameteter A.</li>
<li>The other case where it cannot be applied is when an existing use is relying on the existing type for inference purposes. We will see an example of this below.</li>
</ul>
<p>In the case of load_processes, “genertrification” allows this change:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2577,11 +2577,11 @@ use core::cmp::max;
 pub fn load_processes&lt;C: Chip&gt;(
     kernel: &amp;'static Kernel,
     chip: &amp;'static C,
-    start_of_flash: *const u8,
-    app_memory: &amp;mut [u8],
-    procs: &amp;'static mut [Option&lt;&amp;'static dyn ProcessType&gt;],
+    _: impl Sized,
+    _: impl Sized,
+    _: impl Sized,
     fault_response: FaultResponse,
-    _capability: &amp;dyn ProcessManagementCapability,
+    _: impl Sized,
 ) {
         unsafe {
             Process::create(
</code></pre>
<p>And once we do that, we can revise any calls to load_processes and pass any value we like for the impl Sized arguments. So we’ve opened up new opportunities for “expr-elimination”:</p>
<pre><code class="language-diff">--- INDEX/tock/boards/arty-e21/src/main.rs
+++ WORKDIR/tock/boards/arty-e21/src/main.rs
@@ -39,17 +39,16 @@ impl Platform for ArtyE21 {
 #[no_mangle]
 pub unsafe fn reset_handler() {
     let chip = static_init!(arty_e21::chip::ArtyExx, arty_e21::chip::ArtyExx::new());
-    let process_mgmt_cap = create_capability!(capabilities::ProcessManagementCapability);
     let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&amp;PROCESSES));

     kernel::procs::load_processes(
         board_kernel,
         chip,
-        &amp;0u8 as *const u8,
-        &amp;mut [0; 8192], // APP_MEMORY,
-        &amp;mut PROCESSES,
+        (),
+        (),
+        (),
         kernel::procs::FaultResponse::Panic,
-        &amp;process_mgmt_cap,
+        (),
     );

 }
</code></pre>
<p>We would like to continue simplifying the APIs by applying “genertrification” elsewhere. For example, load_processes calls Process::create, so it would be useful to simplify its API.</p>
<p>The body of Process::create is currently over 150 lines of code. But after bisection-based “expr-elimination”, coupled with “RHS-inlining”, “defaultification”, and “unusedification”, we can get the body down to this far more managable 20 lines:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        kernel: &amp;'static Kernel,
        chip: &amp;'static C,
        app_flash_address: *const u8,
        remaining_app_memory: *mut u8,
        remaining_app_memory_size: usize,
        fault_response: FaultResponse,
        index: usize,
    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
            let mut process: &amp;mut Process&lt;C&gt; =
                &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

            process.debug = MapCell::new(ProcessDebug {
                app_heap_start_pointer: None,
                app_stack_start_pointer: None,
                min_stack_pointer: 0 as *const u8,
                syscall_count: 0,
                last_syscall: None,
                dropped_callback_count: 0,
                restart_count: 0,
                timeslice_expiration_count: 0,
            });

            return (
                Some(process),
                0usize,
                0usize,
            );
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>And now we can apply “genertrification”:</p>
<pre><code class="language-diff">
--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3065,13 +3065,13 @@ fn exceeded_check(size: usize, allocated: usize) -&gt; &amp;'static str { loop { } }
 impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
-        kernel: &amp;'static Kernel,
+        kernel: impl Sized,
         chip: &amp;'static C,
-        app_flash_address: *const u8,
+        app_flash_address: impl Sized,
         remaining_app_memory: *mut u8,
-        remaining_app_memory_size: usize,
-        fault_response: FaultResponse,
-        index: usize,
+        remaining_app_memory_size: impl Sized,
+        fault_response: impl Sized,
+        index: impl Sized,
     ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);
</code></pre>
<h4 id="you-cant-always-genertrify-what-you-want"><a class="header" href="#you-cant-always-genertrify-what-you-want">“you can’t always genertrify what you want”</a></h4>
<p>Unfortunately, I was not able to “genertrify” the remaining_app_memory formal parameter, even though it is unused in the function body. Why is this? Because the current call-site is relying on the type of the formal parameter for inference purposes. So in this case, we need to update the API in tandem with the call site:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2588,7 +2588,7 @@ pub fn load_processes&lt;C: Chip&gt;(
                 (),
                 chip,
                 (),
-                (&amp;mut []).as_mut_ptr(),
+                (),
                 0,
                 (),
                 0,
@@ -3068,7 +3068,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
         kernel: impl Sized,
         chip: &amp;'static C,
         app_flash_address: impl Sized,
-        remaining_app_memory: *mut u8,
+        remaining_app_memory: impl Sized,
         remaining_app_memory_size: impl Sized,
         fault_response: impl Sized,
         index: impl Sized,
</code></pre>
<p>This allows further “expr-elimination”:</p>
<pre><code class="language-diff">
--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3076,17 +3076,6 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

-            process.debug = MapCell::new(ProcessDebug {
-                app_heap_start_pointer: None,
-                app_stack_start_pointer: None,
-                min_stack_pointer: 0 as *const u8,
-                syscall_count: 0,
-                last_syscall: None,
-                dropped_callback_count: 0,
-                restart_count: 0,
-                timeslice_expiration_count: 0,
-            });
-
             return (
                 Some(process),
                 0usize,
</code></pre>
<p>and we bave gotten Process::create down to something that actually is close to minimal, at least with given the transformations we have covered so far:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        kernel: impl Sized,
        chip: &amp;'static C,
        app_flash_address: impl Sized,
        remaining_app_memory: impl Sized,
        remaining_app_memory_size: impl Sized,
        fault_response: impl Sized,
        index: impl Sized,
    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
            let mut process: &amp;mut Process&lt;C&gt; =
                &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

            return (
                Some(process),
                0usize,
                0usize,
            );
    }
...
}
<span class="boring">}</span></code></pre></pre>
<p>But of course, we can go further!</p>
<h3 id="once-all-the-code-is-gone-"><a class="header" href="#once-all-the-code-is-gone-">Once all the code is gone …</a></h3>
<p>The applicability of many of the remaining patterns depends on whether you have successfully trivialized all or most method bodies. That is, if you have gotten rid of most of the complex expressions in the program, then you can usually remove things like struct field declarations or any “interesting” types on formal parameters.</p>
<p>So, lets see if we can further reduce the complexity of our example by simplifying the APIs of the functions involved.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-param-elimination"><a class="header" href="#technique-param-elimination">Technique: “Param-elimination”</a></h3>
<p>If you have successfully eliminated all uses of a method foo, then you can apply this transformation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: ArgType, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>In some rare cases, the compiler bug will requires a method signature to keep the same number of arguments; for that scenario, you can instead use “type-trivialization” for the parameter:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: ArgType, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: (), ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>Either way, these transformations can only be applied if all uses of foo have been eliminated via trivialization of bodies as described above (or if you are willing to update them all accordingly). Thus, I tend to recommend applying “genertrification” instead: that transformation can be applied without concern about the usage sites.</p>
<p>Of course, if you have already applied “genertrification” and also updated all call sites to pass something trivial like (), then you can readily apply either “param-elimination” or “type-trivialization”: it really should be easy to update the call-sites in that scenario.</p>
<p>In our particular case of Process::create, we currently have a fn-signature that looks like:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>crate unsafe fn create(
    kernel: impl Sized,
    chip: &amp;'static C,
    app_flash_address: impl Sized,
    remaining_app_memory: impl Sized,
    remaining_app_memory_size: impl Sized,
    fault_response: impl Sized,
    index: impl Sized,
) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
<span class="boring">}</span></code></pre></pre>
<p>And we already updated the single call-site to pass () or 0 for each of the parameters of type impl Sized, so now we can just remove them entirely:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2585,13 +2585,7 @@ pub fn load_processes&lt;C: Chip&gt;(
 ) {
         unsafe {
             Process::create(
-                (),
                 chip,
-                (),
-                (),
-                0,
-                (),
-                0,
             );
         }
 }
@@ -3065,13 +3059,7 @@ fn exceeded_check(size: usize, allocated: usize) -&gt; &amp;'static str { loop { } }
 impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
-        kernel: impl Sized,
         chip: &amp;'static C,
-        app_flash_address: impl Sized,
-        remaining_app_memory: impl Sized,
-        remaining_app_memory_size: impl Sized,
-        fault_response: impl Sized,
-        index: impl Sized,
     ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

</code></pre>
<p>And compiling still hits the same ICE, so this “param-elimination” was a legitimate reduction of the problem.</p>
<p>Next we’ll consider a related transformation on the fn-signature.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-ret-elimination"><a class="header" href="#technique-ret-elimination">Technique: “Ret-elimination”</a></h3>
<p>If you have successfully eliminated all uses of the value returned from calls to foo, then you can apply this transformation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>If fn foo still has a body, then you can just turn every return point in the body into a normal expression:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { if A { return B; } TailReturn }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) { if A { B; } TailReturn; }

<span class="boring">}</span></code></pre></pre>
<p>In our case, the sole call to Process::create now looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    unsafe {
        Process::create(
            chip,
        );
    }

<span class="boring">}</span></code></pre></pre>
<p>So we can directly apply “ret-elimination” to the definition of Process::create:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3060,11 +3060,11 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
         chip: &amp;'static C,
-    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
+    ) {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

-            return (
+            (
                 Some(process),
                 0usize,
                 0usize,
</code></pre>
<p>But… Ah ha! Doing this causes the compilation error to disappear!</p>
<p>What happened?</p>
<p>Well, inspecting the return type, we can see that “Ret-elimination” in this case has gotten rid of the type: (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize). Nested within that tuple, we see the type &amp;'static dyn ProcessType. So, the attemtpt to return (Some(process), 0, 0) is causing the generated code to coerce the process: &amp;mut Process<C> into a trait-object of type &amp;dyn ProcessType. And apparently this is part of generating the bug!</p>
<p>So, do not look at this reduction-failure as a set-back: It in fact may serve as a clue as to the root cause of the bug.</p>
<hr />
<h3 id="final-reduction-touches-on-processcreate"><a class="header" href="#final-reduction-touches-on-processcreate">Final reduction touches on Process::create</a></h3>
<p>For Process::create, we have:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
            let mut process: &amp;mut Process&lt;C&gt; =
                &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

            return (
                Some(process),
                0usize,
                0usize,
            );
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>We can simplfy this API by reducing the return type to the core element that matters: the trait object:</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -3045,15 +3045,11 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
         chip: &amp;'static C,
-    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
+    ) -&gt; &amp;'static dyn ProcessType {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

-            return (
-                Some(process),
-                0usize,
-                0usize,
-            );
+            process
     }

     #[allow(clippy::cast_ptr_alignment)]
</code></pre>
<p>In fact, we can do even better. The initialization expression on the right-hand side of let mut process = ... is ugly, and its actually completely irrelevant.</p>
<p>In cases like these where we are hitting an ICE, we can use a special kind of “defaultification” to conjure up types without needing any knowledge of their expression.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-none-defaulting"><a class="header" href="#technique-none-defaulting">Technique: “None-defaulting”</a></h3>
<blockquote>
<blockquote>
<p>This is yet another case where the fact that we are debugging a compile-time issue is crucial. You obviously cannot be tossing None.unwrap() into code you expect to run usefully.</p>
</blockquote>
</blockquote>
<p>The idea of “none-defaulting” is simple: You need the compiler to think you have a value of type T. But the steps to make an instance of T are not relevant to reproducing the bug. So just make a None::<T>, and unwrap it.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: T = ----;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: T = None.unwrap();
<span class="boring">}</span></code></pre></pre>
<p>In our case, applying this technique to Process::create yields this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) -&gt; &amp;'static dyn ProcessType {
            let mut process: &amp;mut Process&lt;C&gt; = None.unwrap();

            process
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>And compiling this, the ICE still reproduces!</p>
<h2 id="so-where-are-we-now"><a class="header" href="#so-where-are-we-now">So, where are we now</a></h2>
<p>We’ve still got a set of three crates, one of which is over 3,000 lines long.</p>
<p>But we’ve also reduced the set of non-trival functions in that big crate to just three:</p>
<ul>
<li>Process::create,</li>
<li>load_processes, and</li>
<li><Process as ProcessType>::process_detail_fmt.</li>
</ul>
<p>If you think for a momeent, you can see how everything is tying together here: This ICE is occurring in the midst of some step of code-generation. We previously established that in order to observe the ICE, the compiler needs to handle code-generation for the coercion from &amp;Process to a trait object &amp;dyn ProcessType . A method like <Process as ProcessType>::process_detail_fmt is part of the virtual-methods that get their code generated as part of that coercion.</p>
<p>We already showed Process::create is now pretty trivial.</p>
<p>As for load_processes, after doing some additional “unusedification” and “param-elimination” we can get it down to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(
    chip: &amp;'static C,
) {
        unsafe {
            Process::create(
                chip,
            );
        }
}
<span class="boring">}</span></code></pre></pre>
<p>which we might as well rewrite into the one-liner:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(chip: &amp;'static C) { unsafe { Process::create(chip); } }

<span class="boring">}</span></code></pre></pre>
<p>That just leaves <Process as ProcessType>::process_detail_fmt, which we have not looked at yet.</p>
<p>As part of the earlier (undocumented) bisection process on the out-of-line mod process;, I already “simpl-impled” the ProcessType trait declaration, so it looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ProcessType {
    fn appid(&amp;self) -&gt; AppId { loop { } }
    ...
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) { loop { } }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>This means we can remove all of the irrelevant methods from the impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt;, leaving us with just the single method:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        ...
    }
}

<span class="boring">}</span></code></pre></pre>
<p>And since this is now the only impl of ProcessType, we can also remove the other methods from the ProcessType trait itself:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ProcessType {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) { loop { } }
}

<span class="boring">}</span></code></pre></pre>
<p>I cannot stress how satisfying it is to be able to retest the ICE in between each of these steps. It gives you excellent points to pause, get up from the keyboard and take a walk (which is another surprisingly effective debugging methodology).</p>
<p>But we still have the body of fn process_detail_fmt itself, which is about 175 lines of code. So lets try to winnow that down.</p>
<p>“Suffix-bisection” ends up revealing that the ICE is triggered by this bit of code in the method.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    self.mpu_config.map(|config| {
        let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
    });

<span class="boring">}</span></code></pre></pre>
<p>And so we can “expr-eliminate” all the rest, leaving this defintion of the method:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        self.mpu_config.map(|config| {
            let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
        });
    }
}

<span class="boring">}</span></code></pre></pre>
<p>That looks pretty simple (after all, its a a three line body). But its still doing some relatively interesting stuff: there’s that format_args! macro in there, and a closure being constructed.</p>
<p>We might try to simplify the body further: turn the closure body into the main body of process_detail_fmt itself.</p>
<p>The closure takes an input of type config; a quick inspect of the map method shows that should have the same type as is fed into the MapCell here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mpu_config: MapCell&lt;&lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig&gt;,

<span class="boring">}</span></code></pre></pre>
<p>Unfortunately, we quickly discover that just moving the closure body into the process_detail_fmt method is not a valid reduction. That is, I tried compiling with this definition instead:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        let config = None::&lt;&lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig&gt;.unwrap();
        let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
    }
}

<span class="boring">}</span></code></pre></pre>
<p>and got this ICE:</p>
<pre><code>error: internal compiler error: src/librustc/traits/codegen/mod.rs:53: Encountered error `Unimplemented` selecting `Binder(&lt;() as core::fmt::Display&gt;)` during codegen

</code></pre>
<blockquote>
<blockquote>
<p>When reduction uncovers a different bug, it is of course good practice to record that distinct state of the test source code somewhere. E.g. you could make a separate git branch for it, and come back to later.</p>
</blockquote>
</blockquote>
<p>That is certainly a similar looking ICE. But if we want to be sure about our reduction, we really need to see the same error: if we don’t see [FulfillmentError(Obligation(...))], then we should not be satisifed.</p>
<p>So, we apparently have to keep more of the original code from process_detail_fmt.</p>
<p>At this point we must note that MapCell is a type that kernel is pulling in from another crate, tock-cells.</p>
<p>So we might need to go and modify code over in tock-cells if we want to fully reduce this code.</p>
<p>Or we might be able to get away with just copying its definition locally, avoiding the hassle of the full process of reducing the tock-cells crate itself.</p>
<hr />
<blockquote>
<p>themes: Eliminate Coupling, Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-cut-spaghetti-imports"><a class="header" href="#tactic-cut-spaghetti-imports">Tactic: “Cut-spaghetti-imports”</a></h3>
<p>This is pretty easy: If you’ve “loopified” most of your code, you can often do this replacement.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ...::Type;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type;
<span class="boring">}</span></code></pre></pre>
<p>or, if applicable:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Type = ();
<span class="boring">}</span></code></pre></pre>
<p>If you haven’t done full “loopification” everywhere (our situation), then you may need to do this.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type { ... } // (adapt definition from elsewhere, potentially via cut-and-paste).
impl Type { ... }
<span class="boring">}</span></code></pre></pre>
<p>Note: may need to add (potentially artificial) generic parameters, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ...::Type;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct&lt;'a, T&gt; Type(&amp;'a (), Option&lt;T&gt;);
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Type&lt;'a, T&gt; = (&amp;'a (), Option&lt;T&gt;);
<span class="boring">}</span></code></pre></pre>
<p>In our case, we are going to make a local version of tock_cells::MapCell.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MapCell&lt;T&gt; {
    val: core::cell::UnsafeCell&lt;core::mem::MaybeUninit&lt;T&gt;&gt;,
    occupied: Cell&lt;bool&gt;,
}
impl&lt;T&gt; MapCell&lt;T&gt; {
    pub fn is_some(&amp;self) -&gt; bool {
        self.occupied.get()
    }
    pub fn map&lt;F, R&gt;(&amp;self, closure: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(&amp;mut T) -&gt; R,
    {
        if self.is_some() {
            self.occupied.set(false);
            let valref = unsafe { &amp;mut *self.val.get() };
            // TODO: change to valref.get_mut() once stabilized [#53491](https://github.com/rust-lang/rust/issues/53491)
            let res = closure(unsafe { &amp;mut *valref.as_mut_ptr() });
            self.occupied.set(true);
            Some(res)
        } else {
            None
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>I got this by cut-and-pasting the definiton for struct MapCell<T> (and then fixing its types so I could avoid adding use statements elsewhere), and then cut-and-pasting its fn map method, and finally cut-and-pasting its fn is_some method after a compilation attempt said that was missing.</p>
<p>With that done, compilation continues to show the ICE.</p>
<p>If you “loopify” the body of MapCell::map, the ICE goes away. There is something relevant inside there.</p>
<p>Some intelligent (as in, non-mechanical) “expr-elimination” and “none-defaulting” gets MapCell::map down to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; MapCell&lt;T&gt; {
    pub fn map&lt;F, R&gt;(&amp;self, closure: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(&amp;mut T) -&gt; R,
    {
            closure(None::&lt;&amp;mut T&gt;.unwrap());
            loop { }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Compilation still shows the same ICE here, so we haven’t lost anything yet.</p>
<p>And yet, this version of map does not use self at all!</p>
<p>This brings us to another kind of simplification: going from object methods to top-level functions.</p>
<hr />
<blockquote>
<p>themes: Identify the Unnecessary, Trivialize Content</p>
</blockquote>
<h3 id="tactic-deobjectification"><a class="header" href="#tactic-deobjectification">Tactic: “Deobjectification”</a></h3>
<p>The goal of “deobjectification” is to replace a method defined in an impl with a top-level function. Moving some necessary component for reproducing the bug out of the impl can make the impl itself unnecessary, and thus removable.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;X&gt; Type&lt;X&gt; {
    pub fn foo&lt;T&gt;(&amp;self, args: ---) -&gt; ReturnType { --- } // where `---` does not use `Self`/`self`
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn top_foo&lt;X, T&gt;(args: ---) -&gt; ReturnType { --- }

<span class="boring">}</span></code></pre></pre>
<p>In our case, lets try to pull MapCell::map out of MapCell:</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2577,6 +2577,13 @@ impl&lt;T&gt; MapCell&lt;T&gt; {
             loop { }
     }
 }
+
+fn mapcell_map&lt;T, F, R&gt;(closure: F) -&gt; Option&lt;R&gt; where F: FnOnce(&amp;mut T) -&gt; R
+{
+    closure(None::&lt;&amp;mut T&gt;.unwrap());
+    loop { }
+}
+
 use crate::common::{Queue, RingBuffer};
 use crate::mem::{AppSlice, Shared};
 use crate::platform::mpu::{self, MPU};
@@ -2719,7 +2726,7 @@ pub struct Process&lt;'a, C: 'static + Chip&gt; {

 impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
     unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
-        self.mpu_config.map(|config| {
+        mapcell_map(|config: &amp;mut &lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig| {
             let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
         });
     }
</code></pre>
<p>Success: compilation still ICE’s in the same way.</p>
<p>And now that we’ve remove the last uses of fields in self for Process, we can simplify its definition considerably:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Process&lt;'a, C: 'static + Chip&gt; {
    chip: &amp;'static C,
    tasks: &amp;'a (),
}

<span class="boring">}</span></code></pre></pre>
<p>(And that simplification lets us remove the struct MapCell we added a few steps ago, since we no longer need it for the now-eliminated mpu_config field.)</p>
<p>So now we’ve reduced all three methods to pretty simple bodies; we had to add a fourth method (mapcell_map) in the process; but that method was always there all along as part of the puzzle. It had just been waiting for us in the upstream tock-cells crate.</p>
<p>Furthermore, we can apply “ret-elimination” to mapcell_map, both on the fn mapcell_map itself, and on its closure argument:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2564,10 +2564,9 @@ use core::{mem, ptr, slice, str};

 use crate::callback::{AppId, CallbackId};
 use crate::capabilities::ProcessManagementCapability;
-fn mapcell_map&lt;T, F, R&gt;(closure: F) -&gt; Option&lt;R&gt; where F: FnOnce(&amp;mut T) -&gt; R
+fn mapcell_map&lt;T, F&gt;(closure: F) where F: FnOnce(&amp;mut T)
 {
     closure(None::&lt;&amp;mut T&gt;.unwrap());
-    loop { }
 }

 use crate::common::{Queue, RingBuffer};

</code></pre>
<p>We have now gotten ourself down to the following core set of methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn mapcell_map&lt;T, F&gt;(closure: F) where F: FnOnce(&amp;mut T)
{
    closure(None::&lt;&amp;mut T&gt;.unwrap());
}

...

pub fn load_processes&lt;C: Chip&gt;(chip: &amp;'static C) { unsafe { Process::create(chip); } }

pub struct Process&lt;'a, C: 'static + Chip&gt; {
    chip: &amp;'static C,
    tasks: &amp;'a (),
}

pub trait ProcessType {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) { loop { } }
}

...

impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        mapcell_map(|config: &amp;mut &lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig| {
            let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
        });
    }
}

...

impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) -&gt; &amp;'static dyn ProcessType {
            let mut process: &amp;mut Process&lt;C&gt; = None.unwrap();

            process
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<blockquote>
<p>theme: Eliminate Coupling</p>
</blockquote>
<h3 id="technique-ret-ascription"><a class="header" href="#technique-ret-ascription">Technique: “Ret-ascription”</a></h3>
<p>We could further reduce Process::create a tiny bit: We can remove its return type, as long as we ensure that the coercion implied by the return type still happens in the code.</p>
<p>This is a variant on “ret-elimination”: we again want to remove the return type from the fn signature, but this time we will also ensure that any coercions implied by the return type still occur:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { if A { return B; } TailReturn }
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) { if A { let _: ReturnType = B; } let _: ReturnType = TailReturn; }
<span class="boring">}</span></code></pre></pre>
<p>For Process::create, this looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) {
        let mut process: &amp;mut Process&lt;C&gt; = None.unwrap();

        let _: &amp;'static dyn ProcessType = process;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And furthermore, we can apply “deobjectification” and “param-elimination” here; this method doesn’t even have a self parameter.</p>
<p>That gets us here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(_: &amp;'static C) { process_create::&lt;C&gt;(); }

fn process_create&lt;C: 'static + Chip&gt;() {
    let _: &amp;'static dyn ProcessType = None::&lt;&amp;mut Process&lt;C&gt;&gt;.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="take-a-breath"><a class="header" href="#take-a-breath">Take a breath</a></h2>
<p>Now that all of the involved methods seem relatively small, this seems like a good time to take a breath.</p>
<p>At this point, we could try to take these pieces and build-up a new example from scratch, preserving the core elements identified above. That’s not a bad idea at all, at this point; it could be worth spending a half-hour or so on. Either building up an example from scratch will work, or it won’t. Let’s assume for now that we are not able to jump to a minimal example, even with the pieces we have identified as core to the problem up above?</p>
<p>What now?</p>
<p>We could attempt to remove large swaths of code from the example as it stands: After all, we know we just need these methods; can we just comment everything else out?</p>
<p>Well, no. You can’t just comment random things out. The interdependencies in the crate graph will frustrate attempts to do so.</p>
<p>For example, I tried commenting out most of the code after the mod process { ... }, in the lib.rs, and got a slew of “unresolved import” errors. So, if you want to continue reducing this exmaple, we need to do it in a more directed fashion.</p>
<p>In the interest of trying to follow a semi-mindless process here, lets look at what we need to do in order to really minimize kernel to its core:</p>
<ol>
<li>We have to finish minimizing the leaves. There are crates unrelated to the ICE still being pulled into the build here, and they rely on things in kernel that we will not be able to remove until those crates are themselves reduced or otherwise eliminated from the crate graph.</li>
</ol>
<p>For us, we can apply some of the other techniques we have learned about to the leaf crates, such as using “none-defaulting” to create an instance of arty_e21::chip::ArtyExx in board/argy-e21/main.rs.</p>
<ol start="2">
<li>We have to reducing the coupling within kernel itself. It can be maddening trying to comment out modules at random. When that madness becomes too much for me, I force myself to adopt a more disciplined approach: I use the “cut-spaghetti-imports” tactic to replace the existing use imports with local definitions. (Remember: since most fn-items in every module are “loopified”, the “cut-spaghetti-imports” tactic will work fairly often.</li>
<li>This goes hand-in-hand with the general point above about reducing coupling within kernel: We have to finish mimimizing mod process { ... } itself within kernel. All of the interesting functions for reproducing the bug live there, so we know we cannot “cfgment” out that module for now. But if we have to keep mod process, we won’t be able to remove the other modules until we remove the dependencies that it has on those modules.</li>
</ol>
<p>I hope to return to this richly-documented minimization of rust-lang/rust#65774 the future; and when I do, I hope to cover all three of the points above.</p>
<p>But for now, I hope this was a helpful tour of various minimization technique that you can employ for reducing ICEs and other static analysis bugs in rustc.</p>
<h2 id="refer"><a class="header" href="#refer">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p>后续值得细读的:</p>
<ul>
<li><a href="http://blog.pnkfx.org/blog/2022/05/12/linking-rust-crates/">Linking Rust Crates, Part 1 - The {pnk}f(eli)x Blog</a></li>
<li><a href="http://blog.pnkfx.org/blog/2022/01/10/why-i-use-a-debugger/">Why I use a debugger - The {pnk}f(eli)x Blog</a></li>
<li><a href="http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/">Breaking News: Non-Lexical Lifetimes arrives for everyone - The {pnk}f(eli)x Blog</a></li>
<li><a href="http://blog.pnkfx.org/blog/categories/turbowish/">Category: turbowish - The {pnk}f(eli)x Blog</a></li>
<li>...</li>
</ul>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230228 ZQ init.</li>
</ul>
<pre><code>     _~^*~~_
 \/ /  * ◷  \ \/
   '_   ⏡   _'
   \ '--+--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../tip/open_big_file_speed.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../tip/manag_growing_proj_with_crates_modules.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../tip/open_big_file_speed.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../tip/manag_growing_proj_with_crates_modules.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "tip/rust_min_bug_patterns.md"
    </script>


    <!-- Custom JS scripts -->
    <script type="text/javascript" src="../assets/custom.js"></script>
    <script type="text/javascript" src="../assets/bigPicture.js"></script>

    <hr />

    <p style="text-align:center">

        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议"
                style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
        本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可;-)
<!--
][ <b>
    <a href="/rss.xml">RSS</a>
    </b>
-->

    </p>
    <hr />

    <script src="https://utteranc.es/client.js" repo="zhrust/comments" issue-term="pathname" label="✨💬✨"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>

</html>