<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>be Rustaceans</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

</head>

<body>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script>
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="abt/index.html"><strong aria-hidden="true">1.</strong> 有关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abt/gh-pages.html"><strong aria-hidden="true">1.1.</strong> gh-pages</a></li><li class="chapter-item expanded "><a href="abt/zhrust.html"><strong aria-hidden="true">1.2.</strong> zhrust</a></li></ol></li><li class="chapter-item expanded "><a href="dev/index.html"><strong aria-hidden="true">2.</strong> 开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/20-things-ive-learned-in-my-20-years-as-a-software-engineer.html"><strong aria-hidden="true">2.1.</strong> 20年来作为软件工程师学到的10件事</a></li><li class="chapter-item expanded "><a href="dev/concepts-i-wish-i-learned-earlier.html"><strong aria-hidden="true">2.2.</strong> 希望一早知道的关键概念</a></li></ol></li><li class="chapter-item expanded "><a href="tip/index.html"><strong aria-hidden="true">3.</strong> 技巧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tip/rust6fun-operator-overloading.html"><strong aria-hidden="true">3.1.</strong> 运算符重载六件趣事</a></li><li class="chapter-item expanded "><a href="tip/default-params.html"><strong aria-hidden="true">3.2.</strong> Rust 和默认参数</a></li></ol></li><li class="chapter-item expanded "><a href="101/index.html"><strong aria-hidden="true">4.</strong> 学习</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="101/exercism.html"><strong aria-hidden="true">4.1.</strong> Exercism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="101/ex42all-your-base.html"><strong aria-hidden="true">4.1.1.</strong> 42:all-your-base</a></li><li class="chapter-item expanded "><a href="101/ex43Allergies.html"><strong aria-hidden="true">4.1.2.</strong> 43:Allergies</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="log/index.html"><strong aria-hidden="true">5.</strong> 笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="log/rust-s-ugly-syntax.html"><strong aria-hidden="true">5.1.</strong> Rust 丑句法</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">be Rustaceans</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/zhrust/rustacean/tree/main/src" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script>
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="有关"><a class="header" href="#有关">有关</a></h1>
<blockquote>
<p>as Zoom.Quiet</p>
</blockquote>
<h2 id="main-index"><a class="header" href="#main-index">main index</a></h2>
<p><a href="https://zoomquiet.io/">mapping -&gt; ZoomQuiet.io {by gen4dot2htm.py vv.190718 at:190911 18:07:32,877571}</a></p>
<h2 id="location"><a class="header" href="#location">location</a></h2>
<h2 id="actions"><a class="header" href="#actions">actions</a></h2>
<p>...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gh-pages"><a class="header" href="#gh-pages">gh-pages</a></h1>
<blockquote>
<p>免费使用的成本</p>
</blockquote>
<h2 id="background"><a class="header" href="#background">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>凡是可以编译为 静态网站 的, 都可以通过 gh-pages/GitHub-Pages 服务来进行免费发布;</p>
<h2 id="goal"><a class="header" href="#goal">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
本地编译好, 嘦 git push ,一切就可以自动完成发布</li>
<li><input disabled="" type="checkbox"/>
而且发布到指定域名</li>
</ul>
<h2 id="trace"><a class="header" href="#trace">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<h2 id="refer"><a class="header" href="#refer">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages">验证 GitHub Pages 的自定义域 - GitHub Docs</a></li>
</ul>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zhrust"><a class="header" href="#zhrust">zhRust</a></h1>
<blockquote>
<p>zn.rust 域名</p>
</blockquote>
<h2 id="background-1"><a class="header" href="#background-1">background</a></h2>
<blockquote>
<p>名正言顺</p>
</blockquote>
<p>Ｒust 发布时间不短了,
rust 相关中文社区比当年 Python 的多不少,
所以, 2022年未很难找到简短好记的域名可以注册了</p>
<h2 id="goal-1"><a class="header" href="#goal-1">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>但是, 总是要有一个 Rust 方向的持续输出域名, 
要求从来不变</p>
<ul>
<li>rust,rustacean 相关</li>
<li>越短越好</li>
<li>越便宜越好</li>
<li>...</li>
</ul>
<h2 id="trace-1"><a class="header" href="#trace-1">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li>原先有 101.camp,101.so 所以尝试 rust.so, 已经没有</li>
<li>又尝试 rustacean.so 还有,只是贵而且又长...</li>
<li>那么 在 namecheap.com 再挖掘一下, 没想到
<ul>
<li>.rust 竟然有这个根域名</li>
<li>立即先注册 cn.rust 以及 china.rust</li>
</ul>
</li>
<li>可惜几天过去 dig 指令依然查不到记录,看来 <code>.rust</code> 还是一个预备根域名,至少中国根还不识别..
<ul>
<li>只能恢复使用 <code>rs.101.so</code> 这个域名</li>
<li>另外将 <code>weekly.rs.101.so</code> 也发布出来开始坚持关注每周社区关键变化...</li>
</ul>
</li>
</ul>
<h2 id="refer-1"><a class="header" href="#refer-1">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-1"><a class="header" href="#logging-1">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230101 ZQ 变更域名指向</li>
<li>221230 ZQ init.
<ul>
<li>迁移 utterances 🔮 评注到 https://github.com/zhrust/comments</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<blockquote>
<p>projects ...</p>
</blockquote>
<h2 id="background-2"><a class="header" href="#background-2">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>开发语言学习, 不用来开发真实项目, 基本是表演学习行为了...</p>
<h2 id="goal-2"><a class="header" href="#goal-2">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>一组日常要用工具, 原创/再制/...</p>
<p>关键是积累一组可用作品, 打底儿.</p>
<h2 id="trace-2"><a class="header" href="#trace-2">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>???</p>
<h2 id="refer-2"><a class="header" href="#refer-2">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-2"><a class="header" href="#logging-2">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20年来作为软件工程师学到的20件事"><a class="header" href="#20年来作为软件工程师学到的20件事">20年来作为软件工程师学到的20件事</a></h1>
<p>原文: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/">20 Things I've Learned in my 20 Years as a Software Engineer - Simple Thread</a></p>
<h2 id="注意请先阅读此内容"><a class="header" href="#注意请先阅读此内容">注意:请先阅读此内容</a></h2>
<p>即将展现的是一篇包含大量建议的 blog ;
向前人学习对成功至关重要,但是,我们常常忘记另外一个重要警告:
几乎所有的建议都是上下文相关的, 但是,很少对上下文提供细节;</p>
<p>&quot;你需要收取更多费用!&quot; 这经营了20年的公司说, 多年以来收费&quot;太低&quot;,无法赢得客户并取得成功;</p>
<p>&quot;你需要将一切构建为微服务!&quot; 该公司表示, 构建了一个快速的整体,获得了数千客户,然后,在开始遇到问题时, 全面转向了微服务;</p>
<p>如果不了解上下文, 建议就毫无意义,甚至更糟糕,有害;
如果那些人早点听从他们自己的建议,他们自己可能会因此受苦;
对于任何建议很难逃脱这个陷阱;
我们可能是我们经历的终点,但是,我们却是通过现在的镜头来观察;</p>
<p>因此,为了让你了解一下这些建议的来源,特此说明:
我在职业生涯的前半段担当软件工程师,为各种小型企业和初创公司工作,
然后,我进入咨询行业并在许多非常太的企业工作;
最后, 我开创了 <code>Simple Thread</code>,
我们从一个2人团队成长为一个25人的团队;
10年前, 我们主要和中小型企业合作,现在我们和大型和小型企业合作;</p>
<p>我的所有建议来自于:</p>
<ul>
<li>几乎总是在小而精干的团队中,我们必须用很少的资源作很多事情</li>
<li>重视工作软件而不是特定工具</li>
<li>一直在开始新项目,同时还要维护一些系统</li>
<li>重视工程师的生产力,超过其它大多数考虑因素</li>
<li>...</li>
</ul>
<p>我过去20年的经历塑造了对软件的偏见,
并使我形成了一些信念;
我试图将这些信念压缩为一个易于使用的列表,
希望你能发现她们的价值;</p>
<h2 id="建议清单"><a class="header" href="#建议清单">建议清单:</a></h2>
<h3 id="1-我仍然懂的不是太多"><a class="header" href="#1-我仍然懂的不是太多">1. 我仍然懂的不是太多</a></h3>
<p>&quot;你怎么不知道 BGP ?&quot;</p>
<p>&quot;你从来没听说过 Rust?&quot;</p>
<p>我们大多数人都被人这么说过,
而且可能听的太频繁了;
我们中许多人喜欢软件的原因就是因为我们是终身学习者, 在软件领域,
无论你从哪个方向看, 都有广阔的知识前景向各个方向发展,
而且每天都在扩展;
这意味着即便你在职业生涯中度过数十年,
但是, 和同样在看似相似的角色中度过数十年的人相比,
仍然存在巨大的知识差距;
越早意识到这点, 就能越早开始摆脱 &quot;顶替者综合症&quot; ,
转而乐于向他人学习和教导他人;</p>
<h3 id="2-软件最难的部分是构建正确的东西"><a class="header" href="#2-软件最难的部分是构建正确的东西">2. 软件最难的部分是构建正确的东西</a></h3>
<p>我知道在这点上算陈词滥调,
但是, 大多数软件工程师并不相信的原因是, 他们认为这在贬低他们的工作;
我个人认为这是无稽之谈；
相反,这突出了我们必须工作的环境本身复杂性和不合理性,
这故居了我们的挑战;
你可以设计出世界上技术上最令人印象深刻的东西,
然后, 却无人愿意使用;
这种事儿一直在发生;
设计软件主要是一种倾听活动,
我们经常不得不成为竕软件工程师, 部分通灵师, 以及部分人类学家;
投资在这个设计过程, 无论是通过专门的 UX 团队, 还是通过简单的自我教育,
都将带来巨大的回报;
因为, 你如何计算构建错误软件的真正成本?
这不仅仅是损失工程时间...</p>
<h3 id="3-最好的软件工程师像设计师一样思考"><a class="header" href="#3-最好的软件工程师像设计师一样思考">3. 最好的软件工程师像设计师一样思考</a></h3>
<p>伟大的软件工程师会思考他们代码的用户体验;
他们可能不会用各种术语来考虑,
而是考虑应该是外部API/编程API/用户界面/协议还是其它任何界面;
伟大的工程师会考虑谁将使用, 为什么要使用,如何使用,
以及这些对用户来说什么是最重要的;
牢记用户的需求, 确认是良好用户体验的核心;</p>
<h3 id="4-最好的代码是没有代码或是你不必维护的"><a class="header" href="#4-最好的代码是没有代码或是你不必维护的">4. 最好的代码是没有代码,或是你不必维护的</a></h3>
<p>我只想说: &quot;码农只能编码&quot;;
你问任何行业的人如何解决问题, 
他们都会在他们擅长的领域犯错误;
叫只是人性;
大多数软件工程师总是会在编写代码时出错,
尤其是当非技术解决方案不明朗时;
你不必维护的代码也是如此;
当很多轮子已经存在时,
工程团队很容易想要重新发明轮子;
这是一种平衡行为, 
有很多理由让你自己再来一遍,
但是, 要提防这种 &quot;没在此现实&quot;(“Not Invented Here”) 综合症;</p>
<h3 id="5-软件是达到目的的手段"><a class="header" href="#5-软件是达到目的的手段">5. 软件是达到目的的手段</a></h3>
<p>任何软件工程师的主要工作是交付价值;</p>
<p>很少有软件开发者理解这一点, 将其内化的就更少了;
真正将其内化后, 能导致解决问题的不同方式,
以及观察工具的不同方式;
如果真真的相信软件是从属于结果的,
你就会准备好找到真正&quot;适合的工具&quot;,
有时可能根本不是软件;</p>
<h3 id="6-有时你必须停止磨锯直接开始砍屎"><a class="header" href="#6-有时你必须停止磨锯直接开始砍屎">6. 有时你必须停止磨锯,直接开始砍屎</a></h3>
<p>有些人倾向于跳入问题, 并立即开始编写代码;
其它人往往想要研究和陷入硬件分析进而瘫痪;
在这些情况中,为自己设定一个截止日期,
然后, 开始探索解决方案;
当你开始解决问题时,你很快能学习到更多,
这也将引导你迭代到更好的解决方案;</p>
<h3 id="7-如果你不能很好的理解所有可能性-就无法设计出好的系统"><a class="header" href="#7-如果你不能很好的理解所有可能性-就无法设计出好的系统">7. 如果你不能很好的理解所有可能性, 就无法设计出好的系统</a></h3>
<p>这是我一直在努力解决的问题,
因为, 我的职责使我在软件工程的日常工作中越来越远;
峎上开发者生态是一项巨大的工作,
但是,了解什么是可能的至关重要;
如果你不了解给定生态中有什么是可能的,以及什么是可用的,
那么你将发现除了最简单的问题之外,
不可能设计出一个合理的解决方案来解决所有问题;
总而言之, 要警惕那些很长时间没有编写任何代码的架构专家;</p>
<h3 id="8-每个的了了的都很糟粕克服丫的"><a class="header" href="#8-每个的了了的都很糟粕克服丫的">8. 每个的了了的都很糟粕,克服丫的</a></h3>
<p>Bjarne Stroustrup 有句名言:
&quot;只有两种语言: 人们抱怨的语言, 和没人使用的语言&quot;;</p>
<p>这也可以拓展到大型系统;
没有&quot;正确&quot;的架构, 你永远无法偿还所有技术债务,
你永远无法设计出完美的界面,
你的测试总是太慢;
这不是永不让事情变得更好的借口,
而是一种给你观点的方式;
少担心优雅和完美;
相反, 努力持续改进并创建一个你的团队喜欢在其中工作,
并可以持续创造价值的宜人系统;</p>
<h3 id="9-无人问足为什么"><a class="header" href="#9-无人问足为什么">9. 无人问足&quot;为什么&quot;</a></h3>
<p>抓住任何机会质疑&quot;作事方式&quot;的假设和方法;
有新人加入嘛?
注意他们在哪里感到困惑以及他们在问什么问题;
有没有无意义新功能请求?
确保你了解目标以及是什么推动了对这一功能的渴望;
如果你没有得到明确的答案,
请继续问为什么, 直到你明白为止;</p>
<h3 id="10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员"><a class="header" href="#10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员">10. 我们应该更专注于避免0.1x 程序员,而不是寻找 10x 程序员</a></h3>
<p>10倍速程序员是一个愚蠢的神话;
某人可以在1天里生产出另外一位有能力/勤奋/有类似经验的程序员需要在2周以内生产代码的想法是愚蠢的;
我见过程序员编写10倍的代码,
然后, 你必须修复它10倍以上的次数;
某珍爱可以成为10倍程序员的唯一方法,
是将他们和 0.1 倍速程序员进行比较;
有人浪费时间, 不寻求反馈, 不测试代码,
不考虑边缘情况等等...</p>
<p>我们应该关心让 0.1 倍速程序员远离我们的团队,
而不是寻找神话般的 10 倍速程序员;</p>
<h3 id="11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见"><a class="header" href="#11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见">11. 高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见</a></h3>
<p>没有什么比对他们的工具或是如何构建软件没有有意见的高级工程师更让我担心的事儿了;</p>
<p>我宁愿有人给有强烈的反对意见, 也不愿他们完全没有意见;
如果你正在使用你的工具,而且你还没有更多喜欢或是讨厌的情绪,
那么, 你需要更多体验;
你需要探索其它语言/库/范例;
没有什么比积极寻找其它人如何使用和你不同的工具和技术来完成任务更快提高技能的方法了;</p>
<h3 id="12-人们并不是真想创新"><a class="header" href="#12-人们并不是真想创新">12. 人们并不是真想创新</a></h3>
<p>人们经常谈论创新,
但是, 他们通常寻找的是廉价的胜利和新奇;
如果你在真正的创新, 并想改变人们作事的方式,
那么大多数情况下都会收到负面反馈;
如果你相信自己在作的事儿,
并知道确实会改善事情,
那么为自己的长期战斗作好准备;</p>
<h3 id="13-数据是你系统中最重要的部分"><a class="header" href="#13-数据是你系统中最重要的部分">13. 数据是你系统中最重要的部分</a></h3>
<p>我见过很多系统, 其中希望数据完备性是系统主要机制;
在这种系统中,
任何在黄金路径之外发生的事情,都会心产生部分脏数据;
将来处理这些数据将是一场噩梦;
请记住, 你的数据可能会比你的代码要长寿;
花精力保持数据秩序和清洁,从长远看会有好的回报;</p>
<h3 id="14-寻找技术鲨鱼"><a class="header" href="#14-寻找技术鲨鱼">14. 寻找技术鲨鱼</a></h3>
<p>仍然存在的旧技术是鲨鱼而不是恐龙;
他们解决问题能力如此之强,以至在技术世界不断发生的快速变化中幸存下来;
不要和这些技术打赌,
只有在有充分理由的情况下才负担它们;
这些工具不会华而不实,
也不会令人兴奋,
得是不是, 它们能在没有很多不眠之夜的情况下完成工作;</p>
<h3 id="15-还要把谦逊误认为无知"><a class="header" href="#15-还要把谦逊误认为无知">15. 还要把谦逊误认为无知</a></h3>
<p>有很多软件工程师除非被直接问到,
否则不会发表意见;
永远不要认为仅仅因为有人没有将意见扔到你面前,
他们就没有什么可以补充的;
有时, 最吵闹的人是我们最不想听的;
和周围人交谈, 寻求他们的反馈和建议;
你会庆幸你这么作了;</p>
<h3 id="16-软件工程师应该定期写作"><a class="header" href="#16-软件工程师应该定期写作">16. 软件工程师应该定期写作</a></h3>
<p>软件工程师应该定期写 blog/日记/文档,
通常作需要他们保持书面沟通技巧的事儿;
写作可以帮助你思考问题,
并帮助你能更有效的和团队以及未来的自己沟通;
良好的书面沟通是任何软件工程师都必须掌握的最重要技能之一;</p>
<h3 id="17-尽可能保持流程简洁"><a class="header" href="#17-尽可能保持流程简洁">17. 尽可能保持流程简洁</a></h3>
<p>现在每个人想想变得敏捷,
但是,&quot;敏捷&quot;就是以小块的方法构建事物/学习/然后迭代;
如果有人试图在其中塞入更多东西,
那么,他们可能只是在卖东西;
这并不是说人们不需要问责或是帮助以便用这种方式协作,
但是, 你有多少次听到你最喜欢的科技公司或是大型开源项目成员有吹嘘他们的 Scrum 流程有多NB?
保持精益过程,
直到你知道你需要更多;
相信你的团队,他们能交付成果;</p>
<h3 id="18-软件工程师和所有人一样需要有主人翁精神"><a class="header" href="#18-软件工程师和所有人一样需要有主人翁精神">18. 软件工程师和所有人一样,需要有主人翁精神</a></h3>
<p>如果你将某人从他们的工作成果小分离出来,
他们就会更彡关心他们的工作;
我认为这几乎是必然的;
这是跨职能团队作的如此出色,
以及 DevOps 变得如此流行的主要原因;
这不仅仅是关于交接和效率低下,
而是关于从头到尾拥有整个过程, 并且是直接的负责交付价值;
让一群充满激情的人完全拥有设计/构建和交付软件(或任何东西)的权利,
惊人的事情就会发生;</p>
<p>(译注: 当然, 得是有意义的事务, 为领导一些幻想去努力很难有什么主人翁精神能触发)</p>
<h3 id="19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值"><a class="header" href="#19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值">19. 面试对于告诉某人将成为团队成员有多赞,几乎毫无价值</a></h3>
<p>面试最好花在了解某人是谁,
以及他们对特定专业领域的兴趣程度上;
试图推测他们将成为多么优秀的团队成员是徒劳的;
相信我,
一个人有多聪明或是多博学也不能很好的证明他们将成为一名优秀的团队成员;
没有人会在面试中告诉你他们不可靠/爱辱骂/自负或是从不准时参加会议;
人们可能会声称他们对这些事情有&quot;信号&quot;...
&quot;如果他们在第一面试时询问请假,那么他们永远不会去请假!&quot;
但是, 这些都是废话;
如果你使用这种信号, 只是在猜测并拒绝优秀的候选人;</p>
<h3 id="20-始终努力构建一个更小的系统"><a class="header" href="#20-始终努力构建一个更小的系统">20. 始终努力构建一个更小的系统</a></h3>
<p>有很多力量促使你预先构建更大的系统;
预算分配, 无法测定应该精减哪些功能,
希望提供系统的&quot;最佳版本&quot;;
所有,这些事情都非常有力的推动我们构建更多;
你应该阻止这个;
你在构建一个系统时学到了很多东西,
你最终将迭代到一个比你最初设计的系统更好的版本;
令人惊讶的必须,
这对太多数人来说是难以接受的;</p>
<h2 id="你的故事呢"><a class="header" href="#你的故事呢">你的故事呢?</a></h2>
<p>这是全部了, 20年的软件生涯提炼出来的的20条精辟断言;</p>
<p>如果有什么能引发你的共鸣,
我很很听听;
我也很想知道你在职业生源中积累的智慧并愿意分享出来;
请在评论中留言吧;</p>
<h2 id="refer-3"><a class="header" href="#refer-3">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p>很有人不同意所有观点: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/#comment-142472">January 25, 2023 at 7:25 pm</a></p>
<h3 id="hard-disagree-with-most-of-the-20-items"><a class="header" href="#hard-disagree-with-most-of-the-20-items">Hard disagree with most of the 20 items.</a></h3>
<ol>
<li>
<p>Writing software is difficult, tedious and needs real work. No silver bullet libraries, no methodology, no framework, no IOT, no amount of unit tests will get the work done faster.</p>
</li>
<li>
<p>Developers collect tools, libraries and pet technologies and make projects go over their time and budget by doing it.</p>
</li>
<li>
<p>Code should encapsulate algorithms and not be structured other wise. Code should follow the business logic and be readable and match business requirements easily.</p>
</li>
<li>
<p>Forgetting history keeps the productivity and industry down. Microsoft re-discovering the same old technology which existed on 1960s mainframes for the 7th time just to sell products, trademark buzzwords, training, certification and everything is an anchor around the modern developer’s neck. Think file transfer -&gt; X12 -&gt; serial communication -&gt; raw socket packets -&gt; corba -&gt; xml soap -&gt; xml http -&gt; Rest JSON http -&gt; gRpc as a 50 year journey of rediscovering the same thing repeatedly, each not really that much better than the older technologies, wrapping mounds of interlarded crud on top of fragile, hard to program libraries and the square peg in a round hole mismatch.</p>
</li>
<li>
<p>Refusing to hold W3C and large tech companies accountable for not fixing web HTTP, HTML, CSS and JavaScript for 25+ years.
– How can I create a control which has HTML, CSS, JS which has encapsulated CSS, encapsulated HTML, encapsulated JS without a 10,000 file framework?
– How to match HTML DOM elements with JS without using quoted magic strings? Quoted magic strings were proven anti-productivity and anti-quality in the 1960s
– How to have a UI without the everything is a call back and function pointer? Function pointers with modern wrappings are just as bad as the 1060s computed jump to function tables</p>
</li>
<li>
<p>Forgetting that tech is a business with a 7 year hype cycle, with the new thing being embryonically hyped for 2 years by cutting edge bloggers, then 2 years by sales marketing of companies, then 3 years of disappointment for companies trying to implement it. Followed by, abandonment when the ROI does not work out. Resume driven development, just for business persons.
And yes, there’s a new hype every 2 years to waste time and money on</p>
</li>
<li>
<p>Not holding tech companies accountable when they release major products, .net core, which have less than a 5 year full support lifecycle. Long term support .net is under 3 years.
That is a forced upgrade every 3 years for every .net system just to pass the IT auditors at a large company</p>
</li>
<li>
<p>Devaluing your own worth and work as a developer by telling everyone that the proposed product/task is easy. Software dev is hard work, less than 1 of a 1000 people can even do it poorly.
I would not go to a brain surgeon that told everyone that what he does is easy.</p>
</li>
<li>
<p>Forgetting that software development is a hard, tedious, isolated job where people desiring lots of human interaction will rapidly leave the field by their own choice and lots of people not getting into the field by their own choice.</p>
</li>
<li>
<p>Not telling people that you as a developer have to say “No, it’s too expensive” or “No, it’s too risky” as a regular part of your job. Persons not developing software treating you poorly with career ending consequences just because you won’t accept the death march cross to bear of impossible requirements of an impossibly short deadline</p>
</li>
<li>
<p>Not helping your fellow developers out. Speak well of your co-developers, team, and industry. Don’t downplay the difficulty, complexity or contribution of software.</p>
</li>
<li>
<p>Not calling people out when they think that more data, metrics for everything will automatically solve problems. Ask for a business case, ask for the questions they want to answer (in written form), get the business case and questions they want to answer from the requestor, make sure they are approved before committing to a tight deadline</p>
</li>
<li>
<p>Not damaging the next developer on your project – too many technologies, framework of the month, just another nuget package, one more class, have another 3 patterns, data on disk, data in database structure and consistency is not important and, yes, this system will never receive/send upstream/downstream data</p>
</li>
<li>
<p>Accepting code without parameter checking, error handling or in-line comment documentation (<em>cough</em> vendor’s happy path ‘doc’ page or <em>cough</em> signature only documentation with no example code or error handling.)</p>
</li>
<li>
<p>Misguided acceptance that best practices are best and not just a short nicely sized blog entry. Best practices, in many cases, do not scale for large 1,000,000+ line of code systems and make maintenance harder.</p>
</li>
<li>
<p>Not challenging the ‘more technology is better’ approach</p>
</li>
</ol>
<h2 id="logging-3"><a class="header" href="#logging-3">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230201 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="希望一早知道的关键概念"><a class="header" href="#希望一早知道的关键概念">希望一早知道的关键概念</a></h1>
<p>原文: <a href="https://rauljordan.com/rust-concepts-i-wish-i-learned-earlier/">rauljordan::blog</a></p>
<h2 id="快译"><a class="header" href="#快译">快译</a></h2>
<p>过去一个月里, 我被 Rust 语言彻底迷住了,
因为,她在编写内存安全的现代程序方面具有独特的优势.
多年以来, 有几种语言已经成为工程师编写弹性后端软件的首选语言.
潮流已经从 JAVA/C++ 转向 Go 和 Rust,
她们结合了数十年编程语言理论来构建我们这个时代最需要的工具.</p>
<p>Rust 的地位不言则明.
作为最受一欢迎的语言, 连续7年度在著名 <code>stack overflow</code> 调查中排名第一!
最近还作为 Linux 内核的一部分发布 -- 这是除 C 之外任何语言之前都无法作到的壮举.
对我而言, 这门语言令人兴奋的地方在于,
她在软件构建艺术方面提供了一些真正新颖的东西.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;
use std::{collections::VecDeque, sync::Condvar, sync::Mutex};

fn main() {
    let queue = Mutex::new(VecDeque::new());

    thread::scope(|s| {
        let t = s.spawn(|| loop {
            let item = queue.lock().unwrap().pop_front();
            if let Some(item) = item {
                dbg!(item);
            } else {
                thread::park();
            }
        });

        for i in 0.. {
            queue.lock().unwrap().push_back(i);
            t.thread().unpark();
            thread::sleep(Duration::from_secs(1));
        }
    })
}
</code></pre></pre>
<p>Rust 在整个系统编程中获得了令人难以置信的使用, 
也因难以学习而闻名. 尽管如此, 还是有很多优秀的 Rust 内容可以满足初学者和高级程序员的需求.
然而, 他们中太多人专注解释语言的核心机制和所有权概念, 而不是构建应用程序.</p>
<p>作为一名编写高并发程序并专注在系统编程的 Go 开发者, 
我在学习如何使用 Rust 构建真实程序的过程中遇到了很多障碍. 
也就是交织, 如果我将当前正在从事的工作移植到 Rust 中, 那么所有这些教程的效果如何呢?</p>
<p>此篇文章旨在介绍我进入 Rust 兔子洞的经历, 
以及我希望一些学习资源可以更好阐述的内容. 
对个人而言, 我无法通过简单的观看 youtube 视频来学习一门新语言, 
而是必须通过为自己寻找解决方案,犯错以及对过程感受谦卑来积累．</p>
<h3 id="关于参考"><a class="header" href="#关于参考">关于参考</a></h3>
<p>Rust 中有两种引用, 共享引用(也称为 <code>借用</code>)和可变引用(也称为<code>独占引用</code>).
通常这些被视为变量 x 上的 &amp;x 以及 &amp;mut x . 
一旦我开始将后者称为&quot;独家参考&quot;, 这两白间的区别就更有意义了.</p>
<p>Rust 的参考模型相当简单. 借款人可以根据需要拥有对某对象的尽可能多的共享引用, 
但是, 一次只能有一个独占引用. 
否则, 你可能会有很多调用者同时尝试对同一个值进行修改的囧境;
如果很多借用者也可以持有独占袭用, 
你将面临未定义行为风险, 
而安全的 Rust 则不允许这么折腾.</p>
<p>在学习 Rust 时, 都用 &amp;mut 独家参考可以节省很多时间:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo {
    x: u64,
}

impl Foo {
    /// Any type that borrows an instance of Foo can
    /// call this method, as it only requires a reference to Foo.
    pub fn total(&amp;self) -&gt; u64 {
        self.x
    }
    /// Only exclusive references to instances of Foo
    /// can call this method, as it requires Foo to be mutable.
    pub fn increase(&amp;mut self) {
        self.x += 1;
    }
}

let foo = Foo { x: 10 };
println!(&quot;{}&quot;, foo.total()) // WORKS.
foo.increase() // ERROR: Foo not declared as mut
<span class="boring">}
</span></code></pre></pre>
<h3 id="双向引用是可以的"><a class="header" href="#双向引用是可以的">双向引用是可以的</a></h3>
<blockquote>
<p>Bidirectional references are possible</p>
</blockquote>
<p>在其它具有垃圾收集功能的语言中, 很容易定义图形数据结构或其它包含对某些子项引用的类型, 
并且这些引用可以包含对其父项的引用;
在 Rust 中, 如果不完全理解借用规则, 这是很难作到的;
但是, 仍然可以使用标准库提供的正法.</p>
<p>假设我们有一个名为 Node 的结构, 
包含一组对子节点的引用, 以及一个对父节点的引用; 
通常, Rust 会抱怨, 但是, 我们可以通过将父引用包装在称为 <code>弱指针</code> 的东西中来满足借用检查器的要求;
这种类型告诉 Rust 一个节点消失, 或者其子节点消失, 不应该意味着父节点也应该被删除;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::{Rc, Weak};

struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>这为我们提供了构建双向引用的便利原语; 
然而, 我很快发现在 Rust 中构建图形数据真的很难, 
除非你真的知道自己在作什么, 考虑到一个人需要围绕有效建模数据来作大量的 <code>book-keeping</code> 工作以满足编译器.</p>
<p>(是也乎: 编译器作为 Rust 生态中最大的 BOSS 必须优先满足.)</p>
<h3 id="实施-deref-令代码更清晰"><a class="header" href="#实施-deref-令代码更清晰">实施 Deref 令代码更清晰</a></h3>
<blockquote>
<p>Implement Deref to make your code cleaner</p>
</blockquote>
<p>有时我们希望将包装器类型视之为其包含的内容;
对于常见的数据结构(比如 vec),智能指针(例如 Box) 甚至引用计数类型(类似 Rc 和 Arc) 都是如此;
标准库包含称为 Deref 和 DerefMut 的特征, 
她们将报时你告诉 Rust 应该如何取消引用一个类型;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Deref, DerefMut};

struct Example&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Deref for Example&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.value
    }
}

impl&lt;T&gt; DerefMut for Example&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.value
    }
}

let mut x = Example { value: 'a' };
*x = 'b';
assert_eq!('b', x.value);
<span class="boring">}
</span></code></pre></pre>
<p>上述示例代码中, 我们可以将 <code>*x</code> 视为其基础值 <code>&quot;a&quot;</code>, 
甚至可以改变它, 因为, 我们定义了应该如何在借用或可变引用中取消引用的规则;
这很强大, 也是你无需担心在 Box 等智能指针中包装类型的原因;</p>
<p>值被装箱的事实是一个实现细节, 可以通过这些特征抽象出来;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    value: u64,
}
let mut foo = Box::new(Foo { value: 10 });

// Box implements DerefMut, so this will work fine!
*foo = Foo { value: 20 };
// Dot methods will work on foo because Box implements Deref.
// We do not have to worry about the implementation
// detail that Foo is boxed.
assert_eq!(20, foo.value);
<span class="boring">}
</span></code></pre></pre>
<h3 id="小心实现-deref-类型方法"><a class="header" href="#小心实现-deref-类型方法">小心实现 Deref 类型方法</a></h3>
<blockquote>
<p>Be careful with methods on types that implement Deref</p>
</blockquote>
<p>有没有想过, 为什么像 <code>Arc::clone</code> 这类方法的存在, 
而我们只能对 Arc 值执行 <code>.clone()</code>?
原因和类型如何实现 Deref 有关, 
这是开发者应该警惕的事儿;</p>
<p>考虑以下示例, 我们正在尝试从标准库中实现我们自己版本的
多生产者/单一消费者(mpsc)通道:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex, Condvar};

pub struct Sender&lt;T&gt; {
    inner: Arc&lt;Inner&lt;T&gt;&gt;,
}

impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;mut self, t: T) {
        ...
    }
}

impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // ERROR: Does not know whether to clone Arc or inner!
            inner: self.inner.clone(),
        }
    }
}

struct Inner&lt;T&gt; {
    ...
}

impl&lt;T: Clone&gt; Clone for Inner&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上述示例中, 我们有一个要在其上实现 Clone 特征的 Sender 类型;
该结构有一个名为 inner 的字段, 其类型为 <code>Arc&lt;Inner&lt;T&gt;&gt;</code> ;
回想一下 Arc 已经实现了 Clone 和 Deref ;
最重要的是, 我们的 Inner 还现实了 Clone ;
对于上面的代码, Rust 并不知道我们是要克隆 Arc 还是实际的内部值,
所以, 上面代码会失败;
在这种情况下, 我们可以使用 Arc 从 sync 包中提供的实际方法;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // Now Rust knows to use the Clone method of Arc instead of the
            // clone method of inner itself.
            inner: Arc::clone(&amp;self.inner),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="理解何时以及何时不用内部可变性"><a class="header" href="#理解何时以及何时不用内部可变性">理解何时以及何时不用内部可变性</a></h3>
<blockquote>
<p>Understand when and when not to use interior mutability</p>
</blockquote>
<p>有时, 你需要在代码中使用 Rc 或是 Arc 等结构, 
又或者实现包装一些数据结构, 然后, 又想要改变被包装的数据;
很快, 编译器就会告诉你, 内部可变性是不允许的, 乍看起来这很棘手;
然而, 有一些方法允许 Rust 中的内部可变性, 
甚至是由标准库提供的;</p>
<p>最简单的一种是 Cell, 她为你提供数据的内可变性;
也就是说, 嘦数据复制成本低, 
你就可以在 Rc 中改变数据;
你可以通过将数据包装在 <code>Rc&lt;Cell&lt;T&gt;&gt;</code> 中来实现这一点;
她提供了 get 和 set 方法,
甚至不需要被 mut , 因为, 她们是在底层复制数据的:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// impl&lt;T: Copy&gt; Cell&lt;T&gt;
pub fn get(&amp;self) -&gt; T

// impl&lt;T&gt; Cell&lt;T&gt;
pub fn set(&amp;self, val: T)
<span class="boring">}
</span></code></pre></pre>
<p>其它类型, 比如 RefCell 有助于将某些借用检查移至运行时, 并跳过一些编译器的严格过滤;
然而, 这是有风险的, 因为, 如果没有完成借用检查, 就可能在运行时触发 panic ;
将编译器当成朋友, 你会获得回报;
通过跳过编译器检查, 或是将她们推迟到运行时, 
等于告诉编译器&quot;相信我 --- 我作的都是正确的&quot;;</p>
<p>而 std::cell 包甚至通过一个很有帮助的消息警告我们:</p>
<pre><code>
更常见的继承可变性, 其中必须具有唯一访问权限才能改变值,
这一语言元素是令 Rust 能强力推理指针别名, 静态防止崩溃错误的关键;
因此, 继续可变性是首选, 内部可变性是最后的手段;
由于 Cell 类型可以在不允许突变的地方启用突变, 
因此, 在某些情况中, 内部可变性也许是合适的, 甚至必须使用, 例如:

- 在不可变事物的&quot;内部&quot;引入可变性
- 逻辑不可变方法的实现细节
- 克隆的变异实现

</code></pre>
<h3 id="get-和-get-mut-方法是一回事儿"><a class="header" href="#get-和-get-mut-方法是一回事儿">get 和 get mut 方法是一回事儿</a></h3>
<blockquote>
<p>Get and get mut methods are a thing</p>
</blockquote>
<p>很多类型, 包含 vec 都实现了 get 与 get_mut 方法,
让你可以借用和改变结构中的元素
(前者只有在你有一个对集会的可变引用时才可能);
我花了一段时间, 才知道这些选项可用于许多数据结构,
她们通过更轻松的编写干净的代码, 帮助我的生活更轻松!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut [0, 1, 2];

if let Some(elem) = x.get_mut(1) {
    *elem = 42;
}
assert_eq!(x, &amp;[0, 42, 2]);
<span class="boring">}
</span></code></pre></pre>
<h3 id="拥抱不安全但合理的代码"><a class="header" href="#拥抱不安全但合理的代码">拥抱不安全但合理的代码</a></h3>
<blockquote>
<p>Embrace unsafe but sound code</p>
</blockquote>
<p>作为一名 Go 开发者, &quot;unsafe&quot; 包总是感觉很不靠谱,
而且我很少接触;
然而, Rust 中 “unsafe” 的概念是完全不同的;
事实上, 很多标准库都使用 <code>“unsafe”</code> 来取得巨大成功!</p>
<p>这怎么可能? 尽管 Rust 使未定义的行为成为不可能,
但是, 这不适用于标记为 “unsafe” 的代码块;
相反, 编写 “unsafe” Rust 的开发者嘦保证其使用合理,
即可获得所有好处;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Example taken from the Rustonomicon
fn item_at_index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt; arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>嘦你能证明你的 API 是可靠的,
就接受 unsafe, 但是, 要避免逈你的消费者暴露 unsafe 函数,
除非是真正有保证的;
出于这个原因, 在 Rust 中,对你的包内部进行严格控制,
可以证明 unsafe 代码块是合理的了;</p>
<p>通常在性能绝对重要的情况下, 才使用 unsafe,
或者当你知道使用 unsafe 代码块是解决问题的简单方法,
并且可以证明代码的可靠性时;</p>
<p>(<code>是也乎:</code></p>
<p>安全和可靠分离, 那么, 什么是可靠呢?</p>
<p>)</p>
<h3 id="尽可能用-impl-类型作为参数而不是通用约束"><a class="header" href="#尽可能用-impl-类型作为参数而不是通用约束">尽可能用 impl 类型作为参数而不是通用约束</a></h3>
<p>这点来自 Golang, 我认为特征可以一直简单的作为函数参数来提供;
比如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Meower {
    fn meow(&amp;self);
}

struct Cat {}

impl Meower for Cat {
    fn meow(&amp;self) {
        println!(&quot;meow&quot;);
    }
}

// ERROR: Meower cannot be used as it does not have
// a size at compile time!
fn do_the_meow(meower: Meower) {
    meower.meow();
}
<span class="boring">}
</span></code></pre></pre>
<p>...但是,上述代码失败了,
因为, trait 对象在编译时没有 Rust 完成工作需要的内存尺寸;
我们可以通过添加 <code>&amp;dyn Meower</code> 来告诉编译器这是动态调整大小来绕过,
但是, 很快我了解到这不是 <code>rusty</code>/锈范儿 解决方案;
相反,开发者倾向于衖受特征约束的通用参数,
例如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow&lt;M: Meower&gt;(meower: M) {
    meower.meow();
}
<span class="boring">}
</span></code></pre></pre>
<p>...现在能通过编译了;
然而,随着函数越来越复杂, 如果我们还包括其它通用参数,
就可能会有一个非常难以阅读的函数声明;
在此示例中,如果我们只想用一次 meow,
那么, 实际上并不需要动用泛型;
我们甚至于并不关心 meow 的结果,
所以, 可以改写为这样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow(meower: &amp;impl Meower) {
    meower.meow();
}
<span class="boring">}
</span></code></pre></pre>
<p>这样告诉编译器:&quot;我只想要实现 Meow 的东西&quot;;
当然,这正是我们需要的,
并且,首先不需要函数的通用返回类型时,
此模式会更加清晰;</p>
<h3 id="用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有"><a class="header" href="#用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有">用 iter() 过程中想借用时, iter mut() 用以独占 refs,而 into iter() 支持拥有</a></h3>
<p>很多教程立即跳转到使用下面的 into_iter 方法来迭代 vectors/向量:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let items = vec![1, 2, 3, 4, 5];
for item in items.into_iter() {
    println!(&quot;{}&quot;, item);
}
<span class="boring">}
</span></code></pre></pre>
<p>然而,当我们刚刚开始在结构中使用这个迭代器方法时,
很多初学者(包括作者自己)都碰壁了,例如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: Vec&lt;u32&gt;,
}

impl Foo {
    fn all_zeros(&amp;self) -&gt; bool {
        // ERROR: Cannot move out of self.bar!
        self.bar.into_iter().all(|x| x == 0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>并立即提示:</p>
<pre><code>    error[E0507]: cannot move out of `self.bar` which is behind a shared reference
       --&gt; src/main.rs:9:9
        |
    9   |         self.bar.into_iter().all(|x| x == 0)
        |         ^^^^^^^^ ----------- `self.bar` moved due to this method call
        |         |
        |         move occurs because `self.bar` has
        |         type `Vec&lt;u32&gt;`, which does not implement the `Copy` trait

</code></pre>
<p>作为菜鸟尝试了很多办法后, 才意识到 <code>.into_ter()</code> 取得了集合的所有权,
这不是我的目标所需要的;
相反, 在迭代器上还有另外两种有用的方法, 真希望当时能早点知道丫们;</p>
<p>第一个是 <code>.iter()</code> ,借用集合, 让你断言关于其值的东西,但是, 不拥有或是改变她们;
再有就是 <code>iter_mut()</code> 帮助你改变集合内部值,嘦你是唯一的exclusive reference/独占参考;</p>
<p>总之, 当你只需要借用时用 <code>.iter()</code>,
当你想要获得所有权时用 <code>.into_iter()</code>,
当你需要改变迭代对象的元素时用 <code>.iter_mut()</code>;</p>
<h3 id="phantom-数据不仅仅用以处理指向类型的原始指针"><a class="header" href="#phantom-数据不仅仅用以处理指向类型的原始指针">Phantom 数据不仅仅用以处理指向类型的原始指针</a></h3>
<p>当你第一次遇到 Phantom data/幻数据时,
一定感觉很奇怪,但是, 很快就会成为一种告诉编译器&quot;拥有&quot;某个值的好方式,
尽管只有一个指向她的原始指针;
例如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Foo&lt;'a, T: 'a&gt; {
    bar: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>这儿告诉编译器 Foo 拥有 T,
尽管只有一个指向她的原始指针;
这对于需要处理原始指针和使用 unsafe Rust 的应用程序很有帮助;</p>
<p>但是, 也可以是一种告诉编译器你的类型还没实现 Send 或是 Sync 特征的方法!
你可以使用 PhantomData 包装以下类型,并在你的结构中使用她们,
来作为一种方式告诉编译器你的结构即不是 Send 也不是 Sync;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type PhantomUnsync = PhantomData&lt;Cell&lt;()&gt;&gt;;
pub type PhantomUnsend = PhantomData&lt;MutexGuard&lt;'static, ()&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="用-rayon-实现并行增量"><a class="header" href="#用-rayon-实现并行增量">用 rayon 实现并行增量</a></h3>
<p>有时, 你希望在遍历集会时并行化工作,
但是, 在处理线程和确保类型可以安全的跨线程发送时却碰壁了;
有时, 如果额外的样板文件令你的代码几乎不可读,那就已经不值得了;</p>
<p>相反, 有一个名为 Rayon 很赞的包, 已经提供了以无缝方式并行化计算的上好工具;
例如,假设我们有一个计算数组平方和的函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>由于乘法和加法的性质, 上述代码绝对可以并行化,
Rayon 通过让我们自动访问数组等集会的&quot;并行迭代器&quot;,
使并行化变得微不足道;
这是几乎零样板的代码;
而且也完全不影响可读性:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Importing rayon prelude is what gives us access to .par_iter on arrays.
use rayon::prelude::*;

fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    // We can use par_iter on our array to let rayon
    // handle the parallelization and reconciliation of
    // results at the end.
    input.par_iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>工程中如果自己要构造各种内部库,
也值得给出这种使用界面,
和以往使用内置库的代码完全兼容,
只是在关键节点处替换为自己魔改/加强过的...
)</p>
<h3 id="开发-rust-库时理解-拓展特征-的概念"><a class="header" href="#开发-rust-库时理解-拓展特征-的概念">开发 Rust 库时理解 拓展特征 的概念</a></h3>
<p>那么 Rayon 是如何以如此干净的方式完成上述工作的呢?
答案在于&quot;拓展特征&quot;,
这些特征可以定义为对其它特征的拓展,
例如 Iterator;
也就是说,我们可以逈通常实现 Itertor 特征的项追加其它有用的函数,
但是, 她们只有在特性范畴以内时才可用,
比如通过将其导入文件中;</p>
<p>这种方式非常好,因为,这些特征只有在你在项目中导入拓展特征时才可用,
并提供了一种使用干净的 API 拓展通用集合和类型的好方法,
开发者可以像使用普通 API 一样轻松的使用这些 API;
由于 Rayon 的拓展特征,
使用并行迭代器就像在 Rust 中使用普通迭代器一样简单;</p>
<p>事实上,这有一个信息量很大的演讲,解释了如何使用 拓展特征 来开发一个在迭代器上提供进度条的库;</p>
<p>(<code>是也乎</code>:</p>
<p><a href="https://www.youtube.com/watch?v=bnnacleqg6k">&quot;Type-Driven API Design in Rust&quot; by Will Crichton - YouTube</a></p>
<p>配套看看 Rayon 官方对自己实现原理的嗯哼: <a href="https://github.com/rayon-rs/rayon/tree/master/src/iter/plumbing">rayon/src/iter/plumbing at master · rayon-rs/rayon</a>
以及专门的解析文章: <a href="https://developers.redhat.com/articles/2023/01/30/run-app-under-openshift-service-mesh">How Rust supports Rayon's data parallelism | Red Hat Developer</a></p>
<p>大约可以感受到 Rust 世界的任性了...
)</p>
<h3 id="拥抱-option-和-result-类型的一元性"><a class="header" href="#拥抱-option-和-result-类型的一元性">拥抱 Option 和 Result 类型的一元性</a></h3>
<p>使用 Option 和 Result 之后,
人们会很快看到<code>.unwrap()</code> 将值从她们移出,
如果 Option 和 Result 是共享引用(比如 struct)的一部分,
就将导致失败;
然而,有时我们想要的只是断言 Option 匹配内部的值或获取对其内部的引用;
有很多方法可以作到这点,
但是, 还有一种方式能不用离开 Option 领域:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_five(x: Option&lt;i32&gt;) -&gt; bool {
    // Contains can just check if the Option has what we want.
    x.contains(&amp;5)
}
<span class="boring">}
</span></code></pre></pre>
<p>另一个示例是我们想要用 None 值替换 Option 内数据,
也就是和某些结构交互时;
我们可以用指令式编程的方式来编写,
并按照以下方式详细完成:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    data: Option&lt;T&gt;,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    // Takes the value of data and leaves None in its place.
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.data.is_none() {
            return None;
        }
        let value = self.data.unwrap();
        self.data = None;
        value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然而, Option 有一些非常酷的属性,
因为, 她们的基本性质是定义了有用的方法,
可以让我们的生源更加轻松;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Takes the value of data and leaves None in its place.
fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.data.take()
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 中的 Option 以函数式编程语言中相同的范例为模型,
属于更广泛的数据类型类别, 称为 Monad;
不用深入理解 Monad 是什么, 而嘦将其视为数据的包装器,
我们可以在不需要从中取出东西的情况下对其进行操作;
比如, 想象一个将两个 Option 内部值相加并返回一个 Option 的函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if x.is_none() || y.is_none() {
        return None;
    }
    return Some(x.unwrap() + y.unwrap());
}
<span class="boring">}
</span></code></pre></pre>
<p>上述代码看起来有点点笨拙,因为,需要执行 none 检验,
而且我们必须从两个 Option 中提取值并从中构建一个新 Option 就很囧;
然而, 由于 Option 的特殊属性,
我们可以作的更好!
这是我们可以获得的:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    x.zip(y).map(|(a, b)| a+b)
}
<span class="boring">}
</span></code></pre></pre>
<p>可以对 option 使用 zip 和 map ,
就像我们可以处理数组和向量一样;
此属性也存在于 Result 类型中,
甚至存在于诸如 <code>Future</code> 类型之类事物中;
如果你对为什么这么作感到好奇,
请继续挖掘 Monad 的更多信息 -&gt; <a href="https://stackoverflow.com/questions/2704652/monad-in-plain-english-for-the-oop-programmer-with-no-fp-background">functional programming - Monad in plain English? (For the OOP programmer with no FP background) - Stack Overflow</a></p>
<p>接受 Option 和 Result 类型的一元性质,
不要到处使用 unwrap 和 if x.is_none() {} else ;
本身就包含了很多有用的方法,
你可以在标准库中阅读这些方法;</p>
<p>(<code>是也乎:</code></p>
<p>所以, 标准库的通读是一个基本功了,
不过, 相比 Python 等其它语言的官方文档,
docs.rs 实在太麻了点儿,还要习惯一下;</p>
<p>)</p>
<h3 id="了解-drop-应该如何针对不同数据结构实现"><a class="header" href="#了解-drop-应该如何针对不同数据结构实现">了解 Drop 应该如何针对不同数据结构实现</a></h3>
<p>标准库将 Drop 特性描述为:</p>
<p>当不再需要某个值时, Rust 将对该值运行&quot;析构函数&quot;;
不再需要某个值最常见方式是超出作用域;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中编写数据结构时, Drop 是至关重要的;
人们必须有一种合理的方法来处理一旦不再需要内存时如何丢弃(安全的);
使用引用计数类型可以报时你克服这些障碍,
但是, 这并不总是足够的;
例如,编写自定义链表或是编写使用通道的结构时,通常要实现自定义版本的 Drop;
当你看到标准库实际如何执行时,
实现 Drop 比并看起来容易的多:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// That's it!
fn drop&lt;T&gt;(t: T) {}
<span class="boring">}
</span></code></pre></pre>
<p>巧妙利用失去作用域时销毁的规则,
<code>std::mem::drop</code> 有一个空函数体!</p>
<p>这是一个技巧, 你可以在自己的自定义 Drop 实现中使用,
嘦你涵盖所有基类?即可;</p>
<h3 id="真的对借用检查员很气-那就用不可变数据结构"><a class="header" href="#真的对借用检查员很气-那就用不可变数据结构">真的对借用检查员很气? 那就用不可变数据结构</a></h3>
<p>函数式程序员喜欢说全局的/可变的状态是万恶之源,
如果可以避免,那毛还要使用呢?
多亏了 Rust 的函数式结构,
我们才能构建从一开始就不可能突变的结构结构!
当你需要编写类似在 Haskell/OCaml 或其它语言中看到的纯粹函数式代码时,
这尤其有用;</p>
<p>通过链接列表综合教程中的示例,
我们可以看到如何构建一个不可变列表,其中节点有引用计数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }
    ...
<span class="boring">}
</span></code></pre></pre>
<p>这就很赞,因为,其行为类似于函数式数据结构,
在函数式数据结构中,
人们不会通过追加前缀来修改列表,
而是通过以新元素作为其头部和现有列表作为尾部来构建列表完成新构建;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    [head] ++ tail
<span class="boring">}
</span></code></pre></pre>
<p>请注意,上述方法都不需要 mut, 因为,我们的数据结构是不可变的!
这在内存上也是非常高效的,因为,该结构是引用计数的,
这意味着如果此数据结构上有多个调用者,
我们不会浪费不必要的资源来复制节点的底层内存;</p>
<p>Rust 中的纯函数代码很简洁,
但是,多数时候,需要尾递归来了把用我快这种方式实现的高性能代码；
而且，要小心，毕竟 Rust 编译器不保证尾调用优化；
值得进一步挖掘更多信息 -&gt; <a href="https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust">When is tail recursion guaranteed in Rust? - Stack Overflow</a></p>
<p>(<code>是也乎:</code></p>
<p>这就尴尬了, 只是个看起来很美的思路,
毕竟 Rust 不是纯函数语言,
递归并不是第一公民;</p>
<p>所以, 这种场景中,还是老实和 借用管理员 好好商量吧...</p>
<p>)</p>
<h3 id="traits-篮有助减少重复"><a class="header" href="#traits-篮有助减少重复">traits 篮有助减少重复</a></h3>
<p>有时,可能希望通过很多不同的特征来约束泛型参数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T: Copy + Clone + Ord + Bar + Baz + Nyan&gt; {
    vals: Vec&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>但是,一旦你开始编写 impl 语句,
或是当你有多个通用参数时,
这很快就会失控;
相反你可溶性定义一个整体特征, 使代码更加 DRY;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Fooer: Copy + Clone + Ord + Bar + Baz + Nyan {}

struct Foo&lt;F: Fooer&gt; {
    vals: Vec&lt;F&gt;,
}

impl&lt;F: Fooer&gt; Foo&lt;F&gt; { ... }
<span class="boring">}
</span></code></pre></pre>
<p>traits 篮可以帮助减少重复，
但是，不要让其变得过大；
在很多情况中，
让一个类型需要如此多的约束可能会产生坏味道,
因为,你创建的抽象太大了;
相反,如果你发现约束无缘无故的变得太大,
请传入具体类型;
然而,某些应用和远又可能受益于 blanket traits/特征篮,
例如旨在提供尽可能通用的 API 库;</p>
<h3 id="match-语句本质上很灵活和结构化的"><a class="header" href="#match-语句本质上很灵活和结构化的">Match 语句本质上很灵活和结构化的</a></h3>
<p>例如,可以将值作为元组组合在一起并执行以下操作,而不是嵌套匹配语句:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player_outcome(player: &amp;Move, opp: &amp;Move) -&gt; Outcome {
    use Move::*;
    use Outcome::*;
    match (player, opp) {
        // Rock moves.
        (Rock, Rock) =&gt; Draw,
        (Rock, Paper) =&gt; Lose,
        (Rock, Scissors) =&gt; Win,
        // Paper moves.
        (Paper, Rock) =&gt; Win,
        (Paper, Paper) =&gt; Draw,
        (Paper, Scissors) =&gt; Lose,
        // Scissor moves.
        (Scissors, Rock) =&gt; Lose,
        (Scissors, Paper) =&gt; Win,
        (Scissors, Scissors) =&gt; Draw,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个示例足以说明为什么模型匹配比指令式语言中的 switch 语句更强大,
而且, 在劳模内部值方面可以作的更多.</p>
<h3 id="如果匹配对象是有限且已知的嫑使用-_--子句"><a class="header" href="#如果匹配对象是有限且已知的嫑使用-_--子句">如果匹配对象是有限且已知的,嫑使用 _ =&gt; 子句</a></h3>
<p>例如,我们有个枚举:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
    Nyan,
    Zab,
    Azb,
    Bza,
}
<span class="boring">}
</span></code></pre></pre>
<p>在编写 match 语句时,如果可能的话, 应该匹配枚举的所有类型,而不是求助于 catch-all 子句:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match f {
    Bar =&gt; { ... },
    Baz =&gt; { ... },
    Nyan =&gt; { ... },
    Zab =&gt; { ... },
    Azb =&gt; { ... },
    Bza =&gt; { ... },
}
<span class="boring">}
</span></code></pre></pre>
<p>这对代码维护非常有帮助,因为,如果枚举的原始编写者逈其追加更多变体,
如果我们忘记在匹配语句中处理新变体, 功能将无法编译;</p>
<h3 id="match-保护条款也很强大"><a class="header" href="#match-保护条款也很强大">Match 保护条款也很强大</a></h3>
<p>当你有未知或是可能无限数量的匹配项时(例如数字范围),
匹配守卫就很棒;
然而, 如果你的范围不能被守卫完全包含时,
将迫使你使用一个包罗万象的 <code>_ =&gt;</code>,
这在编写可维护代码时可能就是一个缺点;</p>
<p>Rust 书中典型示例如下:</p>
<pre><pre class="playground"><code class="language-rust">enum Temperature {
    Celsius(i32),
    Fahrenheit(i32),
}

fn main() {
    let temperature = Temperature::Celsius(35);
    match temperature {
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        Temperature::Celsius(t) =&gt; println!(&quot;{}C is below 30 Celsius&quot;, t),
        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
    }
}
</code></pre></pre>
<h3 id="需要搞乱原始汇编嘛-有一个宏"><a class="header" href="#需要搞乱原始汇编嘛-有一个宏">需要搞乱原始汇编嘛? 有一个宏!</a></h3>
<p>core asm 提供了一个闳, 可以让你在 Rust 中编写内联汇编语句,
这在折腾一些花哨的事情时很有帮助,
比如直接拦截 CPU 的堆栈,
或是想要实现高级优化;</p>
<p>这是一个示例,我们使用内联汇编通过简单的将堆栈指针移动到用来欺骗处理器的堆栈来执行我们的函数!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::arch::asm;

const MAX_DEPTH: isize = 48;
const STACK_SIZE: usize = 1024 * 1024 * 2;

#[derive(Debug, Default)]
#[repr(C)]
struct StackContext {
    rsp: u64,
}

fn nyan() -&gt; ! {
    println!(&quot;nyan nyan nyan&quot;);
    loop {}
}

pub fn move_to_nyan() {
    let mut ctx = StackContext::default();
    let mut stack = vec![0u8; MAX as usize];
    unsafe {
        let stack_bottom = stack.as_mut_ptr().offset(MAX_DEPTH);
        let aligned = (stack_bottom as usize &amp; !15) as *mut u8;
        std::ptr::write(aligned.offset(-16) as *mut u64, nyan as u64);
        ctx.rsp = aligned.offset(-16) as u64;
        switch_stack_to_fn(&amp;mut ctx);
    }
}

unsafe fn switch_stack_to_fn(new: *const StackContext) {
    asm!(
        &quot;mov rsp, [{0} + 0x00]&quot;,
        &quot;ret&quot;,
        in(reg) new,
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>所以说, 无法嵌入内联 汇编代码 的语言, 都不算系统语言?</p>
<p>等等, Python 好象也可以哪...
)</p>
<h3 id="使用-criterion-对代码及其吞吐量进行基准测试"><a class="header" href="#使用-criterion-对代码及其吞吐量进行基准测试">使用 Criterion 对代码及其吞吐量进行基准测试</a></h3>
<p>用来对 Rust 代码进行基准测试的 Criterion 是一项了不起的工程作品;
能帮助你使用图形/回归分析和其它奇怪的工具来访问令人敬畏的基准测试功能;
甚至可以用来衡量函数的不同维度,例如时间和吞吐量;
又比如, 我们可以看到在不同的直方图中,使用标准库的迭代器方法构造/获取和收集原始字节的速度有多快;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter;

use criterion::BenchmarkId;
use criterion::Criterion;
use criterion::Throughput;
use criterion::{criterion_group, criterion_main};

fn from_elem(c: &amp;mut Criterion) {
    static KB: usize = 1024;

    let mut group = c.benchmark_group(&quot;from_elem&quot;);
    for size in [KB, 2 * KB, 4 * KB, 8 * KB, 16 * KB].iter() {
        group.throughput(Throughput::Bytes(*size as u64));
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &amp;size| {
            b.iter(|| iter::repeat(0u8).take(size).collect::&lt;Vec&lt;_&gt;&gt;());
        });
    }
    group.finish();
}

criterion_group!(benches, from_elem);
criterion_main!(benches);
<span class="boring">}
</span></code></pre></pre>
<p>将以下条目追加到项目的 Cargo,toml 文件中,
就可以用 cargo bench 运行了:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.3&quot;

[[bench]]
name = &quot;BENCH_NAME&quot;
harness = false
</code></pre>
<p>criterion 不仅可以向你展示非常棒的图表和描述性信息,
而且,还能记住基准测试运行的先前结果,
告诉你性能回归状态;
在这种情况中,我在运行基准测试的同时, 还能用计算机作很多其它事儿,
所以, 也能自然的通报从上次测量后退化了多少;
总之,非常的COOL!</p>
<pre><code>    Found 11 outliers among 100 measurements (11.00%)
      2 (2.00%) low mild
      4 (4.00%) high mild
      5 (5.00%) high severe
    from_elem/8192          time:   [79.816 ns 79.866 ns 79.913 ns]
                            thrpt:  [95.471 GiB/s 95.528 GiB/s 95.587 GiB/s]
                     change:
                            time:   [+7.3168% +7.9223% +8.4362%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-7.7799% -7.3407% -6.8180%]
                            Performance has regressed.
    Found 3 outliers among 100 measurements (3.00%)
      2 (2.00%) high mild
      1 (1.00%) high severe
    from_elem/16384         time:   [107.22 ns 107.28 ns 107.34 ns]
                            thrpt:  [142.15 GiB/s 142.23 GiB/s 142.31 GiB/s]
                     change:
                            time:   [+3.1408% +3.4311% +3.7094%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-3.5767% -3.3173% -3.0451%]
                            Performance has regressed.
</code></pre>
<h3 id="通过阅读标准库来理解关键概念"><a class="header" href="#通过阅读标准库来理解关键概念">通过阅读标准库来理解关键概念!</a></h3>
<p>我喜欢徜徉在标准库中,尤其是 std::rc, std::iter, and std::collections;
以下是我自己从中学习到的一些很赞的技巧:</p>
<ul>
<li>vec 是如何切实实现的</li>
<li>通过 std::cell 和 std::rc 中的不同方法, 实现内部可变性的方式</li>
<li>如何在 std::sync 中实现通道</li>
<li>std::sync::Arc 的魔力</li>
<li>了解 Rust 作者对开发对应库时,如何作出设计决策的详尽解释</li>
</ul>
<p>有希望这篇文章能为进入 Rust 并遇到一些障碍的人们提供可用信息;
期待更多 Rust 内容能推出,
尤其是关键更高级主题的...</p>
<h3 id="shoutout"><a class="header" href="#shoutout">Shoutout</a></h3>
<p>感谢 Offchain Labs 同事 Rachel 和 Lee Bousfield 对这门语言的广泛了解;
他们的一些技巧启发了这篇文章;</p>
<h2 id="refer-4"><a class="header" href="#refer-4">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/">Rust Bug Minimization Patterns - The {pnk}f(eli)x Blog</a></li>
<li><a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></li>
<li><a href="https://github.com/sger/RustBooks#advanced-books">sger/RustBooks: List of Rust books</a>
<ul>
<li><a href="https://veykril.github.io/tlborm/decl-macros/macros2.html">Macros 2.0 - The Little Book of Rust Macros</a></li>
<li>...</li>
</ul>
</li>
</ul>
<h2 id="logging-4"><a class="header" href="#logging-4">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230120 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧"><a class="header" href="#技巧">技巧</a></h1>
<blockquote>
<p>tips...重要也不重要</p>
</blockquote>
<h2 id="background-3"><a class="header" href="#background-3">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>刚刚开始感觉哪儿哪儿都要有技巧, 其实不一定...</p>
<h2 id="goal-3"><a class="header" href="#goal-3">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>将一头合格 Rustaceans 值得记忆的基本技巧,
收集到 42% 左右...</p>
<h2 id="trace-3"><a class="header" href="#trace-3">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>???</p>
<h2 id="refer-5"><a class="header" href="#refer-5">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-5"><a class="header" href="#logging-5">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-运算符重载六件趣事"><a class="header" href="#rust-运算符重载六件趣事">Rust 运算符重载六件趣事</a></h1>
<p>原文: <a href="https://wishawa.github.io/posts/fun-rust-operators/">Six fun things to do with Rust operator overloading | Wisha Wanichwecharungruang</a></p>
<p><img src="https://wishawa.github.io/posts/fun-rust-operators/dot-product-pooh.jpg" alt="dot-product-pooh" /></p>
<h2 id="快译-1"><a class="header" href="#快译-1">快译</a></h2>
<h3 id="c-输入出"><a class="header" href="#c-输入出">C++ 输入/出</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stdin().read_line(&amp;mut buffer).unwrap();
println!(&quot;Hello I am {name}!!!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>可以重载 cin 和 count 上的移位运算符来达成:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cin &gt;&gt; &amp;mut buffer;
cout &lt;&lt; &quot;Hello I am &quot; &lt;&lt; name &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;
<span class="boring">}
</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>看起来意义更加不明了了?
)</p>
<h3 id="可变函数"><a class="header" href="#可变函数">可变函数</a></h3>
<p>想替代</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::cmp::max(x, y);
[w, x, y, z].into_iter().max();
<span class="boring">}
</span></code></pre></pre>
<p>可以搞成:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// max+ is like std::cmp::max but better
// it supports &gt;2 arguments
max+(x, y);
max+(w, x, y, z);
<span class="boring">}
</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>内置标准库太丰富了...简直必须要有一个信仰过程</p>
<p>)</p>
<h3 id="更简洁的构建器"><a class="header" href="#更简洁的构建器">更简洁的构建器</a></h3>
<p>这是一个更严重的问题;
构建器模式有时涉及大量重复的方法调用;
以 warp web 框架的这种用法为例:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
    .and(warp::path::param())
    .and(warp::header(&quot;user-agent&quot;))
    .map(|param: String, agent: String| {
        format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
    });
<span class="boring">}
</span></code></pre></pre>
<p>如果 API 看起来像这样呢?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
	+	warp::path::param()
	+	warp::header(&quot;user-agent&quot;)
	&gt;&gt;	|param: String, agent: String| {
			format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
		};
<span class="boring">}
</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>等等, 这就是语法糖了吧?
)</p>
<h3 id="中缀函数"><a class="header" href="#中缀函数">中缀函数</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.pow(y);
dot_product(a, b);
a.cross(b.cross(c).cross(d))
<span class="boring">}
</span></code></pre></pre>
<p>我们可以这么来:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x ^pow^ y;
a *dot* b;
a *cross* (b *cross* c *cross* d);
<span class="boring">}
</span></code></pre></pre>
<p>很多人就想要这个!</p>
<p>(<code>是也乎:</code></p>
<p>嗯哼? 的确流畅很多哪...
)</p>
<h3 id="doublefish"><a class="header" href="#doublefish">Doublefish</a></h3>
<p>std::mem 提供有这些功能:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val(&amp;value);
<span class="boring">}
</span></code></pre></pre>
<p>Turbofish 爱好者会喜欢 size_of,
但是对 size_of_val 没什么感觉;
所以, 我们可以自行改造出新版本的 size_of_val ,
看起来更象 turbofishy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val&lt;&lt;&amp;value&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<h3 id="join-和-race"><a class="header" href="#join-和-race">Join 和 Race</a></h3>
<p>特性组合器可能具有短路行为能力;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// quit if any of the 3 errors
(fut1, fut2, fut3).try_join().await;

// quit if any of the 3 succeeds
(fut4, fut5, fut6).race_ok().await;
<span class="boring">}
</span></code></pre></pre>
<p>可以通过 &amp; 和 | 在形式上表达出这点:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(TryJoin &gt;&gt; fut1 &amp; fut2 &amp; fut3).await;
(RaceOk &gt;&gt; fut4 | fut5 | fut6).await;
<span class="boring">}
</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>这是从形式上和语义同步了.
)</p>
<h2 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h2>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/10golkq">Discuss this on Reddit</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=71da59351b0988249a69014e6b191353">Playground</a> containing the implementations behind some of the code shown here</li>
<li><a href="https://doc.rust-lang.org/std/ops/index.html">std::ops docs</a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">Rust operators precedence table</a></li>
</ul>
<h2 id="refer-6"><a class="header" href="#refer-6">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-6"><a class="header" href="#logging-6">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230125 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-和默认参数"><a class="header" href="#rust-和默认参数">Rust 和默认参数</a></h1>
<p>原文: <a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></p>
<blockquote>
<p>快译</p>
</blockquote>
<p>Rust 不支持函数声明中的默认参数;
而且和很多语言不同, 无法通过函数重载来模拟;
这让很多来自其它编程语言的 Rustacean 新人感到沮丧,
所以, 就想解释一下为什么这其实是件好事儿,
以及,如果使用默认 trait 和结构更新语法来实现类似的效果;</p>
<p>默认参数(和函数重载)不是面向对象编程的一部分,
但是,又是许多 Rustaceans 新人原先编程语言的共同特征;
因此, 这篇文章在某些方面和我正在进行的关于 Rust 如何不是面向对象的系列文章相吻合,
故而, 被标准为这个系列的文章;
还受到 Reddit 中对我第一篇 OOP 相关贴子回复的启发;</p>
<h2 id="默认秋粮是如何工作咯比如-c"><a class="header" href="#默认秋粮是如何工作咯比如-c">默认秋粮是如何工作咯(比如 C++)</a></h2>
<p>在开始讨论为什么 Rust 没有默认参数以及我们可以折腾什么之前,
得先聊明白什么是默认参数以及在哪些情况下有用;</p>
<p>假设你有一个带有很多参数的函数,
比如(以 Reddit 回复中的示例)在 GUI 中创建一个窗口:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible)

auto handle = createWindow(10, 30, false); // Create invisible window
auto handle2 = createWindow(100, 500, true); // Create visible window
</code></pre>
<p>现在, 假设你准备创建的大多数窗口都是可见的,
并且,你不想让程序员负担必须指定窗口是否可见的担心 --- 甚至于不想明确的考虑这事儿 --- 在正常情况下,
在支持默认参数的编程语言中,你可以为可见性提供默认值:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true)

auto handle = createWindow(10, 30, false); // Create invisible window!

auto handle2 = createWindow(100, 500, true); // Create visible window!

auto handle3 = createWindow(100, 500); // Also create visible window!
auto handle4 = createWindow(100, 500); // Most of the time, that's what
auto handle5 = createWindow(100, 500); // you want, so why have to say it?
Default parameters can also be simulated with function overloading for programming languages where function overloading is available but default parameters are not:

WindowHandle createWindow(int width, int height, bool visible);

WindowHandle createWindow(int width, int height) {
    return createWindow(width, height, true);
}
</code></pre>
<p>Rust 也没有函数重载,这是个复杂的多的问题,
但是, 很多相同的论点都适用这个习惯用法的理解;</p>
<h2 id="benefits-and-detriments-of-default-parameters"><a class="header" href="#benefits-and-detriments-of-default-parameters">Benefits (and Detriments) of Default Parameters</a></h2>
<p>Defaults are good, and default parameters in this style are one way to implement them and reap their benefits.</p>
<p>Defaults are good because they uphold the DRY principle – Don’t Repeat Yourself. If we didn’t have defaults, we’d have to repeat parameters that don’t actually contribute to understanding of the goals of the code. And if the best default parameters changed in such a way that the best way to update the code was to continue using the default – perhaps because of a change of best practices – we’d have to update every call rather than just changing it once, where the default parameter is defined.</p>
<p>Defaults are also good because they decrease the programmer’s cognitive load. Programmers have to keep a lot of information in their brain at a time, and defaults help programmers by not forcing them to think about extra details when they don’t matter – which is the usual situation for most defaults.</p>
<p>Default parameters also make the code more concise, and are popular for that reason. But this isn’t a particular value that I have. I believe the DRY principle is important, and that often amounts to more concise code, but given modern editors and IDE, and modern expectations of typing and reading speed, a moderate amount of verbosity in exchange for other benefits (such as clarity and explicitness) is completely acceptable to me. I believe that default parameters, as they are implemented in C++ and Python, have a substantial cost in clarity and explicitness, and therefore conciseness isn’t a good enough reason to justify them.</p>
<p>In this case, what particularly bothers me about the lack of clarity is that the reader of the code doesn’t know that there are potentially more parameters; there is no hint that there might be other parameters. If a maintenance programmer wants to change one of these calls to make invisible windows instead, they might not realize they should check the documentation for create_window: after all, it only seems to take two parameters, and neither of them have anything remotely to do with invisible windows.</p>
<p>Fortunately, Rust has alternative features that allow us to reap the benefits for cognitive load and DRY without sacrificing explicitness and clarity.</p>
<h2 id="defaults-in-rust-the-default-trait"><a class="header" href="#defaults-in-rust-the-default-trait">Defaults in Rust: the Default trait</a></h2>
<p>Rather than allowing default parameters, Rust allows you to optionally specify default values for your types using the Default trait. Here’s how it works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
}

impl Default for Foo {
    fn default() -&gt; Self {
        Foo::Bar
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Or, written using the more concise derive syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum Foo {
    #[default]
    Bar,

    Baz,
}
<span class="boring">}
</span></code></pre></pre>
<p>Once this default is defined, Foo::default() or even (in a context where the type is clear) Default::default() can stand in for Foo::Bar.</p>
<p>If you are used to re-using existing types for your function parameters, this might seem worse than useless. After all, the parameter we defaulted was of type bool, and the orphan rule (explained in the Rust book’s chapter on traits) forbids us from defining the Default trait on bool – as I alluded to above, Default allows you to define default values for your types. And even if we could, setting a default on booleans is way too overpowered a thing to do just to give this one function parameter have a default! After all, some other function might also have a boolean parameter with a different default.</p>
<p>But this makes more sense if you consider that in Rust, it is common – even idiomatic and preferred – to create custom types for things like configuration and function parameters. After all, if you’re not looking at the documentation, it can be unclear what true means. It’s not even clear that it has anything to do with visibility, let alone that true means that the window is to be visible when the parameter could just as easily be called invisible.</p>
<p>In Rust, we would prefer to define a new type for this situation, an enum listing the visibility options – which will also help if a new visibility option is created. And on this enum, it would be reasonable to declare a default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum WindowVisibility {
    #[default]
    Visible,

    Invisible,
}
<span class="boring">}
</span></code></pre></pre>
<p>Yes, this is more verbosity, but it is more clear, and no less DRY, than our original code. Conciseness is again not a value in and of itself. Explicitly listing the options is preferred to leaving them implicit.</p>
<p>Then, when we call the function, we can use this default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_window(width: u32, height: u32, visibility: WindowVisibility) -&gt; WindowHandle;

let handle = create_window(10, 30, WindowVisibility::Invisible);
let handle2 = create_window(100, 500, WindowVisibility::Visible);

let handle3 = create_window(100, 500, WindowVisibility::default());
let handle4 = create_window(100, 500, WindowVisibility::default());
let handle5 = create_window(100, 500, Default::default()); // Also permitted
<span class="boring">}
</span></code></pre></pre>
<p>This is, as promised, more verbose, but equally DRY, and much more explicit and clear.</p>
<p>NB: I’m using free-standing functions for example purposes only. In reality, this particular function is just as likely to be part of a type’s intrinsic methods, something like WindowHandle::new or WindowHandle::create_window.</p>
<h3 id="scaling-defaults-in-rust-struct-update-syntax"><a class="header" href="#scaling-defaults-in-rust-struct-update-syntax">Scaling defaults in Rust: Struct update syntax</a></h3>
<p>So this is all well and good for one default. But it doesn’t scale that well. What if we want to add another 3 parameters to our window creation function? In a language like C++, we can give them defaults, and the callers don’t even need to be updated (parameters are for example purposes only and do not represent a well-thought out list of what you might want to specify in creating a window):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WindowHandle createWindow(int width, int height, bool visible = true,
                          WindowStyle windowStyle = WindowStyle::Standard,
                          int z_position = -1,
                          bool autoclose = false);

createWindow(100, 500); // Still works identically
createWindow(100, 500, false); // Also still works
createWindow(100, 500, false, WindowStyle::Standard, 2, true); // Specify everything
<span class="boring">}
</span></code></pre></pre>
<p>This is a useful feature. In Rust, with the techniques we’ve discussed so far, we’d have to write Default::default() repeatedly for however many parameters there are. This is a DRY violation, and interferes with the ability to add new parameters.</p>
<p>There is a flaw with this feature, however. You’ve now constrained yourself to specifying parameters to the left in order to specify parameters on the right. In the last example call to createWindow, we violate DRY by explicitly specifying a value when we probably wanted to use the default, but that wasn’t available because we wanted to override the default for a later parameter.</p>
<p>Fortunately, Rust has a version of this too. Just as we created an enum just for the purposes of this function call, it is idiomatic in Rust to create structures for configuration parameters like this. The structure would look something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowConfig {
    pub width: u32,
    pub height: u32,
    pub visibility: WindowVisibility,
    pub window_style: WindowStyle,
    pub z_position: i32,
    pub autoclose: AutoclosePolicy,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, we can implement Default for that entire struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for WindowConfig {
    fn default() -&gt; Self {
        Self {
            width: 100,
            height: 100,
            visibility: WindowVisibility::Visible,
            window_style: WindowStyle::Standard,
            z_position: -1,
            autoclose: AutoclosePolicy::Disable,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, this might seem to be extremely tedious to use. You might imagine using it something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = WindowConfig::default();
config.width = 500;
config.z_position = 2;
config.autoclose = AutoclosePolicy::Enable;
let handle = create_window(config);
<span class="boring">}
</span></code></pre></pre>
<p>I would argue that even this is preferable to default parameters, because again, it is explicit. However, Rust has a syntactic construct designed exactly for situations like this, struct update syntax. With it, we get something very similar to default parameters, but a little more verbose, a lot more explicit, and a lot more flexible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = create_window(WindowConfig {
    width: 500,
    z_position: 2,
    autoclose: AutoclosePolicy::Enable,
    ..Default::default()
});
<span class="boring">}
</span></code></pre></pre>
<p>Unlike C++-style default parameters, we can override exactly the defaults we want to. It is also explicitly clear that there are other parameters we could modify if we wanted to, without forcing the maintenance programmer to check the documentation.</p>
<p>But beyond that, this allows there to be other sets of defaults defined. In addition to WindowConfig::default, there might be another set of configuration parameters for creating dialog boxes, like WindowConfig::dialog() or WindowConfig::default_dialog. An app where the programmer usually creates invisible windows, or windows all of the same height, might define its own default set, config::app_local_default_window_config(). These wouldn’t be mediated through the Default trait, but Default is just a trait, and Default::default() is just a method call. You can call your own methods instead, and still use this struct update syntax.</p>
<p>So now, we have a system of idioms in Rust to replace default parameters. It’s just as DRY, and decreases the cognitive load just as much. More importantly, it does so without sacrificing explicitness and clarity as to exactly what’s going on – a given function always takes the same number of parameters, which is an invariant that Rust maintenance programmers can (and do) rely on.</p>
<h3 id="the-builder-pattern"><a class="header" href="#the-builder-pattern">The Builder Pattern</a></h3>
<p>At this point, the old-hand Rustaceans in the audience will note that I haven’t discussed one common Rust approach to designing these configuration structs, the builder pattern.</p>
<p>That’s for a reason: I don’t like it. I personally prefer to use Default and struct update syntax where others might reach for the builder pattern. I think it’s less explicit, and since I have a lot of experience in non-OOP programming languages, it feels to me like a solution without a problem, the primary upshot of which is to make the code look more object-oriented.</p>
<p>But it is a commonly used pattern in Rust, and you will use crates that use the builder pattern, so it’s worth being familiar with it. It’s the same concept as before: using a struct full of parameters to send configuration to a constructor or to a function call. It’s probably going to be called something like WindowBuilder instead of WindowConfig.</p>
<p>However, instead of using the struct update syntax directly, a bunch of helper methods are added to do the struct update:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Or, as I would notate it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(self, height: u32) -&gt; Self {
        Self {
            height,
            ..self
        }
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Sometimes, enumerations are split into multiple update methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn autoclose_enable(mut self) -&gt; Self {
        self
        self.autoclose = AutoclosePolicy::Enable;
    }

    fn autoclose_disable(mut self) -&gt; Self {
        self.autoclose = AutoclosePolicy::Disable;
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, normally, instead of calling e.g. the window constructor, you call a build method defined on the builder (and at this point I cringe at the gratuitous OOP philosophy influencing the design):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn build(self) {
        window_create(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, instead of using struct update syntax, you chain together calls to these methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = WindowBuilder::new()
    .width(500)
    .z_position(2)
    .autoclose_enable()
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>I still prefer this to default parameters, but I also find it tacky. I don’t like being forced to think in terms of abstract “objects” like builders, and I don’t like the presumption that this style is more intuitive. Why is a “builder” an object that does something? Why is that prefered to a structure that is “configuration”? Are OOP programmers aware that in real life, the vast majority of objects literally don’t do things, and certainly don’t build other objects?</p>
<p>But for people familiar with the idioms of object-oriented programming, this might be preferable. It is a commonly chosen option, so it’s important at least to recognize it.</p>
<h2 id="conclusion-and-application"><a class="header" href="#conclusion-and-application">Conclusion and Application</a></h2>
<p>Rust has a lot of idioms that are different from those in other programming languages. I often see proposals from new Rustaceans to add default parameters – and other similar features – to Rust, and these new Rustaceans are confused that the strong demand they feel is not as widely felt in the greater Rust community.</p>
<p>And normally, it’s similar to this situation with default parameters. There are alternative idioms that accomplish the same goals, to the extent that those goals are in line with Rust’s values: in this case, DRYness, and reducing developers' cognitive loads. They are also better solutions in some other ways, according to Rusty values: the additional explicitness is worth a little more verbosity.</p>
<p>But often, the new Rustaceans making these proposals are unaware of the Rusty way of doing things. And if they are aware of it, they are approaching it from the goals of other programming languages, and don’t see how the solution measures up.</p>
<p>So I hope this can serve as a case study to help people understand that there often are Rusty ways of accomplishing the goals of popular features from OOP land, and why Rustaceans prefer these solutions to blind accumulation of features.</p>
<h2 id="logging-7"><a class="header" href="#logging-7">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230212 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学习"><a class="header" href="#学习">学习</a></h1>
<blockquote>
<p>learnning ...</p>
</blockquote>
<h2 id="background-4"><a class="header" href="#background-4">background</a></h2>
<blockquote>
<p>可能背景</p>
</blockquote>
<p>和其它语言不同, Rust 有太多公开的秘密,如果不能快速先习惯一批,
很难写出可以运行的软件来...</p>
<h2 id="goal-4"><a class="header" href="#goal-4">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>最常用的那 20% Rust 常识...</p>
<h2 id="trace-4"><a class="header" href="#trace-4">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<h2 id="refer-7"><a class="header" href="#refer-7">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<h2 id="logging-8"><a class="header" href="#logging-8">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercism"><a class="header" href="#exercism">Exercism</a></h1>
<blockquote>
<p>练习主义</p>
</blockquote>
<h2 id="background-5"><a class="header" href="#background-5">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/about">About Exercism</a></p>
<p>是一个神奇的网站</p>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.30.38.jpg" alt="" /></p>
<p>一是个专注用练习题来学习各种开发语言的网站,
免费,包含越来越多的语言</p>
<h2 id="goal-5"><a class="header" href="#goal-5">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust">Rust on Exercism</a></p>
<p>至少先刷完这 103 道题目, 然后, 再开发具体的实用工具;</p>
<h2 id="trace-5"><a class="header" href="#trace-5">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.31.48.jpg" alt="rust" /></p>
<p>不过最终是乱序来的</p>
<h2 id="refer-8"><a class="header" href="#refer-8">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<p><a href="https://cheats.rs/">Rust Language Cheat Sheet</a></p>
<ul>
<li><a href="https://juejin.cn/post/7146144676532191262">16｜数据结构：Vec<T>、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？ - 掘金</a></li>
<li>...</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a16a825f50d4d34866d432c15fa3ebd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="" /></p>
<h2 id="logging-9"><a class="header" href="#logging-9">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rs42all-your-base"><a class="header" href="#rs42all-your-base">rs42all-your-base</a></h1>
<blockquote>
<p>所有进制</p>
</blockquote>
<h2 id="background-6"><a class="header" href="#background-6">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/docs/tracks/rust">All Your Base in Rust on Exercism</a></p>
<h2 id="logging-10"><a class="header" href="#logging-10">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id="try_fold"><a class="header" href="#try_fold">try_fold()</a></h3>
<blockquote>
<p>表达能力的典范...</p>
</blockquote>
<h2 id="refer-9"><a class="header" href="#refer-9">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Positional_notation#External_links">Positional notation - Wikipedia</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html">Iterator in std::iter - Rust</a>
<ul>
<li><a href="https://qiita.com/lo48576/items/34887794c146042aebf1">Rustのイテレータの網羅的かつ大雑把な紹介 - Qiita</a></li>
<li><a href="https://zenn.dev/megeton/articles/fb6266bcb6aa1b">Ruby脳のためのRust配列系メソッドまとめ</a></li>
<li>...</li>
</ul>
</li>
<li><a href="https://rustcc.cn/article?id=2f4b3a15-7874-4c68-b9d8-5a717e9a3af0">rust新手的一个问题：fold和scan。 - Rust语言中文社区</a>
<ul>
<li><a href="https://juejin.cn/post/7067102952602746910">抛弃Rust的try...catch和null检查 - 掘金</a></li>
<li>...</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ex43allergies"><a class="header" href="#ex43allergies">ex43Allergies</a></h1>
<blockquote>
<p>过敏源</p>
</blockquote>
<h2 id="background-7"><a class="header" href="#background-7">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust/exercises/allergies">Allergies in Rust on Exercism</a></p>
<h2 id="logging-11"><a class="header" href="#logging-11">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id=""><a class="header" href="#">&amp;</a></h3>
<blockquote>
<p>现实世界的 与计算</p>
</blockquote>
<h2 id="refer-10"><a class="header" href="#refer-10">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://hltj.me/lang/2016/11/07/10m-letters.html">由“千万字母表问题”看多范式编程语言 | 灰蓝时光</a>
<ul>
<li><a href="http://www.nct9.ne.jp/m_hiroi/linux/rust14.html">Linux Programming / お気楽 Rust プログラミング超入門</a></li>
</ul>
</li>
<li>...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="笔记"><a class="header" href="#笔记">笔记</a></h1>
<blockquote>
<p>logging</p>
</blockquote>
<h2 id="background-8"><a class="header" href="#background-8">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>任何自学都需要探索+内省, 同时来, 否则, 很容易不知道在折腾什么...</p>
<h2 id="goal-6"><a class="header" href="#goal-6">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li>是谁?</li>
<li>在哪?</li>
<li>去哪?</li>
</ul>
<p>随时嗯哼明白...</p>
<h2 id="trace-6"><a class="header" href="#trace-6">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
基本环境</li>
<li><input disabled="" type="checkbox"/>
基本语法</li>
<li><input disabled="" type="checkbox"/>
基本 std</li>
<li><input disabled="" type="checkbox"/>
基本项目结构</li>
<li><input disabled="" type="checkbox"/>
基本经典工程</li>
<li><input disabled="" type="checkbox"/>
基本...习惯们?</li>
</ul>
<h2 id="refer-11"><a class="header" href="#refer-11">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-12"><a class="header" href="#logging-12">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-丑句法"><a class="header" href="#rust-丑句法">Rust 丑句法</a></h1>
<p>原文: <a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html#Rust-s-Ugly-Syntax">Rust's Ugly Syntax</a></p>
<h2 id="快译-2"><a class="header" href="#快译-2">快译</a></h2>
<p>大家抱怨 Rust 的语法;
不过,俺想大多数时候,
当人们认为在对 Rust 语法有疑问时,
实际上在反抗对应语义;
在这篇有点儿异想天开的文章中,
俺将尝试理清这两点;</p>
<p>先从一个丑陋的语法示例开始:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}
</span></code></pre></pre>
<p>此函数读取给定二进制文件内容;
这是直接从标准库中提取的, 所以, 不算是稻草人式无用示例;
而且,至少对俺来说, 这绝对不算漂亮;</p>
<p>让我们想象一下,如果 Rust 有更好的语法, 这个函数应该是什么样儿;
如果和真正的编程语言有任何相似之处, 无论真假, 纯属试合!</p>
<p>从 Rs++ 开始:</p>
<pre><code class="language-c++">template&lt;std::HasConstReference&lt;std::Path&gt; P&gt;
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
std::read(P path) {
    return read_(path.as_reference());
}

static
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
read_(&amp;auto const std::Path path) {
    auto file = try std::File::open(path);
    std::vector bytes;
    try file.read_to_end(&amp;bytes);
    return okey(bytes);
}
</code></pre>
<p>Rhodes 变体:</p>
<pre><code class="language-ruby">public io.Result&lt;ArrayList&lt;Byte&gt;&gt; read&lt;P extends ReferencingFinal&lt;Path&gt;&gt;(
        P path) {
    return myRead(path.get_final_reference());
}

private io.Result&lt;ArrayList&lt;Byte&gt;&gt; myRead(
        final reference lifetime var Path path) {
    var file = try File.open(path);
    ArrayList&lt;Byte&gt; bytes = ArrayList.new();
    try file.readToEnd(borrow bytes);
    return Success(bytes);
}
</code></pre>
<p>经典 RhodesScript:</p>
<pre><code class="language-js">public function read&lt;P extends IncludingRef&lt;Path&gt;&gt;(
    path: P,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    return myRead(path.included_ref());
}

private function myRead(
    path: &amp;const Path,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    let file = try File.open(path);
    Array&lt;byte&gt; bytes = Array.new()
    try file.readToEnd(&amp;bytes)
    return Ok(bytes);
}
</code></pre>
<p>响尾蛇/Rattlesnake:</p>
<pre><code class="language-python">def read[P: Refing[Path]](path: P): io.Result[List[byte]]:
    def inner(path: @Path): io.Result[List[byte]]:
        file := try File.open(path)
        bytes := List.new()
        try file.read_to_end(@: bytes)
        return Ok(bytes)
    return inner(path.ref)
</code></pre>
<p>以及, CrabML:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>read :: 'p  ref_of =&gt; 'p -&gt; u8 vec io.either.t
let read p =
  let
    inner :: &amp;path -&gt; u8 vec.t io.either.t
    inner p =
      let mut file = try (File.open p) in
      let mut bytes = vec.new () in
      try (file.read_to_end (&amp;mut bytes)); Right bytes
  in
    ref_op p |&gt; inner
;;
<span class="boring">}
</span></code></pre></pre>
<p>作为一个稍微严肃和有用的练习,
让我们作相反的尝试--保留 Rust 语法,
但是, 尝试简化语义直到最终结果, 看会是什么样儿;</p>
<p>这是我们的起点:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}
</span></code></pre></pre>
<p>这时, 最大的噪音源是嵌套函数;
动机有点儿深奥;
外部函数是通用的,而内部不是;
使用编译模式,这意味着外部函数和用户代码一起编译,
而嵌的将优化;
相比之下, 内部函数是在编译 std 本身时编译的,
从而节省了编译用户代码的时间;
简化这一点(损失一些性能)的一种方法,
说是泛型函数总是单独编译,
但是,能在幕后接受一个额外的运行时秋粮, 可以描述物理维度上的输入参数;</p>
<p>这样我们获得:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path.as_ref())?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}
</span></code></pre></pre>
<p>下个噪音元素是 <code>&lt;P: AsRef&lt;Path&gt;&gt;</code> 约束;
这是必需的,因为 Rust 喜欢将内存中字节的物理布局作为接口公开,
特别是对可以带来性能的情况;
特殊的, Path 的含义并不是文件路径的某种抽象,
这里只是字面意义上内存中的一堆连续字节;
所以, 我们需要 AsRef 来将其和任何能够表示这种字节片的抽象一起工作;
但是, 如果我们不关心性能,
就可以要求所有接口都相当抽象,并通过虚函数调用进行调解,
而不是直接访问内存;
那么, 我们就不需要 AsRef 这堆东西了:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}
</span></code></pre></pre>
<p>这样简化后,我们实际上也可以摆脱 <code>Vec&lt;u8&gt;</code> -- 如果我们不再使用泛型来表达语言本身的高效可增长字节数组;
我们必须使用运行时提供的一些不透明字节类型:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Bytes&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Bytes::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}
</span></code></pre></pre>
<p>从技术上讲,我们仍然随身携带所有权和备用系统,
但是,由于无法直接控制类型的内存布局,
就无法带来巨大的性能优势;
仍然有助于避免 GC,防止迭代器失效,
并静态检验非线程安全代码是否实际上没有跨线程使用;
不过, 如果我们只切换到 GC, 我们可以轻松摆脱那些 &amp;指针;
我们甚至于不需要太担心并发性--因为,我们的对象是单独分配的,而且总是在指针后面,
我们可以通过注意到指针大小,
无论是否在 x86 系统上都是原子操作来消除数据竞争;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; io::Result&lt;Bytes&gt; {
  let file = File::open(path)?;
  let bytes = Bytes::new();
  file.read_to_end(bytes)?;
  Ok(bytes)
}
<span class="boring">}
</span></code></pre></pre>
<p>最后,我们在这对错误的处理过于迂腐 -- 我们并仅要关注返回类型失败的可能,
甚至于要用 ? 来突出指示任何可能失败的特定表达式;
完全不考虑错误处理,
让一些顶层处理程序来处理:
(比如: try { } catch (...) { /* intentionally empty */ })</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; Bytes {
  let file = File::open(path);
  let bytes = Bytes::new();
  file.read_to_end(bytes);
  bytes
}
<span class="boring">}
</span></code></pre></pre>
<p>现在是否好多了?</p>
<h2 id="ps"><a class="header" href="#ps">PS:</a></h2>
<p>的确是篇奇想, 这样简化后, 几乎就是 多了一些控制符号的 Python 了,
又或是根本可以视为 TypeScript 了;
当然, 如果有这种低效版 Rust 多数程序员还是愿意使用的;
就象当年 CoffeeScript 的尝试;</p>
<h2 id="logging-13"><a class="header" href="#logging-13">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230206 ZQ init.</li>
</ul>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->


                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">

        </nav>

    </div>




    <script>
        window.playground_copyable = true;
    </script>


    <script src="elasticlunr.min.js" charset="utf-8"></script>
    <script src="mark.min.js" charset="utf-8"></script>
    <script src="searcher.js" charset="utf-8"></script>

    <script src="clipboard.min.js" charset="utf-8"></script>
    <script src="highlight.js" charset="utf-8"></script>
    <script src="book.js" charset="utf-8"></script>

    <!-- Custom JS scripts -->

    <script>
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>

    <hr />

    <p style="text-align:center">

        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议"
                style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
        本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可;-)

    </p>
    <hr />

    <script src="https://utteranc.es/client.js" repo="zhrust/comments" issue-term="pathname" label="✨💬✨"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>

</html>