<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>be Rustaceans</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="如何成为一名合格的 Rustacean ? 肯定有个过程, 这儿记录了私人这个转化过程...">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

</head>

<body>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script>
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item "><a href="abt/index.html"><strong aria-hidden="true">1.</strong> 成为 Rustacean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="abt/gh-pages.html"><strong aria-hidden="true">1.1.</strong> gh-pages</a></li><li class="chapter-item "><a href="abt/zhrust.html"><strong aria-hidden="true">1.2.</strong> zhrust</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><a href="101/index.html"><strong aria-hidden="true">2.</strong> Rust 学习</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="101/tracing.html"><strong aria-hidden="true">2.1.</strong> tracing 初步</a></li><li class="chapter-item "><a href="101/chatgpt101.html"><strong aria-hidden="true">2.2.</strong> 伴学ChatGPT</a></li><li class="chapter-item "><a href="101/exercism.html"><strong aria-hidden="true">2.3.</strong> Exercism</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="101/ex42all-your-base.html"><strong aria-hidden="true">2.3.1.</strong> 42:all-your-base</a></li><li class="chapter-item "><a href="101/ex43Allergies.html"><strong aria-hidden="true">2.3.2.</strong> 43:Allergies</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><a href="dev/index.html"><strong aria-hidden="true">3.</strong> Rust 开发</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/dama-projects.html"><strong aria-hidden="true">3.1.</strong> 小作品</a></li><li class="chapter-item "><a href="dev/20-things-ive-learned-in-my-20-years-as-a-software-engineer.html"><strong aria-hidden="true">3.2.</strong> 20年来作为软件工程师学到的10件事</a></li><li class="chapter-item "><a href="dev/concepts-i-wish-i-learned-earlier.html"><strong aria-hidden="true">3.3.</strong> 希望一早知道的关键概念</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><a href="tip/index.html"><strong aria-hidden="true">4.</strong> Rust 技艺</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tip/rust6fun-operator-overloading.html"><strong aria-hidden="true">4.1.</strong> 运算符重载六件趣事</a></li><li class="chapter-item "><a href="tip/oop-1-encapsulation.html"><strong aria-hidden="true">4.2.</strong> Rust 超越面向对象,第1部分</a></li><li class="chapter-item "><a href="tip/oop-2-polymorphism.html"><strong aria-hidden="true">4.3.</strong> Rust 超越面向对象,第2部分</a></li><li class="chapter-item "><a href="tip/default-params.html"><strong aria-hidden="true">4.4.</strong> OOP:Rust 和默认参数</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><a href="log/index.html"><strong aria-hidden="true">5.</strong> 笔记</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="log/rust-s-ugly-syntax.html"><strong aria-hidden="true">5.1.</strong> Rust 丑句法</a></li><li class="chapter-item "><a href="log/rust101logging.html"><strong aria-hidden="true">5.2.</strong> Rust 课程笔记</a></li><li class="chapter-item "><a href="log/graph-rust-move-copy-borrow.html"><strong aria-hidden="true">5.3.</strong> 图形描述 Rust 中所有权和借用</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">be Rustaceans</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/zhrust/rustacean/tree/main/src" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script>
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="有关如何成为-rustacean"><a class="header" href="#有关如何成为-rustacean">有关&quot;如何成为 Rustacean&quot;...</a></h1>
<blockquote>
<p>as Zoom.Quiet</p>
</blockquote>
<h2 id="background"><a class="header" href="#background">background</a></h2>
<p>自学使用 Python 第21年,
看着 Perl7 消失,
看着 Golang 突然变成 G+,
看着 Rust 突然变成现学,
忍不住了...</p>
<h2 id="goal"><a class="header" href="#goal">goal</a></h2>
<p>充分复用以往各种技术栈的自学经验,
尽可能合理和效率的完成 Pythoneer -&gt; Rustacean 的转化;
或是外挂?</p>
<h2 id="trace"><a class="header" href="#trace">trace</a></h2>
<ul>
<li>...</li>
<li>230225 mdbook 追加 RRS 失败, 不过, 根据其它公开图书项目的配置, 将菜单折叠了...</li>
<li>230101 锈周刊开始连载: <a href="https://weekly.rs.101.so/2023/RR23W1.html#%E6%96%87%E7%AB%A0%E5%97%AF%E5%93%BC">RR23W1 - Weekly for China Rustaceans</a></li>
<li>221111 最终以 rs.101.so ~ 如此基础的 Rust , 域名发布</li>
<li>221022 仓库创建</li>
<li>220918 确定肯定已经明确开始转化进程</li>
</ul>
<h2 id="refer"><a class="header" href="#refer">refer.</a></h2>
<ul>
<li>大妈:
<ul>
<li>主索引: <a href="https://zoomquiet.io/">mapping -&gt; ZoomQuiet.io {by gen4dot2htm.py vv.190718 at:190911 18:07:32,877571}</a></li>
<li>...</li>
</ul>
</li>
</ul>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<ul>
<li>...</li>
<li>221111 ZQ 尝试 .rs 域名失败</li>
<li>221101 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gh-pages"><a class="header" href="#gh-pages">gh-pages</a></h1>
<blockquote>
<p>免费使用的成本</p>
</blockquote>
<h2 id="background-1"><a class="header" href="#background-1">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>凡是可以编译为 静态网站 的, 都可以通过 gh-pages/GitHub-Pages 服务来进行免费发布;</p>
<h2 id="goal-1"><a class="header" href="#goal-1">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
本地编译好, 嘦 git push ,一切就可以自动完成发布</li>
<li><input disabled="" type="checkbox"/>
而且发布到指定域名</li>
</ul>
<h2 id="trace-1"><a class="header" href="#trace-1">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<h2 id="refer-1"><a class="header" href="#refer-1">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages">验证 GitHub Pages 的自定义域 - GitHub Docs</a></li>
</ul>
<h2 id="logging-1"><a class="header" href="#logging-1">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zhrust"><a class="header" href="#zhrust">zhRust</a></h1>
<blockquote>
<p>zn.rust 域名</p>
</blockquote>
<h2 id="background-2"><a class="header" href="#background-2">background</a></h2>
<blockquote>
<p>名正言顺</p>
</blockquote>
<p>Ｒust 发布时间不短了,
rust 相关中文社区比当年 Python 的多不少,
所以, 2022年未很难找到简短好记的域名可以注册了</p>
<h2 id="goal-2"><a class="header" href="#goal-2">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>但是, 总是要有一个 Rust 方向的持续输出域名, 
要求从来不变</p>
<ul>
<li>rust,rustacean 相关</li>
<li>越短越好</li>
<li>越便宜越好</li>
<li>...</li>
</ul>
<h2 id="trace-2"><a class="header" href="#trace-2">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li>原先有 101.camp,101.so 所以尝试 rust.so, 已经没有</li>
<li>又尝试 rustacean.so 还有,只是贵而且又长...</li>
<li>那么 在 namecheap.com 再挖掘一下, 没想到
<ul>
<li>.rust 竟然有这个根域名</li>
<li>立即先注册 cn.rust 以及 china.rust</li>
</ul>
</li>
<li>可惜几天过去 dig 指令依然查不到记录,看来 <code>.rust</code> 还是一个预备根域名,至少中国根还不识别..
<ul>
<li>只能恢复使用 <code>rs.101.so</code> 这个域名</li>
<li>另外将 <code>weekly.rs.101.so</code> 也发布出来开始坚持关注每周社区关键变化...</li>
</ul>
</li>
</ul>
<h2 id="refer-2"><a class="header" href="#refer-2">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-2"><a class="header" href="#logging-2">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230101 ZQ 变更域名指向</li>
<li>221230 ZQ init.
<ul>
<li>迁移 utterances 🔮 评注到 https://github.com/zhrust/comments</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学习"><a class="header" href="#学习">学习</a></h1>
<blockquote>
<p>learnning ...</p>
</blockquote>
<h2 id="background-3"><a class="header" href="#background-3">background</a></h2>
<blockquote>
<p>可能背景</p>
</blockquote>
<p>和其它语言不同, Rust 有太多公开的秘密,如果不能快速先习惯一批,
很难写出可以运行的软件来...</p>
<h2 id="goal-3"><a class="header" href="#goal-3">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>最常用的那 20% Rust 常识...以便解决 80% 应用场景</p>
<h2 id="trace-3"><a class="header" href="#trace-3">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"/>
基本概念
<ul>
<li><input disabled="" type="checkbox"/>
所有权/借用/作用域</li>
<li><input disabled="" type="checkbox"/>
Option</li>
<li><input disabled="" type="checkbox"/>
Box</li>
<li><input disabled="" type="checkbox"/>
...</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
核心数据结构,及其常用操作</li>
<li><input disabled="" type="checkbox"/>
推荐工程结构
<ul>
<li><input disabled="" type="checkbox"/>
crate 以及内部模块管理</li>
<li><input disabled="" type="checkbox" checked=""/>
logging
<ul>
<li>tracing = &quot;0.1&quot;</li>
<li>clia-tracing-config = &quot;0.2&quot;</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
实用开发/调试流程
<ul>
<li><input disabled="" type="checkbox"/>
MVP/ CLI 工程</li>
<li><input disabled="" type="checkbox"/>
MVP/ web 工程</li>
<li><input disabled="" type="checkbox"/>
MVP/ 微服务</li>
<li><input disabled="" type="checkbox"/>
MVP/ 系统服务</li>
<li><input disabled="" type="checkbox"/>
...</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
实效 TDD 流程</li>
<li><input disabled="" type="checkbox"/>
底层调试技巧: gdb ...</li>
</ul>
<h2 id="refer-3"><a class="header" href="#refer-3">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<h3 id="youtube"><a class="header" href="#youtube">Youtube</a></h3>
<blockquote>
<p>真的是什么都有</p>
</blockquote>
<ul>
<li>各种劝解:
<ul>
<li><a href="https://www.youtube.com/watch?v=sDtQaO5_SOw">Rust Linz, June 2021 - Tim McNamara - How to learn Rust - YouTube</a></li>
</ul>
</li>
<li>110+<a href="https://www.youtube.com/playlist?list=PL3azK8C0kje1DUJbaOqce19j3R_-tIc4_">Rust 编程语言入门教程 [2021] - YouTube</a>
<ul>
<li>94+ <a href="https://www.youtube.com/playlist?list=PLVhhUNGAUIQScqB26DdUq4n1Y2n3auM7X">Rust - YouTube</a>
<ul>
<li>专题:<a href="https://www.youtube.com/watch?v=xhU8KDzL0vA&amp;list=PLVhhUNGAUIQRR7JheZsDaxF_Cd5Pf5slw">rusqlite - YouTube</a></li>
<li><a href="http://ogcrazcalm.blogspot.com/2015/11/sql-cheat-sheet.html">SQL Cheat Sheet | Crazcalm</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/database/sqlite.html#insert-and-select-data">SQLite - Rust Cookbook</a></li>
<li><a href="https://crates.io/crates/rusqlite">rusqlite - crates.io: Rust Package Registry</a></li>
<li><a href="https://doc.rust-lang.org/std/fs/struct.File.html#examples">File in std::fs - Rust</a></li>
</ul>
</li>
<li>42+<a href="https://www.youtube.com/playlist?list=PLVvjrrRCBy2JSHf9tGxGKJ-bYAN_uDCUL">RUST PROGRAMMING TUTORIALS - YouTube</a></li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW">Intro to Rust - YouTube</a></li>
<li>14+<a href="https://www.youtube.com/playlist?list=PLKkEWK6xRmes17LQUEA5bNjYISuCEOTXx">Rust For Starters - YouTube</a></li>
</ul>
</li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8">The Rust Lang Book - YouTube</a></li>
<li>25+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDD5vy2BuSHvFZU0a6RDmgb">Rust Projects - YouTube</a>
<ul>
<li>24+<a href="https://www.youtube.com/playlist?list=PL5dTjWUk_cPYuhHm9_QImW7_u4lr5d6zO">50 RUST Projects - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/@jonhoo">Jon Gjengset - YouTube</a>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFgY2faCIYjJZv_RluGkTlKt">Rust live-coding - YouTube</a>
<ul>
<li>都是几个小时的连续调试过程</li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">Crust of Rust - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLZaoyhMXgBzoM9bfb5pyUOT3zjnaDdSEP">Rust Talks - YouTube</a>
<ul>
<li>各种畅想...</li>
<li><a href="https://www.youtube.com/playlist?list=PLnhCUtqrIE-zgfmf6hn6fLwhfR_hDSG9T">Contributing to Rustc - YouTube</a> ~ 牛人直播如何为 Rust 编译器贡献特性...</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=_jMSrMex6R0&amp;list=PLFjq8z-aGyQ6t_LGp7wqHsHTYO-pDDx84">Rust - YouTube</a>
<ul>
<li>各种前景分析</li>
<li><a href="https://www.youtube.com/watch?v=qjwWF6K-7uE&amp;list=PLFjq8z-aGyQ78CQu1G3C5CT9ieiNpsnbJ">WebAssembly - YouTube</a> ~ 各种实现应用</li>
</ul>
</li>
<li>...</li>
</ul>
<h3 id="free-books"><a class="header" href="#free-books">free Books</a></h3>
<blockquote>
<p>这个世界上免费好资源太多了...</p>
</blockquote>
<p><a href="https://github.com/EbookFoundation/free-programming-books/blob/main/books/free-programming-books-langs.md#rust">free-programming-books/free-programming-books-langs.md at main · EbookFoundation/free-programming-books</a></p>
<h2 id="logging-3"><a class="header" href="#logging-3">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing"><a class="header" href="#tracing">tracing</a></h1>
<blockquote>
<p>一步到位日志工具?</p>
</blockquote>
<h2 id="background-4"><a class="header" href="#background-4">background</a></h2>
<p>无论哪种级别的开发,
一个日志工具是必要的,
否则,发生点儿什么事儿, 一点儿数据/配置/...的残影都没有那是真一点儿办法也没有...</p>
<h2 id="goal-4"><a class="header" href="#goal-4">goal</a></h2>
<ul>
<li>Rust 原生</li>
<li>成熟</li>
<li>支持多种格式/配置/定制/...</li>
<li>文档完备, 安装流畅, 没有急转弯....</li>
</ul>
<h2 id="trace-4"><a class="header" href="#trace-4">trace</a></h2>
<h3 id="install"><a class="header" href="#install">install</a></h3>
<p>Cargo.toml 中追加:</p>
<pre><code>[dependencies]
log = &quot;0.4&quot;
tracing = &quot;0.1&quot;
clia-tracing-config = &quot;0.2&quot;
</code></pre>
<blockquote>
<p>$ cargo check </p>
</blockquote>
<p>自动安装对应 crate</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() -&gt; Result&lt;()&gt;{

    let _guard = clia_tracing_config::build()
        .filter_level(&quot;debug&quot;)//fatal,error,warn,info,debug
        .with_ansi(true)
        .to_stdout(false)
        .directory(&quot;./log&quot;)
        .file_name(&quot;debug.log&quot;)
        .rolling(&quot;daily&quot;)
        .init();

/// ...

    Ok(())

}</code></pre></pre>
<p>在需要的场景中定义个 <code>_guard</code> 就完成了所有关键配置,
这是由 <code>clia-tracing-config</code> 实现的,</p>
<p>现在, 就可以在开发过程中使用</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>log::debug!(&quot;{}&quot;, foobar);
log::info!(&quot;{}&quot;, foobar);
log::warn!(&quot;{}&quot;, foobar);
log::error!(&quot;{}&quot;, foobar);
<span class="boring">}</span></code></pre></pre>
<p>进行日志输出, 而且每天自动活动, 但是, 有自动 link ,
可以使用 <code>tail -f </code> 一直追踪观察;</p>
<pre><code>项目/
    +- Cargo.toml
    +- README.md
    +- src/
    |   +- main.rs
    +- tests/
    |   +- cli.rs
    +- log/
    |   +- debug.log -&gt; debug.log.2023-02-25
    |   +- ...
    |   +- debug.log.2023-02-23
    |   `- debug.log.2023-02-25
    ...
</code></pre>
<h2 id="refer-4"><a class="header" href="#refer-4">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://awesomerank.github.io/lists/rust-unofficial/awesome-rust.html#cryptocurrencies">Awesome Rank for rust-unofficial/awesome-rust</a>
<ul>
<li><a href="https://github.com/rust-unofficial/awesome-rust">rust-unofficial/awesome-rust: A curated list of Rust code and resources.</a></li>
<li>先从社区知道 logging 模块的大约范畴</li>
</ul>
</li>
<li><a href="https://blog.logrocket.com/comparing-logging-tracing-rust/">Comparing logging and tracing in Rust - LogRocket Blog</a>
<ul>
<li><a href="https://privaterookie.github.io/posts/2020-02-03-log4rs-Rust-log%E5%BA%93.html">log4rs-Rust-log库 - 夜雨秋灯录</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10252834">在 Rust 中使用 log： log / slog / tracing - iT 邦幫忙</a></li>
<li>再从对比中定位目标</li>
</ul>
</li>
<li><a href="https://choosealicense.com/licenses/mit">tracing - crates.io: Rust Package Registry</a>
<ul>
<li><a href="https://course.rs/logs/tracing.html">使用 tracing 记录日志 - Rust语言圣经(Rust Course)</a></li>
<li><a href="https://crates.io/crates/clia-tracing-config">clia-tracing-config - crates.io: Rust Package Registry</a></li>
</ul>
</li>
<li>...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="伴学chatgpt"><a class="header" href="#伴学chatgpt">伴学ChatGPT</a></h1>
<blockquote>
<p>chatting for debugging ...</p>
</blockquote>
<h2 id="background-5"><a class="header" href="#background-5">background</a></h2>
<p>通过网络中各种免费教程/图书学习时,
作者文字背后的思考过程无法交流...</p>
<h2 id="goal-5"><a class="header" href="#goal-5">goal</a></h2>
<p>合理使用 ChatGPT 进行提示工程style 学习</p>
<h2 id="trace-5"><a class="header" href="#trace-5">trace</a></h2>
<blockquote>
<p>记录各种舒服的姿势:</p>
</blockquote>
<h3 id="cli-测试姿势"><a class="header" href="#cli-测试姿势">CLI 测试姿势</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>se assert_cmd::Command;
use predicates::prelude::*;
use std::fs;

type TestResult = Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;;

#[test]
fn dies_no_args() -&gt; TestResult {
    let mut cmd = Command::cargo_bin(&quot;echor&quot;)?; 
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;USAGE&quot;));
    Ok(()) 
}

#[test]
fn hello1() -&gt; TestResult {
    let expected = fs::read_to_string(&quot;tests/expected/hello1.txt&quot;)?;
    let mut cmd = Command::cargo_bin(&quot;echor&quot;)?;
    cmd.arg(&quot;Hello there&quot;).assert().success().stdout(expected);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Q:</p>
</blockquote>
<p>以上代码中, 为什么要专门定义 TestResult 类型?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>在 Rust 中，测试函数必须返回 Result&lt;(), Box<dyn std::error::Error>&gt; 类型。这是因为测试框架需要处理测试函数中可能出现的错误，并将这些错误转换为测试结果。如果测试函数返回的是一个普通的错误类型，测试框架无法对其进行处理，因此需要使用 Result 类型。TestResult 类型只是为了更清晰地表明这是一个测试函数返回的结果类型，并没有特殊的含义。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>Result&lt;(), Box<dyn std::error::Error>&gt; 这一类型, 具体有什么要求?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>Result&lt;(), Box<dyn std::error::Error>&gt; 是 Rust 中测试函数的标准返回类型。具体要求如下：</p>
<ul>
<li>返回类型为 Result，表示测试函数可以返回成功或失败的结果。</li>
<li>() 表示测试函数不返回任何值，因为测试函数的目的是验证代码的行为是否正确，而不是生成有用的输出。</li>
<li>Box<dyn std::error::Error> 表示测试函数返回的错误类型可以是任何实现了 std::error::Error trait 的类型，而且这个类型被包装在 Box 中。这是因为测试框架需要能够处理各种可能的错误类型，包括编译错误、运行时错误等等。使用 Box<dyn std::error::Error> 可以使测试函数返回任何实现了 std::error::Error trait 的错误类型，同时又能够在测试框架中方便地处理这些错误。</li>
</ul>
<p>总之，Result&lt;(), Box<dyn std::error::Error>&gt; 表示测试函数可以返回成功或失败的结果，不返回任何值，但是可以返回任何实现了 std::error::Error trait 的错误类型。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>任何实现了 std::error::Error trait 的错误类型 一般有什么类型包含这种 trait? 能举例说明嘛?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>任何实现了 std::error::Error trait 的类型都可以作为测试函数返回的错误类型。在 Rust 中，标准库中的很多错误类型都实现了 std::error::Error trait，例如：</p>
<ul>
<li>std::io::Error：表示 I/O 操作中可能出现的错误，如文件读写错误、网络通信错误等。</li>
<li>std::num::ParseIntError：表示将字符串转换为数字时可能出现的错误，如字符串不符合数字格式等。</li>
<li>std::env::VarError：表示获取环境变量时可能出现的错误，如环境变量不存在等。</li>
<li>serde_json::Error：表示处理 JSON 数据时可能出现的错误，如 JSON 数据格式错误等。</li>
</ul>
<p>这些类型都实现了 std::error::Error trait，因此可以作为测试函数返回的错误类型。在测试函数中，如果某个操作出现了这些错误，可以将错误包装成 Box<dyn std::error::Error> 类型返回，这样测试框架就可以处理这些错误并将其视为测试失败。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>如果要为自定义新数据类型追加这种 trait 有哪些可行方案? 举例说明一下?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>如果要为自定义的新数据类型追加 std::error::Error trait，有以下几种可行的方案：</p>
<ul>
<li>实现 std::error::Error trait：在新数据类型的实现代码中手动实现 std::error::Error trait，包括实现 description 方法和 source 方法。这样就可以将新数据类型作为测试函数的错误类型返回。例如：</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;

#[derive(Debug)]
struct MyError {
    message: String,
}

impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;{}&quot;, self.message)
    }
}

impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.message
    }

    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let result = Err(MyError {
        message: &quot;An error occurred&quot;.to_owned(),
    });
    result.map_err(Box::new)?;
    Ok(())
}</code></pre></pre>
<ul>
<li>使用 thiserror crate：thiserror 是一个 Rust crate，它提供了一种更简单的方法来实现 std::error::Error trait。使用 thiserror crate 可以通过宏来自动生成错误类型的实现代码，包括实现 std::error::Error trait。例如：</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;
use thiserror::Error;

#[derive(Debug, Error)]
#[error(&quot;An error occurred: {message}&quot;)]
struct MyError {
    message: String,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let result = Err(MyError {
        message: &quot;An error occurred&quot;.to_owned(),
    });
    result.map_err(Box::new)?;
    Ok(())
}
</code></pre></pre>
<p>... 在上面的代码中，使用 thiserror crate 定义了一个 MyError 类型，通过 #[derive(Error)] 宏自动生成了实现 std::error::Error trait 的代码。此时，MyError 类型就可以作为测试函数的错误类型返回了。</p>
<p>无论使用哪种方法，一旦为新数据类型追加了 std::error::Error trait，就可以将其作为测试函数的错误类型返回了。例如，下面是使用自定义错误类型进行测试的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
struct MyError {
    message: String,
}

impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;{}&quot;, self.message)
    }
}

impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.message
    }

    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}

fn foo() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    Err(MyError {
        message: &quot;An error occurred&quot;.to_owned(),
    })
}

#[test]
fn test_foo() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let result = foo();
    assert!(result.is_err());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="crate-思路"><a class="header" href="#crate-思路">crate 思路</a></h3>
<blockquote>
<p>Q:</p>
</blockquote>
<p>如何将一个 CLI 工具项目发布为一个 crate? 要进行哪些改造? 以及要注意什么?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>要将一个 CLI 工具项目发布为一个 crate，你需要进行以下步骤：</p>
<ul>
<li>将你的 CLI 工具项目打包成一个库。在 Rust 中，库文件通常以 lib.rs 文件为入口点，并将 CLI 代码重构为函数或结构体方法。这样可以将你的代码解耦，并使其更易于测试和重用。</li>
<li>在你的项目根目录中创建一个 Cargo.toml 文件，其中包含以下信息：
<ul>
<li>包的名称、版本号和作者信息。</li>
<li>项目的描述信息。</li>
<li>项目的依赖项和其版本要求。</li>
<li>包的类型，例如库或二进制文件。</li>
<li>包的许可证类型。</li>
</ul>
</li>
<li>将你的代码上传到 crates.io。首先，你需要创建一个 crates.io 帐户。然后，你可以使用 cargo login 命令登录并上传你的代码。在上传前，确保你的代码已经完成了测试，并且包含了合适的文档和许可证信息。</li>
<li>给你的 crate 添加文档。Rust 社区非常注重代码文档，因此你需要确保你的 crate 包含了适当的文档和注释。你可以使用 Rust 内置的文档工具来生成文档，并将其上传到 crates.io。</li>
<li>更新你的项目文档和 README。在将你的 crate 发布到 crates.io 后，你需要更新你的项目文档和 README 文件，以便其他开发者可以使用你的 crate。</li>
</ul>
<p>在发布你的 crate 前，你需要注意以下几点：</p>
<ul>
<li>你需要确保你的代码质量和可靠性。这包括确保你的代码通过了单元测试和集成测试，并尽可能避免使用未经测试的依赖项。</li>
<li>你需要确保你的代码符合 Rust 社区的代码规范和最佳实践。</li>
<li>你需要确保你的 crate 包含了适当的许可证信息，并确保你有权发布你的代码。</li>
<li>你需要确保你的 crate 包含了合适的文档和注释，以便其他开发者可以轻松地使用你的代码。</li>
</ul>
<p>总之，将一个 CLI 工具项目发布为一个 crate 需要对代码进行一些改造，确保代码质量和可靠性，并且遵循 Rust 社区的最佳实践和规范。发布前，你需要确保你的代码包含了适当的文档和许可证信息，并更新你的项目文档和 README 文件。</p>
<h3 id="toml-作为配置"><a class="header" href="#toml-作为配置">.toml 作为配置</a></h3>
<blockquote>
<p>Q:</p>
</blockquote>
<p>rudt 中读写 .toml 文件, 最推荐的 create 是哪个? 如何使用?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>如果你需要在 Rust 中读写 TOML 文件，可以使用 toml crate。这个 crate 可以在 Cargo.toml 文件中添加以下依赖来使用：</p>
<pre><code class="language-toml">[dependencies]
toml = &quot;0.5.8&quot;
</code></pre>
<p>以下是一个简单的示例代码，演示如何使用 toml crate 读取一个名为 &quot;config.toml&quot; 的 TOML 文件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs;
use toml::Value;

fn main() {
    // 读取文件
    let contents = fs::read_to_string(&quot;config.toml&quot;)
        .expect(&quot;Something went wrong reading the file&quot;);

    // 解析 TOML
    let parsed_toml: Value = toml::from_str(&amp;contents).unwrap();

    // 访问值
    let title = parsed_toml[&quot;title&quot;].as_str().unwrap();
    let subtitle = parsed_toml[&quot;subtitle&quot;].as_str().unwrap();

    println!(&quot;{}: {}&quot;, title, subtitle);
}</code></pre></pre>
<p>在上面的代码中，首先使用 fs::read_to_string 函数读取 TOML 文件的内容。然后，使用 toml::from_str 函数将内容解析为 toml::Value 类型的值。接下来，可以访问解析后的 TOML 值，例如 parsed_toml[&quot;title&quot;].as_str().unwrap() 用于获取 TOML 文件中的 &quot;title&quot; 值。最后，将这些值打印到控制台。</p>
<p>如果你需要将数据写入 TOML 文件，则可以使用 toml crate 的 to_string 函数将 toml::Value 类型的值转换为 TOML 格式的字符串，然后使用 fs::write 函数将字符串写入文件。</p>
<p>以下是一个简单的示例代码，演示如何使用 toml crate 写入一个名为 &quot;config.toml&quot; 的 TOML 文件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs;
use toml::Value;

fn main() {
    // 创建一个 `toml::Value` 类型的值
    let mut toml_value = Value::new();
    toml_value[&quot;title&quot;] = &quot;My Title&quot;.into();
    toml_value[&quot;subtitle&quot;] = &quot;My Subtitle&quot;.into();

    // 将值转换为 TOML 格式的字符串
    let toml_str = toml::to_string(&amp;toml_value).unwrap();

    // 写入文件
    fs::write(&quot;config.toml&quot;, toml_str).expect(&quot;Something went wrong writing the file&quot;);
}
</code></pre></pre>
<p>在上面的代码中，首先创建一个 toml::Value 类型的值，该值包含要写入 TOML 文件的数据。然后，使用 toml::to_string 函数将该值转换为 TOML 格式的字符串。最后，使用 fs::write 函数将字符串写入文件。</p>
<h3 id="展开-bufreader"><a class="header" href="#展开-bufreader">展开 BufReader</a></h3>
<blockquote>
<p>Q:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let f = File::open(&quot;log.txt&quot;)?;
    let mut reader = BufReader::new(f);

    let mut line = String::new();
    let len = reader.read_line(&amp;mut line)?;
    println!(&quot;First line is {} bytes long&quot;, len);
    Ok(())
}</code></pre></pre>
<p>如何将这段代码修改为循环将指定文件所有行内容逐一输出?</p>
<blockquote>
<p>PS: 从 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html#examples">std::io::BufReader - Rust</a> 抄的</p>
</blockquote>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>要循环输出文件的所有行内容，您可以在一个循环中使用BufReader的read_line方法。每次迭代时，该方法会读取文件中的一行，并将其存储在给定的字符串变量中。当没有更多的行可以读取时，该方法将返回一个长度为0的结果，这是跳出循环的信号。</p>
<p>以下是修改后的代码示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let f = File::open(&quot;log.txt&quot;)?;
    let reader = BufReader::new(f);

    for line in reader.lines() {
        println!(&quot;{}&quot;, line?);
    }
    Ok(())
}</code></pre></pre>
<p>在这个例子中，我们使用了reader.lines()方法，它返回一个std::io::Lines迭代器。每次迭代时，该迭代器都会读取文件中的一行，并将其包装在一个std::io::Result<String>中返回。我们可以使用?操作符来解包这个结果，如果读取失败，它会将错误传播到main函数的调用方。</p>
<p>通过这种方式，我们可以逐行读取文件并将每一行内容输出到控制台。</p>
<blockquote>
<p>Q:
std::io::prelude 是什么库? 引用了什么进来? 用在哪儿了?</p>
</blockquote>
<blockquote>
<p>GPT:</p>
</blockquote>
<p><code>std::io::prelude</code> 是一个模块，包含了一些常见的 I/O trait 和类型的预定义导入。这些预定义导入使得开发者能够轻松地使用 Rust 标准库中的 I/O 功能，同时也减少了大量的代码重复。</p>
<p>在 Rust 代码中，通过引入std::io::prelude模块来使用预定义导入，通常会出现在处理 I/O 相关操作的代码中。这个模块包含了以下几个 trait 的预定义导入：</p>
<ul>
<li>Read: 用于读取数据的 trait。</li>
<li>BufRead: 用于读取缓冲区的 trait。</li>
<li>Write: 用于写入数据的 trait。</li>
</ul>
<p>这些 trait 都被用于在 Rust 中进行 I/O 操作，因此它们经常会被其他的 I/O 模块或库使用。例如，在上面提供的示例代码中，我们使用了std::io::prelude来导入Read trait，从而使用BufReader的read_line方法读取文件中的每一行内容。</p>
<blockquote>
<p>A: 
如何对循环中的 line 进行类似 contains 的判定呢?</p>
</blockquote>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>要对读取的每一行内容进行包含（contains）的判定，您可以在for循环内使用if语句，对每一行进行检查。以下是示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let f = File::open(&quot;log.txt&quot;)?;
    let reader = BufReader::new(f);

    for line in reader.lines() {
        let line_content = line?;
        if line_content.contains(&quot;Error&quot;) {
            println!(&quot;{}&quot;, line_content);
        }
    }
    Ok(())
}</code></pre></pre>
<p>在这个例子中，我们使用contains方法检查每一行内容是否包含字符串&quot;Error&quot;。如果是，我们将该行内容打印到控制台。否则，我们将跳过该行并继续读取文件的下一行。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>对应代码修改为:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = File::open(&amp;args.path)
        .expect(&quot;could NOT read the file&quot;);
    let reader = BufReader::new(f);

    let mut line = String::new();
    for line in reader.lines() {
            let line_content = line?;
            if line_content.contains(&quot;Error&quot;) {
                println!(&quot;{}&quot;, line_content);
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>但是报错:</p>
<pre><code>error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
  --&gt; src/main.rs:66:36
   |
24 | fn main() {
   | --------- this function should return `Result` or `Option` to accept `?`
...
66 |             let line_content = line?;
   |                                    ^ cannot use the `?` operator in a function that returns `()`
   |
   = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>应该如何解决?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>该错误是因为在main函数中，我们不能在循环中使用?操作符。?操作符只能用于返回Result或Option的函数或方法中，它会在发生错误时自动将错误返回给调用者。</p>
<p>在main函数中，我们必须手动处理错误并决定如何处理它们。在这种情况下，我们可以简单地将错误打印到控制台。以下是示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    for line in reader.lines() {
        if let Ok(line_content) = line {
            if line_content.contains(&quot;Error&quot;) {
                println!(&quot;{}&quot;, line_content);
            }
        } else {
            eprintln!(&quot;Error while reading file&quot;);
            return;
        }
    }
}</code></pre></pre>
<p>在这个例子中，我们使用if let语句检查读取每一行是否成功。如果成功，我们检查行内容是否包含字符串&quot;Error&quot;，如果是则将其打印到控制台。如果读取行时发生错误，我们将错误打印到标准错误流（stderr），并退出程序。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>看起来这里有多层 if 不是很 rusty, 有其它方案来达成相同效果嘛?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>您可以使用match语句来代替嵌套的if let语句，以避免多层嵌套和提高代码可读性。以下是使用match语句重写的示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    for line in reader.lines() {
        match line {
            Ok(line_content) =&gt; {
                if line_content.contains(&quot;Error&quot;) {
                    println!(&quot;{}&quot;, line_content);
                }
            }
            Err(_) =&gt; {
                eprintln!(&quot;Error while reading file&quot;);
                return;
            }
        }
    }
}</code></pre></pre>
<p>在这个例子中，我们使用match语句匹配line的值。如果读取行成功，我们使用Ok(line_content)分支来处理行内容，如果行内容包含字符串&quot;Error&quot;，则将其打印到控制台。如果读取行时出现错误，我们使用Err(_)分支来处理错误，并将错误打印到标准错误流（stderr），并退出程序。</p>
<p>相比使用嵌套的if let语句，match语句更加清晰和简洁。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>没错, match 看起来优雅多了, 不过, 还有其它方案嘛?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>是的，除了使用match语句，还有一种更简洁的方法来实现类似的效果。可以使用filter_map方法和std::result::Result::ok函数来过滤行并将它们转换为可选的字符串。然后，您可以使用for循环迭代这些字符串并将它们打印出来。以下是使用filter_map和std::result::Result::ok函数的示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    for line in reader.lines().filter_map(Result::ok).filter(|line| line.contains(&quot;Error&quot;)) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre></pre>
<p>在这个例子中，我们首先调用filter_map方法来过滤掉那些读取行时返回错误的行，并将其转换为可选的字符串。然后，我们使用filter方法来过滤掉那些不包含字符串&quot;Error&quot;的行。最后，我们使用for循环迭代这些字符串，并将它们打印到控制台。</p>
<p>相比使用match语句和嵌套的if let语句，这种方法更加简洁和优雅。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>还有更加优雅的方案嘛?</p>
<blockquote>
<p>GPT:
当然，Rust 的标准库提供了非常强大的迭代器和函数式编程工具箱，可以让代码更加简洁和优雅。</p>
</blockquote>
<p>在这个例子中，您可以使用filter方法和闭包来过滤掉不包含&quot;Error&quot;的行，然后使用map方法和unwrap函数将可选的行转换为字符串并将其打印到控制台上。这是代码的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    reader.lines()
          .filter(|line| line.as_ref().map(|s| s.contains(&quot;Error&quot;)).unwrap_or(false))
          .map(|line| line.unwrap())
          .for_each(|line| println!(&quot;{}&quot;, line));
}</code></pre></pre>
<p>在这个例子中，我们首先调用filter方法来过滤掉那些不包含字符串&quot;Error&quot;的行。由于lines方法返回的是一个包含Result&lt;Option<String>&gt;的迭代器，我们需要在闭包中使用as_ref方法来将Result&lt;Option<String>&gt;转换为Option&lt;&amp;String&gt;。然后，我们使用map方法和unwrap函数来将可选的行转换为字符串，并将其打印到控制台上。</p>
<p>使用这种方法，我们可以将代码进一步简化，并更加清晰地表达我们的意图。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>没错, 这样又简洁,又整齐,而且意义明确;
看起来 迭代器和函数式工具有很多, 类似 filter 和 map 的内置工具还有哪些? 分别有什么优雅的实用案例?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>Rust 的标准库提供了丰富的迭代器和函数式编程工具，包括：</p>
<ul>
<li>map：将一个迭代器中的每个元素转换为另一种类型的元素，通常用于数据类型转换和计算。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let squares: Vec&lt;i32&gt; = numbers.iter().map(|n| n * n).collect();
// squares is [1, 4, 9, 16, 25]
<span class="boring">}</span></code></pre></pre>
<ul>
<li>filter：根据某个条件过滤出迭代器中的元素，通常用于数据过滤和筛选。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let evens: Vec&lt;i32&gt; = numbers.iter().filter(|n| n % 2 == 0).collect();
// evens is [2, 4]
<span class="boring">}</span></code></pre></pre>
<ul>
<li>fold：使用某种累加器（初始值）和一个闭包来聚合迭代器中的元素，通常用于求和、平均值和字符串拼接等操作。
<ul>
<li>示例：计算一个数字向量中所有元素的和。</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let sum: i32 = numbers.iter().fold(0, |acc, n| acc + n);
// sum is 15
<span class="boring">}</span></code></pre></pre>
<ul>
<li>flat_map：将一个迭代器中的每个元素转换为另一个迭代器，然后将所有的迭代器合并为一个迭代器。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let words = vec![&quot;hello world&quot;, &quot;foo bar&quot;, &quot;baz qux&quot;];
let letters: Vec&lt;char&gt; = words.iter().flat_map(|s| s.chars()).collect();
// letters is ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', 'f', 'o', 'o', ' ', 'b', 'a', 'r', 'b', 'a', 'z', ' ', 'q', 'u', 'x']
<span class="boring">}</span></code></pre></pre>
<ul>
<li>any 和 all：检查迭代器中是否存在任意元素或所有元素都满足某个条件。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let any_odd = numbers.iter().any(|n| n % 2 == 1);
let all_even = numbers.iter().all(|n| n % 2 == 0);
// any_odd is true, all_even is false
<span class="boring">}</span></code></pre></pre>
<ul>
<li>enumerate: 枚举迭代器中的元素，并将元素索引和值组成一个元组返回。
<ul>
<li>示例：遍历一个字符串向量并打印每个元素的索引和值。</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
for (i, s) in v.iter().enumerate() {
    println!(&quot;{}: {}&quot;, i, s);
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>zip：将两个迭代器合并为一个元素对的迭代器。
<ul>
<li>示例：从两个向量中取出对应位置的元素并组成一个新的向量</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
let letters = vec!['a', 'b', 'c'];
let pairs: Vec&lt;(i32, char)&gt; = numbers.iter().zip(letters.iter()).collect();
// pairs is [(1, 'a'), (2, 'b'), (3, 'c')]

<span class="boring">}</span></code></pre></pre>
<p>当使用迭代器处理数据时，有时需要对数据进行分段处理。在这种情况下，可以使用 take 和 skip 方法。</p>
<ul>
<li>take：从一个集合中取出前几个元素。例如，从一个包含所有人的向量中取出前 10 个人。
<ul>
<li>take(n) 方法会创建一个新的迭代器，它只包含原始迭代器的前 n 个元素。例如：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let first_three = numbers.iter().take(3);
for number in first_three {
    println!(&quot;{}&quot;, number);
}
// 输出:
// 1
// 2
// 3
<span class="boring">}</span></code></pre></pre>
<ul>
<li>skip：跳过一个集合中的前几个元素。例如，从一个包含所有人的向量中跳过前 10 个人，然后返回剩余的所有人。
<ul>
<li>skip(n) 方法会创建一个新的迭代器，它跳过原始迭代器的前 n 个元素，然后迭代其余的元素。例如：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let last_two = numbers.iter().skip(3);
for number in last_two {
    println!(&quot;{}&quot;, number);
}
// 输出:
// 4
// 5

<span class="boring">}</span></code></pre></pre>
<ul>
<li>chain：将两个集合连接在一起，然后返回一个新的集合。例如，将一个包含所有男性的向量和一个包含所有女性的向量连接在一起，然后返回一个包含所有人的向量。
<ul>
<li>另一个常见的迭代器方法是 chain 方法。它接收另一个迭代器作为参数，将其添加到当前迭代器的末尾，并返回一个新的迭代器。例如：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers1 = vec![1, 2, 3];
let numbers2 = vec![4, 5, 6];
let all_numbers = numbers1.iter().chain(numbers2.iter());
for number in all_numbers {
    println!(&quot;{}&quot;, number);
}
// 输出:
// 1
// 2
// 3
// 4
// 5
// 6

<span class="boring">}</span></code></pre></pre>
<p>在上面的示例中，我们首先创建了两个向量 numbers1 和 numbers2，然后将它们合并为一个新的迭代器 all_numbers。最后，我们遍历 all_numbers 并输出其中的所有元素。</p>
<p>这些是 Rust 中一些常见的迭代器方法和函数式工具，您可以根据自己的需要来选择使用它们。在 Rust 中，迭代器和函数式编程被广泛应用于各种场景，例如处理集合、过滤和排序数据、处理文本等等。通过使用这些工具，您可以编写更加简洁、优雅、高效和安全的代码。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>发现还有 try_fold 之类带有 try_ 的迭代器,一般是用在什么场景中的?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>try_fold 方法是一个带有 try_ 前缀的迭代器方法，它类似于 fold 方法，但是它允许在迭代器处理过程中发生错误，并将错误传递给调用方进行处理。try_fold 方法的使用场景通常是处理可能会失败的操作的迭代器元素序列，例如网络请求或文件 I/O 操作。</p>
<p>try_fold 方法有两个参数：一个初始累加器和一个闭包，闭包将当前累加器的值和迭代器的下一个元素作为参数，并返回一个 Result 值。如果闭包返回一个 Ok 值，则 try_fold 方法会继续迭代。如果闭包返回一个 Err 值，则 try_fold 方法会立即停止迭代并将错误传递给调用方。</p>
<p>以下是一个简单的示例，演示如何使用 try_fold 方法来计算向量中所有元素的和，其中每个元素都是 Result&lt;i32, String&gt; 类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let vec = vec![Ok(1), Ok(2), Err(&quot;failed&quot;.to_string()), Ok(3)];
    let sum = vec
        .into_iter()
        .try_fold(0, |acc, x| x.map(|n| acc + n));
    match sum {
        Ok(result) =&gt; println!(&quot;Sum is {}&quot;, result),
        Err(error) =&gt; println!(&quot;Error: {}&quot;, error),
    }
}</code></pre></pre>
<p>在上面的代码中，我们首先创建了一个向量 vec，其中包含三个 Ok 值和一个 Err 值。然后我们使用 into_iter 方法将向量转换为迭代器，使用 try_fold 方法来计算所有元素的和，其中使用 map 方法将 Ok 值映射到它们的整数值，并忽略 Err 值。最后，我们使用 match 来处理可能的错误和结果。</p>
<h2 id="refer-5"><a class="header" href="#refer-5">refer.</a></h2>
<blockquote>
<p>其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...</p>
</blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#">Iterator in std::iter - Rust</a></li>
</ul>
<h2 id="logging-4"><a class="header" href="#logging-4">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230224 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercism"><a class="header" href="#exercism">Exercism</a></h1>
<blockquote>
<p>练习主义</p>
</blockquote>
<h2 id="background-6"><a class="header" href="#background-6">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/about">About Exercism</a></p>
<p>是一个神奇的网站</p>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.30.38.jpg" alt="" /></p>
<p>一是个专注用练习题来学习各种开发语言的网站,
免费,包含越来越多的语言</p>
<h2 id="goal-6"><a class="header" href="#goal-6">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust">Rust on Exercism</a></p>
<p>至少先刷完这 103 道题目, 然后, 再开发具体的实用工具;</p>
<h2 id="trace-6"><a class="header" href="#trace-6">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.31.48.jpg" alt="rust" /></p>
<p>不过最终是乱序来的</p>
<h2 id="refer-6"><a class="header" href="#refer-6">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<p><a href="https://cheats.rs/">Rust Language Cheat Sheet</a></p>
<ul>
<li><a href="https://juejin.cn/post/7146144676532191262">16｜数据结构：Vec<T>、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？ - 掘金</a></li>
<li>...</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a16a825f50d4d34866d432c15fa3ebd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="" /></p>
<h2 id="logging-5"><a class="header" href="#logging-5">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rs42all-your-base"><a class="header" href="#rs42all-your-base">rs42all-your-base</a></h1>
<blockquote>
<p>所有进制</p>
</blockquote>
<h2 id="background-7"><a class="header" href="#background-7">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/docs/tracks/rust">All Your Base in Rust on Exercism</a></p>
<h2 id="logging-6"><a class="header" href="#logging-6">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id="try_fold"><a class="header" href="#try_fold">try_fold()</a></h3>
<blockquote>
<p>表达能力的典范...</p>
</blockquote>
<h2 id="refer-7"><a class="header" href="#refer-7">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Positional_notation#External_links">Positional notation - Wikipedia</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html">Iterator in std::iter - Rust</a>
<ul>
<li><a href="https://qiita.com/lo48576/items/34887794c146042aebf1">Rustのイテレータの網羅的かつ大雑把な紹介 - Qiita</a></li>
<li><a href="https://zenn.dev/megeton/articles/fb6266bcb6aa1b">Ruby脳のためのRust配列系メソッドまとめ</a></li>
<li>...</li>
</ul>
</li>
<li><a href="https://rustcc.cn/article?id=2f4b3a15-7874-4c68-b9d8-5a717e9a3af0">rust新手的一个问题：fold和scan。 - Rust语言中文社区</a>
<ul>
<li><a href="https://juejin.cn/post/7067102952602746910">抛弃Rust的try...catch和null检查 - 掘金</a></li>
<li>...</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ex43allergies"><a class="header" href="#ex43allergies">ex43Allergies</a></h1>
<blockquote>
<p>过敏源</p>
</blockquote>
<h2 id="background-8"><a class="header" href="#background-8">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust/exercises/allergies">Allergies in Rust on Exercism</a></p>
<h2 id="logging-7"><a class="header" href="#logging-7">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id=""><a class="header" href="#">&amp;</a></h3>
<blockquote>
<p>现实世界的 与计算</p>
</blockquote>
<h2 id="refer-8"><a class="header" href="#refer-8">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://hltj.me/lang/2016/11/07/10m-letters.html">由“千万字母表问题”看多范式编程语言 | 灰蓝时光</a>
<ul>
<li><a href="http://www.nct9.ne.jp/m_hiroi/linux/rust14.html">Linux Programming / お気楽 Rust プログラミング超入門</a></li>
</ul>
</li>
<li>...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<blockquote>
<p>projects ...</p>
</blockquote>
<h2 id="background-9"><a class="header" href="#background-9">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>开发语言学习, 不用来开发真实项目, 基本是表演学习行为了...</p>
<h2 id="goal-7"><a class="header" href="#goal-7">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>一组日常要用工具, 原创/再制/...</p>
<p>关键是积累一组可用作品, 打底儿.</p>
<h2 id="trace-7"><a class="header" href="#trace-7">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>???</p>
<h2 id="refer-9"><a class="header" href="#refer-9">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-8"><a class="header" href="#logging-8">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践作品"><a class="header" href="#实践作品">实践作品</a></h1>
<h2 id="background-10"><a class="header" href="#background-10">background</a></h2>
<p>学习一门新语言, 最高效的姿势就是拿来使用了</p>
<h2 id="goal-8"><a class="header" href="#goal-8">goal</a></h2>
<p>将当前日常要用的各种工具, 转化为 rust 版本的...</p>
<h2 id="plan"><a class="header" href="#plan">plan</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
NNera ~ 牛妞纪元</li>
<li><input disabled="" type="checkbox"/>
bxmr ~ BXM 输入码表维护器</li>
<li><input disabled="" type="checkbox"/>
yuzu ~ 柚子, 简陋的私用短址生成器
<ul>
<li><input disabled="" type="checkbox" checked=""/>
SUUID ~ 短 UUID 生成器; 组合标准的 UUID+Md5 就好</li>
<li><input disabled="" type="checkbox"/>
自制, 参考: <a href="https://github.com/skorokithakis/shortuuid/blob/master/shortuuid/main.py">shortuuid/main.py at master · skorokithakis/shortuuid</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Yazi ~ 睚眦 git 仓库行为分析器</li>
</ul>
<h2 id="trace-8"><a class="header" href="#trace-8">trace</a></h2>
<blockquote>
<p>追踪笔记</p>
</blockquote>
<h2 id="refer-10"><a class="header" href="#refer-10">refer.</a></h2>
<blockquote>
<p>各种相关参考...</p>
</blockquote>
<ul>
<li><a href="https://www.oreilly.com/library/view/command-line-rust/9781098109424/">Command-Line Rust [Book]</a></li>
<li>...</li>
</ul>
<h2 id="logging-9"><a class="header" href="#logging-9">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>...</li>
<li>230122 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20年来作为软件工程师学到的20件事"><a class="header" href="#20年来作为软件工程师学到的20件事">20年来作为软件工程师学到的20件事</a></h1>
<p>原文: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/">20 Things I've Learned in my 20 Years as a Software Engineer - Simple Thread</a></p>
<h2 id="注意请先阅读此内容"><a class="header" href="#注意请先阅读此内容">注意:请先阅读此内容</a></h2>
<p>即将展现的是一篇包含大量建议的 blog ;
向前人学习对成功至关重要,但是,我们常常忘记另外一个重要警告:
几乎所有的建议都是上下文相关的, 但是,很少对上下文提供细节;</p>
<p>&quot;你需要收取更多费用!&quot; 这经营了20年的公司说, 多年以来收费&quot;太低&quot;,无法赢得客户并取得成功;</p>
<p>&quot;你需要将一切构建为微服务!&quot; 该公司表示, 构建了一个快速的整体,获得了数千客户,然后,在开始遇到问题时, 全面转向了微服务;</p>
<p>如果不了解上下文, 建议就毫无意义,甚至更糟糕,有害;
如果那些人早点听从他们自己的建议,他们自己可能会因此受苦;
对于任何建议很难逃脱这个陷阱;
我们可能是我们经历的终点,但是,我们却是通过现在的镜头来观察;</p>
<p>因此,为了让你了解一下这些建议的来源,特此说明:
我在职业生涯的前半段担当软件工程师,为各种小型企业和初创公司工作,
然后,我进入咨询行业并在许多非常太的企业工作;
最后, 我开创了 <code>Simple Thread</code>,
我们从一个2人团队成长为一个25人的团队;
10年前, 我们主要和中小型企业合作,现在我们和大型和小型企业合作;</p>
<p>我的所有建议来自于:</p>
<ul>
<li>几乎总是在小而精干的团队中,我们必须用很少的资源作很多事情</li>
<li>重视工作软件而不是特定工具</li>
<li>一直在开始新项目,同时还要维护一些系统</li>
<li>重视工程师的生产力,超过其它大多数考虑因素</li>
<li>...</li>
</ul>
<p>我过去20年的经历塑造了对软件的偏见,
并使我形成了一些信念;
我试图将这些信念压缩为一个易于使用的列表,
希望你能发现她们的价值;</p>
<h2 id="建议清单"><a class="header" href="#建议清单">建议清单:</a></h2>
<h3 id="1-我仍然懂的不是太多"><a class="header" href="#1-我仍然懂的不是太多">1. 我仍然懂的不是太多</a></h3>
<p>&quot;你怎么不知道 BGP ?&quot;</p>
<p>&quot;你从来没听说过 Rust?&quot;</p>
<p>我们大多数人都被人这么说过,
而且可能听的太频繁了;
我们中许多人喜欢软件的原因就是因为我们是终身学习者, 在软件领域,
无论你从哪个方向看, 都有广阔的知识前景向各个方向发展,
而且每天都在扩展;
这意味着即便你在职业生涯中度过数十年,
但是, 和同样在看似相似的角色中度过数十年的人相比,
仍然存在巨大的知识差距;
越早意识到这点, 就能越早开始摆脱 &quot;顶替者综合症&quot; ,
转而乐于向他人学习和教导他人;</p>
<h3 id="2-软件最难的部分是构建正确的东西"><a class="header" href="#2-软件最难的部分是构建正确的东西">2. 软件最难的部分是构建正确的东西</a></h3>
<p>我知道在这点上算陈词滥调,
但是, 大多数软件工程师并不相信的原因是, 他们认为这在贬低他们的工作;
我个人认为这是无稽之谈；
相反,这突出了我们必须工作的环境本身复杂性和不合理性,
这故居了我们的挑战;
你可以设计出世界上技术上最令人印象深刻的东西,
然后, 却无人愿意使用;
这种事儿一直在发生;
设计软件主要是一种倾听活动,
我们经常不得不成为竕软件工程师, 部分通灵师, 以及部分人类学家;
投资在这个设计过程, 无论是通过专门的 UX 团队, 还是通过简单的自我教育,
都将带来巨大的回报;
因为, 你如何计算构建错误软件的真正成本?
这不仅仅是损失工程时间...</p>
<h3 id="3-最好的软件工程师像设计师一样思考"><a class="header" href="#3-最好的软件工程师像设计师一样思考">3. 最好的软件工程师像设计师一样思考</a></h3>
<p>伟大的软件工程师会思考他们代码的用户体验;
他们可能不会用各种术语来考虑,
而是考虑应该是外部API/编程API/用户界面/协议还是其它任何界面;
伟大的工程师会考虑谁将使用, 为什么要使用,如何使用,
以及这些对用户来说什么是最重要的;
牢记用户的需求, 确认是良好用户体验的核心;</p>
<h3 id="4-最好的代码是没有代码或是你不必维护的"><a class="header" href="#4-最好的代码是没有代码或是你不必维护的">4. 最好的代码是没有代码,或是你不必维护的</a></h3>
<p>我只想说: &quot;码农只能编码&quot;;
你问任何行业的人如何解决问题, 
他们都会在他们擅长的领域犯错误;
叫只是人性;
大多数软件工程师总是会在编写代码时出错,
尤其是当非技术解决方案不明朗时;
你不必维护的代码也是如此;
当很多轮子已经存在时,
工程团队很容易想要重新发明轮子;
这是一种平衡行为, 
有很多理由让你自己再来一遍,
但是, 要提防这种 &quot;没在此现实&quot;(“Not Invented Here”) 综合症;</p>
<h3 id="5-软件是达到目的的手段"><a class="header" href="#5-软件是达到目的的手段">5. 软件是达到目的的手段</a></h3>
<p>任何软件工程师的主要工作是交付价值;</p>
<p>很少有软件开发者理解这一点, 将其内化的就更少了;
真正将其内化后, 能导致解决问题的不同方式,
以及观察工具的不同方式;
如果真真的相信软件是从属于结果的,
你就会准备好找到真正&quot;适合的工具&quot;,
有时可能根本不是软件;</p>
<h3 id="6-有时你必须停止磨锯直接开始砍屎"><a class="header" href="#6-有时你必须停止磨锯直接开始砍屎">6. 有时你必须停止磨锯,直接开始砍屎</a></h3>
<p>有些人倾向于跳入问题, 并立即开始编写代码;
其它人往往想要研究和陷入硬件分析进而瘫痪;
在这些情况中,为自己设定一个截止日期,
然后, 开始探索解决方案;
当你开始解决问题时,你很快能学习到更多,
这也将引导你迭代到更好的解决方案;</p>
<h3 id="7-如果你不能很好的理解所有可能性-就无法设计出好的系统"><a class="header" href="#7-如果你不能很好的理解所有可能性-就无法设计出好的系统">7. 如果你不能很好的理解所有可能性, 就无法设计出好的系统</a></h3>
<p>这是我一直在努力解决的问题,
因为, 我的职责使我在软件工程的日常工作中越来越远;
峎上开发者生态是一项巨大的工作,
但是,了解什么是可能的至关重要;
如果你不了解给定生态中有什么是可能的,以及什么是可用的,
那么你将发现除了最简单的问题之外,
不可能设计出一个合理的解决方案来解决所有问题;
总而言之, 要警惕那些很长时间没有编写任何代码的架构专家;</p>
<h3 id="8-每个的了了的都很糟粕克服丫的"><a class="header" href="#8-每个的了了的都很糟粕克服丫的">8. 每个的了了的都很糟粕,克服丫的</a></h3>
<p>Bjarne Stroustrup 有句名言:
&quot;只有两种语言: 人们抱怨的语言, 和没人使用的语言&quot;;</p>
<p>这也可以拓展到大型系统;
没有&quot;正确&quot;的架构, 你永远无法偿还所有技术债务,
你永远无法设计出完美的界面,
你的测试总是太慢;
这不是永不让事情变得更好的借口,
而是一种给你观点的方式;
少担心优雅和完美;
相反, 努力持续改进并创建一个你的团队喜欢在其中工作,
并可以持续创造价值的宜人系统;</p>
<h3 id="9-无人问足为什么"><a class="header" href="#9-无人问足为什么">9. 无人问足&quot;为什么&quot;</a></h3>
<p>抓住任何机会质疑&quot;作事方式&quot;的假设和方法;
有新人加入嘛?
注意他们在哪里感到困惑以及他们在问什么问题;
有没有无意义新功能请求?
确保你了解目标以及是什么推动了对这一功能的渴望;
如果你没有得到明确的答案,
请继续问为什么, 直到你明白为止;</p>
<h3 id="10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员"><a class="header" href="#10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员">10. 我们应该更专注于避免0.1x 程序员,而不是寻找 10x 程序员</a></h3>
<p>10倍速程序员是一个愚蠢的神话;
某人可以在1天里生产出另外一位有能力/勤奋/有类似经验的程序员需要在2周以内生产代码的想法是愚蠢的;
我见过程序员编写10倍的代码,
然后, 你必须修复它10倍以上的次数;
某珍爱可以成为10倍程序员的唯一方法,
是将他们和 0.1 倍速程序员进行比较;
有人浪费时间, 不寻求反馈, 不测试代码,
不考虑边缘情况等等...</p>
<p>我们应该关心让 0.1 倍速程序员远离我们的团队,
而不是寻找神话般的 10 倍速程序员;</p>
<h3 id="11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见"><a class="header" href="#11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见">11. 高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见</a></h3>
<p>没有什么比对他们的工具或是如何构建软件没有有意见的高级工程师更让我担心的事儿了;</p>
<p>我宁愿有人给有强烈的反对意见, 也不愿他们完全没有意见;
如果你正在使用你的工具,而且你还没有更多喜欢或是讨厌的情绪,
那么, 你需要更多体验;
你需要探索其它语言/库/范例;
没有什么比积极寻找其它人如何使用和你不同的工具和技术来完成任务更快提高技能的方法了;</p>
<h3 id="12-人们并不是真想创新"><a class="header" href="#12-人们并不是真想创新">12. 人们并不是真想创新</a></h3>
<p>人们经常谈论创新,
但是, 他们通常寻找的是廉价的胜利和新奇;
如果你在真正的创新, 并想改变人们作事的方式,
那么大多数情况下都会收到负面反馈;
如果你相信自己在作的事儿,
并知道确实会改善事情,
那么为自己的长期战斗作好准备;</p>
<h3 id="13-数据是你系统中最重要的部分"><a class="header" href="#13-数据是你系统中最重要的部分">13. 数据是你系统中最重要的部分</a></h3>
<p>我见过很多系统, 其中希望数据完备性是系统主要机制;
在这种系统中,
任何在黄金路径之外发生的事情,都会心产生部分脏数据;
将来处理这些数据将是一场噩梦;
请记住, 你的数据可能会比你的代码要长寿;
花精力保持数据秩序和清洁,从长远看会有好的回报;</p>
<h3 id="14-寻找技术鲨鱼"><a class="header" href="#14-寻找技术鲨鱼">14. 寻找技术鲨鱼</a></h3>
<p>仍然存在的旧技术是鲨鱼而不是恐龙;
他们解决问题能力如此之强,以至在技术世界不断发生的快速变化中幸存下来;
不要和这些技术打赌,
只有在有充分理由的情况下才负担它们;
这些工具不会华而不实,
也不会令人兴奋,
得是不是, 它们能在没有很多不眠之夜的情况下完成工作;</p>
<h3 id="15-还要把谦逊误认为无知"><a class="header" href="#15-还要把谦逊误认为无知">15. 还要把谦逊误认为无知</a></h3>
<p>有很多软件工程师除非被直接问到,
否则不会发表意见;
永远不要认为仅仅因为有人没有将意见扔到你面前,
他们就没有什么可以补充的;
有时, 最吵闹的人是我们最不想听的;
和周围人交谈, 寻求他们的反馈和建议;
你会庆幸你这么作了;</p>
<h3 id="16-软件工程师应该定期写作"><a class="header" href="#16-软件工程师应该定期写作">16. 软件工程师应该定期写作</a></h3>
<p>软件工程师应该定期写 blog/日记/文档,
通常作需要他们保持书面沟通技巧的事儿;
写作可以帮助你思考问题,
并帮助你能更有效的和团队以及未来的自己沟通;
良好的书面沟通是任何软件工程师都必须掌握的最重要技能之一;</p>
<h3 id="17-尽可能保持流程简洁"><a class="header" href="#17-尽可能保持流程简洁">17. 尽可能保持流程简洁</a></h3>
<p>现在每个人想想变得敏捷,
但是,&quot;敏捷&quot;就是以小块的方法构建事物/学习/然后迭代;
如果有人试图在其中塞入更多东西,
那么,他们可能只是在卖东西;
这并不是说人们不需要问责或是帮助以便用这种方式协作,
但是, 你有多少次听到你最喜欢的科技公司或是大型开源项目成员有吹嘘他们的 Scrum 流程有多NB?
保持精益过程,
直到你知道你需要更多;
相信你的团队,他们能交付成果;</p>
<h3 id="18-软件工程师和所有人一样需要有主人翁精神"><a class="header" href="#18-软件工程师和所有人一样需要有主人翁精神">18. 软件工程师和所有人一样,需要有主人翁精神</a></h3>
<p>如果你将某人从他们的工作成果小分离出来,
他们就会更彡关心他们的工作;
我认为这几乎是必然的;
这是跨职能团队作的如此出色,
以及 DevOps 变得如此流行的主要原因;
这不仅仅是关于交接和效率低下,
而是关于从头到尾拥有整个过程, 并且是直接的负责交付价值;
让一群充满激情的人完全拥有设计/构建和交付软件(或任何东西)的权利,
惊人的事情就会发生;</p>
<p>(译注: 当然, 得是有意义的事务, 为领导一些幻想去努力很难有什么主人翁精神能触发)</p>
<h3 id="19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值"><a class="header" href="#19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值">19. 面试对于告诉某人将成为团队成员有多赞,几乎毫无价值</a></h3>
<p>面试最好花在了解某人是谁,
以及他们对特定专业领域的兴趣程度上;
试图推测他们将成为多么优秀的团队成员是徒劳的;
相信我,
一个人有多聪明或是多博学也不能很好的证明他们将成为一名优秀的团队成员;
没有人会在面试中告诉你他们不可靠/爱辱骂/自负或是从不准时参加会议;
人们可能会声称他们对这些事情有&quot;信号&quot;...
&quot;如果他们在第一面试时询问请假,那么他们永远不会去请假!&quot;
但是, 这些都是废话;
如果你使用这种信号, 只是在猜测并拒绝优秀的候选人;</p>
<h3 id="20-始终努力构建一个更小的系统"><a class="header" href="#20-始终努力构建一个更小的系统">20. 始终努力构建一个更小的系统</a></h3>
<p>有很多力量促使你预先构建更大的系统;
预算分配, 无法测定应该精减哪些功能,
希望提供系统的&quot;最佳版本&quot;;
所有,这些事情都非常有力的推动我们构建更多;
你应该阻止这个;
你在构建一个系统时学到了很多东西,
你最终将迭代到一个比你最初设计的系统更好的版本;
令人惊讶的必须,
这对太多数人来说是难以接受的;</p>
<h2 id="你的故事呢"><a class="header" href="#你的故事呢">你的故事呢?</a></h2>
<p>这是全部了, 20年的软件生涯提炼出来的的20条精辟断言;</p>
<p>如果有什么能引发你的共鸣,
我很很听听;
我也很想知道你在职业生源中积累的智慧并愿意分享出来;
请在评论中留言吧;</p>
<h2 id="refer-11"><a class="header" href="#refer-11">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p>很有人不同意所有观点: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/#comment-142472">January 25, 2023 at 7:25 pm</a></p>
<h3 id="hard-disagree-with-most-of-the-20-items"><a class="header" href="#hard-disagree-with-most-of-the-20-items">Hard disagree with most of the 20 items.</a></h3>
<ol>
<li>
<p>Writing software is difficult, tedious and needs real work. No silver bullet libraries, no methodology, no framework, no IOT, no amount of unit tests will get the work done faster.</p>
</li>
<li>
<p>Developers collect tools, libraries and pet technologies and make projects go over their time and budget by doing it.</p>
</li>
<li>
<p>Code should encapsulate algorithms and not be structured other wise. Code should follow the business logic and be readable and match business requirements easily.</p>
</li>
<li>
<p>Forgetting history keeps the productivity and industry down. Microsoft re-discovering the same old technology which existed on 1960s mainframes for the 7th time just to sell products, trademark buzzwords, training, certification and everything is an anchor around the modern developer’s neck. Think file transfer -&gt; X12 -&gt; serial communication -&gt; raw socket packets -&gt; corba -&gt; xml soap -&gt; xml http -&gt; Rest JSON http -&gt; gRpc as a 50 year journey of rediscovering the same thing repeatedly, each not really that much better than the older technologies, wrapping mounds of interlarded crud on top of fragile, hard to program libraries and the square peg in a round hole mismatch.</p>
</li>
<li>
<p>Refusing to hold W3C and large tech companies accountable for not fixing web HTTP, HTML, CSS and JavaScript for 25+ years.
– How can I create a control which has HTML, CSS, JS which has encapsulated CSS, encapsulated HTML, encapsulated JS without a 10,000 file framework?
– How to match HTML DOM elements with JS without using quoted magic strings? Quoted magic strings were proven anti-productivity and anti-quality in the 1960s
– How to have a UI without the everything is a call back and function pointer? Function pointers with modern wrappings are just as bad as the 1060s computed jump to function tables</p>
</li>
<li>
<p>Forgetting that tech is a business with a 7 year hype cycle, with the new thing being embryonically hyped for 2 years by cutting edge bloggers, then 2 years by sales marketing of companies, then 3 years of disappointment for companies trying to implement it. Followed by, abandonment when the ROI does not work out. Resume driven development, just for business persons.
And yes, there’s a new hype every 2 years to waste time and money on</p>
</li>
<li>
<p>Not holding tech companies accountable when they release major products, .net core, which have less than a 5 year full support lifecycle. Long term support .net is under 3 years.
That is a forced upgrade every 3 years for every .net system just to pass the IT auditors at a large company</p>
</li>
<li>
<p>Devaluing your own worth and work as a developer by telling everyone that the proposed product/task is easy. Software dev is hard work, less than 1 of a 1000 people can even do it poorly.
I would not go to a brain surgeon that told everyone that what he does is easy.</p>
</li>
<li>
<p>Forgetting that software development is a hard, tedious, isolated job where people desiring lots of human interaction will rapidly leave the field by their own choice and lots of people not getting into the field by their own choice.</p>
</li>
<li>
<p>Not telling people that you as a developer have to say “No, it’s too expensive” or “No, it’s too risky” as a regular part of your job. Persons not developing software treating you poorly with career ending consequences just because you won’t accept the death march cross to bear of impossible requirements of an impossibly short deadline</p>
</li>
<li>
<p>Not helping your fellow developers out. Speak well of your co-developers, team, and industry. Don’t downplay the difficulty, complexity or contribution of software.</p>
</li>
<li>
<p>Not calling people out when they think that more data, metrics for everything will automatically solve problems. Ask for a business case, ask for the questions they want to answer (in written form), get the business case and questions they want to answer from the requestor, make sure they are approved before committing to a tight deadline</p>
</li>
<li>
<p>Not damaging the next developer on your project – too many technologies, framework of the month, just another nuget package, one more class, have another 3 patterns, data on disk, data in database structure and consistency is not important and, yes, this system will never receive/send upstream/downstream data</p>
</li>
<li>
<p>Accepting code without parameter checking, error handling or in-line comment documentation (<em>cough</em> vendor’s happy path ‘doc’ page or <em>cough</em> signature only documentation with no example code or error handling.)</p>
</li>
<li>
<p>Misguided acceptance that best practices are best and not just a short nicely sized blog entry. Best practices, in many cases, do not scale for large 1,000,000+ line of code systems and make maintenance harder.</p>
</li>
<li>
<p>Not challenging the ‘more technology is better’ approach</p>
</li>
</ol>
<h2 id="logging-10"><a class="header" href="#logging-10">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230201 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="希望一早知道的关键概念"><a class="header" href="#希望一早知道的关键概念">希望一早知道的关键概念</a></h1>
<p>原文: <a href="https://rauljordan.com/rust-concepts-i-wish-i-learned-earlier/">rauljordan::blog</a></p>
<h2 id="快译"><a class="header" href="#快译">快译</a></h2>
<p>过去一个月里, 我被 Rust 语言彻底迷住了,
因为,她在编写内存安全的现代程序方面具有独特的优势.
多年以来, 有几种语言已经成为工程师编写弹性后端软件的首选语言.
潮流已经从 JAVA/C++ 转向 Go 和 Rust,
她们结合了数十年编程语言理论来构建我们这个时代最需要的工具.</p>
<p>Rust 的地位不言则明.
作为最受一欢迎的语言, 连续7年度在著名 <code>stack overflow</code> 调查中排名第一!
最近还作为 Linux 内核的一部分发布 -- 这是除 C 之外任何语言之前都无法作到的壮举.
对我而言, 这门语言令人兴奋的地方在于,
她在软件构建艺术方面提供了一些真正新颖的东西.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;
use std::{collections::VecDeque, sync::Condvar, sync::Mutex};

fn main() {
    let queue = Mutex::new(VecDeque::new());

    thread::scope(|s| {
        let t = s.spawn(|| loop {
            let item = queue.lock().unwrap().pop_front();
            if let Some(item) = item {
                dbg!(item);
            } else {
                thread::park();
            }
        });

        for i in 0.. {
            queue.lock().unwrap().push_back(i);
            t.thread().unpark();
            thread::sleep(Duration::from_secs(1));
        }
    })
}</code></pre></pre>
<p>Rust 在整个系统编程中获得了令人难以置信的使用, 
也因难以学习而闻名. 尽管如此, 还是有很多优秀的 Rust 内容可以满足初学者和高级程序员的需求.
然而, 他们中太多人专注解释语言的核心机制和所有权概念, 而不是构建应用程序.</p>
<p>作为一名编写高并发程序并专注在系统编程的 Go 开发者, 
我在学习如何使用 Rust 构建真实程序的过程中遇到了很多障碍. 
也就是交织, 如果我将当前正在从事的工作移植到 Rust 中, 那么所有这些教程的效果如何呢?</p>
<p>此篇文章旨在介绍我进入 Rust 兔子洞的经历, 
以及我希望一些学习资源可以更好阐述的内容. 
对个人而言, 我无法通过简单的观看 youtube 视频来学习一门新语言, 
而是必须通过为自己寻找解决方案,犯错以及对过程感受谦卑来积累．</p>
<h3 id="关于参考"><a class="header" href="#关于参考">关于参考</a></h3>
<p>Rust 中有两种引用, 共享引用(也称为 <code>借用</code>)和可变引用(也称为<code>独占引用</code>).
通常这些被视为变量 x 上的 &amp;x 以及 &amp;mut x . 
一旦我开始将后者称为&quot;独家参考&quot;, 这两白间的区别就更有意义了.</p>
<p>Rust 的参考模型相当简单. 借款人可以根据需要拥有对某对象的尽可能多的共享引用, 
但是, 一次只能有一个独占引用. 
否则, 你可能会有很多调用者同时尝试对同一个值进行修改的囧境;
如果很多借用者也可以持有独占袭用, 
你将面临未定义行为风险, 
而安全的 Rust 则不允许这么折腾.</p>
<p>在学习 Rust 时, 都用 &amp;mut 独家参考可以节省很多时间:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo {
    x: u64,
}

impl Foo {
    /// Any type that borrows an instance of Foo can
    /// call this method, as it only requires a reference to Foo.
    pub fn total(&amp;self) -&gt; u64 {
        self.x
    }
    /// Only exclusive references to instances of Foo
    /// can call this method, as it requires Foo to be mutable.
    pub fn increase(&amp;mut self) {
        self.x += 1;
    }
}

let foo = Foo { x: 10 };
println!(&quot;{}&quot;, foo.total()) // WORKS.
foo.increase() // ERROR: Foo not declared as mut
<span class="boring">}</span></code></pre></pre>
<h3 id="双向引用是可以的"><a class="header" href="#双向引用是可以的">双向引用是可以的</a></h3>
<blockquote>
<p>Bidirectional references are possible</p>
</blockquote>
<p>在其它具有垃圾收集功能的语言中, 很容易定义图形数据结构或其它包含对某些子项引用的类型, 
并且这些引用可以包含对其父项的引用;
在 Rust 中, 如果不完全理解借用规则, 这是很难作到的;
但是, 仍然可以使用标准库提供的正法.</p>
<p>假设我们有一个名为 Node 的结构, 
包含一组对子节点的引用, 以及一个对父节点的引用; 
通常, Rust 会抱怨, 但是, 我们可以通过将父引用包装在称为 <code>弱指针</code> 的东西中来满足借用检查器的要求;
这种类型告诉 Rust 一个节点消失, 或者其子节点消失, 不应该意味着父节点也应该被删除;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::{Rc, Weak};

struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这为我们提供了构建双向引用的便利原语; 
然而, 我很快发现在 Rust 中构建图形数据真的很难, 
除非你真的知道自己在作什么, 考虑到一个人需要围绕有效建模数据来作大量的 <code>book-keeping</code> 工作以满足编译器.</p>
<p>(是也乎: 编译器作为 Rust 生态中最大的 BOSS 必须优先满足.)</p>
<h3 id="实施-deref-令代码更清晰"><a class="header" href="#实施-deref-令代码更清晰">实施 Deref 令代码更清晰</a></h3>
<blockquote>
<p>Implement Deref to make your code cleaner</p>
</blockquote>
<p>有时我们希望将包装器类型视之为其包含的内容;
对于常见的数据结构(比如 vec),智能指针(例如 Box) 甚至引用计数类型(类似 Rc 和 Arc) 都是如此;
标准库包含称为 Deref 和 DerefMut 的特征, 
她们将报时你告诉 Rust 应该如何取消引用一个类型;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Deref, DerefMut};

struct Example&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Deref for Example&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.value
    }
}

impl&lt;T&gt; DerefMut for Example&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.value
    }
}

let mut x = Example { value: 'a' };
*x = 'b';
assert_eq!('b', x.value);
<span class="boring">}</span></code></pre></pre>
<p>上述示例代码中, 我们可以将 <code>*x</code> 视为其基础值 <code>&quot;a&quot;</code>, 
甚至可以改变它, 因为, 我们定义了应该如何在借用或可变引用中取消引用的规则;
这很强大, 也是你无需担心在 Box 等智能指针中包装类型的原因;</p>
<p>值被装箱的事实是一个实现细节, 可以通过这些特征抽象出来;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    value: u64,
}
let mut foo = Box::new(Foo { value: 10 });

// Box implements DerefMut, so this will work fine!
*foo = Foo { value: 20 };
// Dot methods will work on foo because Box implements Deref.
// We do not have to worry about the implementation
// detail that Foo is boxed.
assert_eq!(20, foo.value);
<span class="boring">}</span></code></pre></pre>
<h3 id="小心实现-deref-类型方法"><a class="header" href="#小心实现-deref-类型方法">小心实现 Deref 类型方法</a></h3>
<blockquote>
<p>Be careful with methods on types that implement Deref</p>
</blockquote>
<p>有没有想过, 为什么像 <code>Arc::clone</code> 这类方法的存在, 
而我们只能对 Arc 值执行 <code>.clone()</code>?
原因和类型如何实现 Deref 有关, 
这是开发者应该警惕的事儿;</p>
<p>考虑以下示例, 我们正在尝试从标准库中实现我们自己版本的
多生产者/单一消费者(mpsc)通道:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex, Condvar};

pub struct Sender&lt;T&gt; {
    inner: Arc&lt;Inner&lt;T&gt;&gt;,
}

impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;mut self, t: T) {
        ...
    }
}

impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // ERROR: Does not know whether to clone Arc or inner!
            inner: self.inner.clone(),
        }
    }
}

struct Inner&lt;T&gt; {
    ...
}

impl&lt;T: Clone&gt; Clone for Inner&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>上述示例中, 我们有一个要在其上实现 Clone 特征的 Sender 类型;
该结构有一个名为 inner 的字段, 其类型为 <code>Arc&lt;Inner&lt;T&gt;&gt;</code> ;
回想一下 Arc 已经实现了 Clone 和 Deref ;
最重要的是, 我们的 Inner 还现实了 Clone ;
对于上面的代码, Rust 并不知道我们是要克隆 Arc 还是实际的内部值,
所以, 上面代码会失败;
在这种情况下, 我们可以使用 Arc 从 sync 包中提供的实际方法;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // Now Rust knows to use the Clone method of Arc instead of the
            // clone method of inner itself.
            inner: Arc::clone(&amp;self.inner),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="理解何时以及何时不用内部可变性"><a class="header" href="#理解何时以及何时不用内部可变性">理解何时以及何时不用内部可变性</a></h3>
<blockquote>
<p>Understand when and when not to use interior mutability</p>
</blockquote>
<p>有时, 你需要在代码中使用 Rc 或是 Arc 等结构, 
又或者实现包装一些数据结构, 然后, 又想要改变被包装的数据;
很快, 编译器就会告诉你, 内部可变性是不允许的, 乍看起来这很棘手;
然而, 有一些方法允许 Rust 中的内部可变性, 
甚至是由标准库提供的;</p>
<p>最简单的一种是 Cell, 她为你提供数据的内可变性;
也就是说, 嘦数据复制成本低, 
你就可以在 Rc 中改变数据;
你可以通过将数据包装在 <code>Rc&lt;Cell&lt;T&gt;&gt;</code> 中来实现这一点;
她提供了 get 和 set 方法,
甚至不需要被 mut , 因为, 她们是在底层复制数据的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// impl&lt;T: Copy&gt; Cell&lt;T&gt;
pub fn get(&amp;self) -&gt; T

// impl&lt;T&gt; Cell&lt;T&gt;
pub fn set(&amp;self, val: T)
<span class="boring">}</span></code></pre></pre>
<p>其它类型, 比如 RefCell 有助于将某些借用检查移至运行时, 并跳过一些编译器的严格过滤;
然而, 这是有风险的, 因为, 如果没有完成借用检查, 就可能在运行时触发 panic ;
将编译器当成朋友, 你会获得回报;
通过跳过编译器检查, 或是将她们推迟到运行时, 
等于告诉编译器&quot;相信我 --- 我作的都是正确的&quot;;</p>
<p>而 std::cell 包甚至通过一个很有帮助的消息警告我们:</p>
<pre><code>
更常见的继承可变性, 其中必须具有唯一访问权限才能改变值,
这一语言元素是令 Rust 能强力推理指针别名, 静态防止崩溃错误的关键;
因此, 继续可变性是首选, 内部可变性是最后的手段;
由于 Cell 类型可以在不允许突变的地方启用突变, 
因此, 在某些情况中, 内部可变性也许是合适的, 甚至必须使用, 例如:

- 在不可变事物的&quot;内部&quot;引入可变性
- 逻辑不可变方法的实现细节
- 克隆的变异实现

</code></pre>
<h3 id="get-和-get-mut-方法是一回事儿"><a class="header" href="#get-和-get-mut-方法是一回事儿">get 和 get mut 方法是一回事儿</a></h3>
<blockquote>
<p>Get and get mut methods are a thing</p>
</blockquote>
<p>很多类型, 包含 vec 都实现了 get 与 get_mut 方法,
让你可以借用和改变结构中的元素
(前者只有在你有一个对集会的可变引用时才可能);
我花了一段时间, 才知道这些选项可用于许多数据结构,
她们通过更轻松的编写干净的代码, 帮助我的生活更轻松!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut [0, 1, 2];

if let Some(elem) = x.get_mut(1) {
    *elem = 42;
}
assert_eq!(x, &amp;[0, 42, 2]);
<span class="boring">}</span></code></pre></pre>
<h3 id="拥抱不安全但合理的代码"><a class="header" href="#拥抱不安全但合理的代码">拥抱不安全但合理的代码</a></h3>
<blockquote>
<p>Embrace unsafe but sound code</p>
</blockquote>
<p>作为一名 Go 开发者, &quot;unsafe&quot; 包总是感觉很不靠谱,
而且我很少接触;
然而, Rust 中 “unsafe” 的概念是完全不同的;
事实上, 很多标准库都使用 <code>“unsafe”</code> 来取得巨大成功!</p>
<p>这怎么可能? 尽管 Rust 使未定义的行为成为不可能,
但是, 这不适用于标记为 “unsafe” 的代码块;
相反, 编写 “unsafe” Rust 的开发者嘦保证其使用合理,
即可获得所有好处;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Example taken from the Rustonomicon
fn item_at_index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt; arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>嘦你能证明你的 API 是可靠的,
就接受 unsafe, 但是, 要避免逈你的消费者暴露 unsafe 函数,
除非是真正有保证的;
出于这个原因, 在 Rust 中,对你的包内部进行严格控制,
可以证明 unsafe 代码块是合理的了;</p>
<p>通常在性能绝对重要的情况下, 才使用 unsafe,
或者当你知道使用 unsafe 代码块是解决问题的简单方法,
并且可以证明代码的可靠性时;</p>
<p>(<code>是也乎:</code></p>
<p>安全和可靠分离, 那么, 什么是可靠呢?</p>
<p>)</p>
<h3 id="尽可能用-impl-类型作为参数而不是通用约束"><a class="header" href="#尽可能用-impl-类型作为参数而不是通用约束">尽可能用 impl 类型作为参数而不是通用约束</a></h3>
<p>这点来自 Golang, 我认为特征可以一直简单的作为函数参数来提供;
比如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Meower {
    fn meow(&amp;self);
}

struct Cat {}

impl Meower for Cat {
    fn meow(&amp;self) {
        println!(&quot;meow&quot;);
    }
}

// ERROR: Meower cannot be used as it does not have
// a size at compile time!
fn do_the_meow(meower: Meower) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>...但是,上述代码失败了,
因为, trait 对象在编译时没有 Rust 完成工作需要的内存尺寸;
我们可以通过添加 <code>&amp;dyn Meower</code> 来告诉编译器这是动态调整大小来绕过,
但是, 很快我了解到这不是 <code>rusty</code>/锈范儿 解决方案;
相反,开发者倾向于衖受特征约束的通用参数,
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow&lt;M: Meower&gt;(meower: M) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>...现在能通过编译了;
然而,随着函数越来越复杂, 如果我们还包括其它通用参数,
就可能会有一个非常难以阅读的函数声明;
在此示例中,如果我们只想用一次 meow,
那么, 实际上并不需要动用泛型;
我们甚至于并不关心 meow 的结果,
所以, 可以改写为这样:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow(meower: &amp;impl Meower) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>这样告诉编译器:&quot;我只想要实现 Meow 的东西&quot;;
当然,这正是我们需要的,
并且,首先不需要函数的通用返回类型时,
此模式会更加清晰;</p>
<h3 id="用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有"><a class="header" href="#用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有">用 iter() 过程中想借用时, iter mut() 用以独占 refs,而 into iter() 支持拥有</a></h3>
<p>很多教程立即跳转到使用下面的 into_iter 方法来迭代 vectors/向量:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let items = vec![1, 2, 3, 4, 5];
for item in items.into_iter() {
    println!(&quot;{}&quot;, item);
}
<span class="boring">}</span></code></pre></pre>
<p>然而,当我们刚刚开始在结构中使用这个迭代器方法时,
很多初学者(包括作者自己)都碰壁了,例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: Vec&lt;u32&gt;,
}

impl Foo {
    fn all_zeros(&amp;self) -&gt; bool {
        // ERROR: Cannot move out of self.bar!
        self.bar.into_iter().all(|x| x == 0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>并立即提示:</p>
<pre><code>    error[E0507]: cannot move out of `self.bar` which is behind a shared reference
       --&gt; src/main.rs:9:9
        |
    9   |         self.bar.into_iter().all(|x| x == 0)
        |         ^^^^^^^^ ----------- `self.bar` moved due to this method call
        |         |
        |         move occurs because `self.bar` has
        |         type `Vec&lt;u32&gt;`, which does not implement the `Copy` trait

</code></pre>
<p>作为菜鸟尝试了很多办法后, 才意识到 <code>.into_ter()</code> 取得了集合的所有权,
这不是我的目标所需要的;
相反, 在迭代器上还有另外两种有用的方法, 真希望当时能早点知道丫们;</p>
<p>第一个是 <code>.iter()</code> ,借用集合, 让你断言关于其值的东西,但是, 不拥有或是改变她们;
再有就是 <code>iter_mut()</code> 帮助你改变集合内部值,嘦你是唯一的exclusive reference/独占参考;</p>
<p>总之, 当你只需要借用时用 <code>.iter()</code>,
当你想要获得所有权时用 <code>.into_iter()</code>,
当你需要改变迭代对象的元素时用 <code>.iter_mut()</code>;</p>
<h3 id="phantom-数据不仅仅用以处理指向类型的原始指针"><a class="header" href="#phantom-数据不仅仅用以处理指向类型的原始指针">Phantom 数据不仅仅用以处理指向类型的原始指针</a></h3>
<p>当你第一次遇到 Phantom data/幻数据时,
一定感觉很奇怪,但是, 很快就会成为一种告诉编译器&quot;拥有&quot;某个值的好方式,
尽管只有一个指向她的原始指针;
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Foo&lt;'a, T: 'a&gt; {
    bar: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这儿告诉编译器 Foo 拥有 T,
尽管只有一个指向她的原始指针;
这对于需要处理原始指针和使用 unsafe Rust 的应用程序很有帮助;</p>
<p>但是, 也可以是一种告诉编译器你的类型还没实现 Send 或是 Sync 特征的方法!
你可以使用 PhantomData 包装以下类型,并在你的结构中使用她们,
来作为一种方式告诉编译器你的结构即不是 Send 也不是 Sync;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type PhantomUnsync = PhantomData&lt;Cell&lt;()&gt;&gt;;
pub type PhantomUnsend = PhantomData&lt;MutexGuard&lt;'static, ()&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="用-rayon-实现并行增量"><a class="header" href="#用-rayon-实现并行增量">用 rayon 实现并行增量</a></h3>
<p>有时, 你希望在遍历集会时并行化工作,
但是, 在处理线程和确保类型可以安全的跨线程发送时却碰壁了;
有时, 如果额外的样板文件令你的代码几乎不可读,那就已经不值得了;</p>
<p>相反, 有一个名为 Rayon 很赞的包, 已经提供了以无缝方式并行化计算的上好工具;
例如,假设我们有一个计算数组平方和的函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>由于乘法和加法的性质, 上述代码绝对可以并行化,
Rayon 通过让我们自动访问数组等集会的&quot;并行迭代器&quot;,
使并行化变得微不足道;
这是几乎零样板的代码;
而且也完全不影响可读性:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Importing rayon prelude is what gives us access to .par_iter on arrays.
use rayon::prelude::*;

fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    // We can use par_iter on our array to let rayon
    // handle the parallelization and reconciliation of
    // results at the end.
    input.par_iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>工程中如果自己要构造各种内部库,
也值得给出这种使用界面,
和以往使用内置库的代码完全兼容,
只是在关键节点处替换为自己魔改/加强过的...
)</p>
<h3 id="开发-rust-库时理解-拓展特征-的概念"><a class="header" href="#开发-rust-库时理解-拓展特征-的概念">开发 Rust 库时理解 拓展特征 的概念</a></h3>
<p>那么 Rayon 是如何以如此干净的方式完成上述工作的呢?
答案在于&quot;拓展特征&quot;,
这些特征可以定义为对其它特征的拓展,
例如 Iterator;
也就是说,我们可以逈通常实现 Itertor 特征的项追加其它有用的函数,
但是, 她们只有在特性范畴以内时才可用,
比如通过将其导入文件中;</p>
<p>这种方式非常好,因为,这些特征只有在你在项目中导入拓展特征时才可用,
并提供了一种使用干净的 API 拓展通用集合和类型的好方法,
开发者可以像使用普通 API 一样轻松的使用这些 API;
由于 Rayon 的拓展特征,
使用并行迭代器就像在 Rust 中使用普通迭代器一样简单;</p>
<p>事实上,这有一个信息量很大的演讲,解释了如何使用 拓展特征 来开发一个在迭代器上提供进度条的库;</p>
<p>(<code>是也乎</code>:</p>
<p><a href="https://www.youtube.com/watch?v=bnnacleqg6k">&quot;Type-Driven API Design in Rust&quot; by Will Crichton - YouTube</a></p>
<p>配套看看 Rayon 官方对自己实现原理的嗯哼: <a href="https://github.com/rayon-rs/rayon/tree/master/src/iter/plumbing">rayon/src/iter/plumbing at master · rayon-rs/rayon</a>
以及专门的解析文章: <a href="https://developers.redhat.com/articles/2023/01/30/run-app-under-openshift-service-mesh">How Rust supports Rayon's data parallelism | Red Hat Developer</a></p>
<p>大约可以感受到 Rust 世界的任性了...
)</p>
<h3 id="拥抱-option-和-result-类型的一元性"><a class="header" href="#拥抱-option-和-result-类型的一元性">拥抱 Option 和 Result 类型的一元性</a></h3>
<p>使用 Option 和 Result 之后,
人们会很快看到<code>.unwrap()</code> 将值从她们移出,
如果 Option 和 Result 是共享引用(比如 struct)的一部分,
就将导致失败;
然而,有时我们想要的只是断言 Option 匹配内部的值或获取对其内部的引用;
有很多方法可以作到这点,
但是, 还有一种方式能不用离开 Option 领域:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_five(x: Option&lt;i32&gt;) -&gt; bool {
    // Contains can just check if the Option has what we want.
    x.contains(&amp;5)
}
<span class="boring">}</span></code></pre></pre>
<p>另一个示例是我们想要用 None 值替换 Option 内数据,
也就是和某些结构交互时;
我们可以用指令式编程的方式来编写,
并按照以下方式详细完成:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    data: Option&lt;T&gt;,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    // Takes the value of data and leaves None in its place.
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.data.is_none() {
            return None;
        }
        let value = self.data.unwrap();
        self.data = None;
        value
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然而, Option 有一些非常酷的属性,
因为, 她们的基本性质是定义了有用的方法,
可以让我们的生源更加轻松;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Takes the value of data and leaves None in its place.
fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.data.take()
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 中的 Option 以函数式编程语言中相同的范例为模型,
属于更广泛的数据类型类别, 称为 Monad;
不用深入理解 Monad 是什么, 而嘦将其视为数据的包装器,
我们可以在不需要从中取出东西的情况下对其进行操作;
比如, 想象一个将两个 Option 内部值相加并返回一个 Option 的函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if x.is_none() || y.is_none() {
        return None;
    }
    return Some(x.unwrap() + y.unwrap());
}
<span class="boring">}</span></code></pre></pre>
<p>上述代码看起来有点点笨拙,因为,需要执行 none 检验,
而且我们必须从两个 Option 中提取值并从中构建一个新 Option 就很囧;
然而, 由于 Option 的特殊属性,
我们可以作的更好!
这是我们可以获得的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    x.zip(y).map(|(a, b)| a+b)
}
<span class="boring">}</span></code></pre></pre>
<p>可以对 option 使用 zip 和 map ,
就像我们可以处理数组和向量一样;
此属性也存在于 Result 类型中,
甚至存在于诸如 <code>Future</code> 类型之类事物中;
如果你对为什么这么作感到好奇,
请继续挖掘 Monad 的更多信息 -&gt; <a href="https://stackoverflow.com/questions/2704652/monad-in-plain-english-for-the-oop-programmer-with-no-fp-background">functional programming - Monad in plain English? (For the OOP programmer with no FP background) - Stack Overflow</a></p>
<p>接受 Option 和 Result 类型的一元性质,
不要到处使用 unwrap 和 if x.is_none() {} else ;
本身就包含了很多有用的方法,
你可以在标准库中阅读这些方法;</p>
<p>(<code>是也乎:</code></p>
<p>所以, 标准库的通读是一个基本功了,
不过, 相比 Python 等其它语言的官方文档,
docs.rs 实在太麻了点儿,还要习惯一下;</p>
<p>)</p>
<h3 id="了解-drop-应该如何针对不同数据结构实现"><a class="header" href="#了解-drop-应该如何针对不同数据结构实现">了解 Drop 应该如何针对不同数据结构实现</a></h3>
<p>标准库将 Drop 特性描述为:</p>
<p>当不再需要某个值时, Rust 将对该值运行&quot;析构函数&quot;;
不再需要某个值最常见方式是超出作用域;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>在 Rust 中编写数据结构时, Drop 是至关重要的;
人们必须有一种合理的方法来处理一旦不再需要内存时如何丢弃(安全的);
使用引用计数类型可以报时你克服这些障碍,
但是, 这并不总是足够的;
例如,编写自定义链表或是编写使用通道的结构时,通常要实现自定义版本的 Drop;
当你看到标准库实际如何执行时,
实现 Drop 比并看起来容易的多:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// That's it!
fn drop&lt;T&gt;(t: T) {}
<span class="boring">}</span></code></pre></pre>
<p>巧妙利用失去作用域时销毁的规则,
<code>std::mem::drop</code> 有一个空函数体!</p>
<p>这是一个技巧, 你可以在自己的自定义 Drop 实现中使用,
嘦你涵盖所有基类?即可;</p>
<h3 id="真的对借用检查员很气-那就用不可变数据结构"><a class="header" href="#真的对借用检查员很气-那就用不可变数据结构">真的对借用检查员很气? 那就用不可变数据结构</a></h3>
<p>函数式程序员喜欢说全局的/可变的状态是万恶之源,
如果可以避免,那毛还要使用呢?
多亏了 Rust 的函数式结构,
我们才能构建从一开始就不可能突变的结构结构!
当你需要编写类似在 Haskell/OCaml 或其它语言中看到的纯粹函数式代码时,
这尤其有用;</p>
<p>通过链接列表综合教程中的示例,
我们可以看到如何构建一个不可变列表,其中节点有引用计数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }
    ...
<span class="boring">}</span></code></pre></pre>
<p>这就很赞,因为,其行为类似于函数式数据结构,
在函数式数据结构中,
人们不会通过追加前缀来修改列表,
而是通过以新元素作为其头部和现有列表作为尾部来构建列表完成新构建;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    [head] ++ tail
<span class="boring">}</span></code></pre></pre>
<p>请注意,上述方法都不需要 mut, 因为,我们的数据结构是不可变的!
这在内存上也是非常高效的,因为,该结构是引用计数的,
这意味着如果此数据结构上有多个调用者,
我们不会浪费不必要的资源来复制节点的底层内存;</p>
<p>Rust 中的纯函数代码很简洁,
但是,多数时候,需要尾递归来了把用我快这种方式实现的高性能代码；
而且，要小心，毕竟 Rust 编译器不保证尾调用优化；
值得进一步挖掘更多信息 -&gt; <a href="https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust">When is tail recursion guaranteed in Rust? - Stack Overflow</a></p>
<p>(<code>是也乎:</code></p>
<p>这就尴尬了, 只是个看起来很美的思路,
毕竟 Rust 不是纯函数语言,
递归并不是第一公民;</p>
<p>所以, 这种场景中,还是老实和 借用管理员 好好商量吧...</p>
<p>)</p>
<h3 id="traits-篮有助减少重复"><a class="header" href="#traits-篮有助减少重复">traits 篮有助减少重复</a></h3>
<p>有时,可能希望通过很多不同的特征来约束泛型参数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T: Copy + Clone + Ord + Bar + Baz + Nyan&gt; {
    vals: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>但是,一旦你开始编写 impl 语句,
或是当你有多个通用参数时,
这很快就会失控;
相反你可溶性定义一个整体特征, 使代码更加 DRY;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Fooer: Copy + Clone + Ord + Bar + Baz + Nyan {}

struct Foo&lt;F: Fooer&gt; {
    vals: Vec&lt;F&gt;,
}

impl&lt;F: Fooer&gt; Foo&lt;F&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<p>traits 篮可以帮助减少重复，
但是，不要让其变得过大；
在很多情况中，
让一个类型需要如此多的约束可能会产生坏味道,
因为,你创建的抽象太大了;
相反,如果你发现约束无缘无故的变得太大,
请传入具体类型;
然而,某些应用和远又可能受益于 blanket traits/特征篮,
例如旨在提供尽可能通用的 API 库;</p>
<h3 id="match-语句本质上很灵活和结构化的"><a class="header" href="#match-语句本质上很灵活和结构化的">Match 语句本质上很灵活和结构化的</a></h3>
<p>例如,可以将值作为元组组合在一起并执行以下操作,而不是嵌套匹配语句:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player_outcome(player: &amp;Move, opp: &amp;Move) -&gt; Outcome {
    use Move::*;
    use Outcome::*;
    match (player, opp) {
        // Rock moves.
        (Rock, Rock) =&gt; Draw,
        (Rock, Paper) =&gt; Lose,
        (Rock, Scissors) =&gt; Win,
        // Paper moves.
        (Paper, Rock) =&gt; Win,
        (Paper, Paper) =&gt; Draw,
        (Paper, Scissors) =&gt; Lose,
        // Scissor moves.
        (Scissors, Rock) =&gt; Lose,
        (Scissors, Paper) =&gt; Win,
        (Scissors, Scissors) =&gt; Draw,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个示例足以说明为什么模型匹配比指令式语言中的 switch 语句更强大,
而且, 在劳模内部值方面可以作的更多.</p>
<h3 id="如果匹配对象是有限且已知的嫑使用-_--子句"><a class="header" href="#如果匹配对象是有限且已知的嫑使用-_--子句">如果匹配对象是有限且已知的,嫑使用 _ =&gt; 子句</a></h3>
<p>例如,我们有个枚举:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
    Nyan,
    Zab,
    Azb,
    Bza,
}
<span class="boring">}</span></code></pre></pre>
<p>在编写 match 语句时,如果可能的话, 应该匹配枚举的所有类型,而不是求助于 catch-all 子句:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match f {
    Bar =&gt; { ... },
    Baz =&gt; { ... },
    Nyan =&gt; { ... },
    Zab =&gt; { ... },
    Azb =&gt; { ... },
    Bza =&gt; { ... },
}
<span class="boring">}</span></code></pre></pre>
<p>这对代码维护非常有帮助,因为,如果枚举的原始编写者逈其追加更多变体,
如果我们忘记在匹配语句中处理新变体, 功能将无法编译;</p>
<h3 id="match-保护条款也很强大"><a class="header" href="#match-保护条款也很强大">Match 保护条款也很强大</a></h3>
<p>当你有未知或是可能无限数量的匹配项时(例如数字范围),
匹配守卫就很棒;
然而, 如果你的范围不能被守卫完全包含时,
将迫使你使用一个包罗万象的 <code>_ =&gt;</code>,
这在编写可维护代码时可能就是一个缺点;</p>
<p>Rust 书中典型示例如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Temperature {
    Celsius(i32),
    Fahrenheit(i32),
}

fn main() {
    let temperature = Temperature::Celsius(35);
    match temperature {
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        Temperature::Celsius(t) =&gt; println!(&quot;{}C is below 30 Celsius&quot;, t),
        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
    }
}</code></pre></pre>
<h3 id="需要搞乱原始汇编嘛-有一个宏"><a class="header" href="#需要搞乱原始汇编嘛-有一个宏">需要搞乱原始汇编嘛? 有一个宏!</a></h3>
<p>core asm 提供了一个闳, 可以让你在 Rust 中编写内联汇编语句,
这在折腾一些花哨的事情时很有帮助,
比如直接拦截 CPU 的堆栈,
或是想要实现高级优化;</p>
<p>这是一个示例,我们使用内联汇编通过简单的将堆栈指针移动到用来欺骗处理器的堆栈来执行我们的函数!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::arch::asm;

const MAX_DEPTH: isize = 48;
const STACK_SIZE: usize = 1024 * 1024 * 2;

#[derive(Debug, Default)]
#[repr(C)]
struct StackContext {
    rsp: u64,
}

fn nyan() -&gt; ! {
    println!(&quot;nyan nyan nyan&quot;);
    loop {}
}

pub fn move_to_nyan() {
    let mut ctx = StackContext::default();
    let mut stack = vec![0u8; MAX as usize];
    unsafe {
        let stack_bottom = stack.as_mut_ptr().offset(MAX_DEPTH);
        let aligned = (stack_bottom as usize &amp; !15) as *mut u8;
        std::ptr::write(aligned.offset(-16) as *mut u64, nyan as u64);
        ctx.rsp = aligned.offset(-16) as u64;
        switch_stack_to_fn(&amp;mut ctx);
    }
}

unsafe fn switch_stack_to_fn(new: *const StackContext) {
    asm!(
        &quot;mov rsp, [{0} + 0x00]&quot;,
        &quot;ret&quot;,
        in(reg) new,
    )
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>所以说, 无法嵌入内联 汇编代码 的语言, 都不算系统语言?</p>
<p>等等, Python 好象也可以哪...
)</p>
<h3 id="使用-criterion-对代码及其吞吐量进行基准测试"><a class="header" href="#使用-criterion-对代码及其吞吐量进行基准测试">使用 Criterion 对代码及其吞吐量进行基准测试</a></h3>
<p>用来对 Rust 代码进行基准测试的 Criterion 是一项了不起的工程作品;
能帮助你使用图形/回归分析和其它奇怪的工具来访问令人敬畏的基准测试功能;
甚至可以用来衡量函数的不同维度,例如时间和吞吐量;
又比如, 我们可以看到在不同的直方图中,使用标准库的迭代器方法构造/获取和收集原始字节的速度有多快;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter;

use criterion::BenchmarkId;
use criterion::Criterion;
use criterion::Throughput;
use criterion::{criterion_group, criterion_main};

fn from_elem(c: &amp;mut Criterion) {
    static KB: usize = 1024;

    let mut group = c.benchmark_group(&quot;from_elem&quot;);
    for size in [KB, 2 * KB, 4 * KB, 8 * KB, 16 * KB].iter() {
        group.throughput(Throughput::Bytes(*size as u64));
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &amp;size| {
            b.iter(|| iter::repeat(0u8).take(size).collect::&lt;Vec&lt;_&gt;&gt;());
        });
    }
    group.finish();
}

criterion_group!(benches, from_elem);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<p>将以下条目追加到项目的 Cargo,toml 文件中,
就可以用 cargo bench 运行了:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.3&quot;

[[bench]]
name = &quot;BENCH_NAME&quot;
harness = false
</code></pre>
<p>criterion 不仅可以向你展示非常棒的图表和描述性信息,
而且,还能记住基准测试运行的先前结果,
告诉你性能回归状态;
在这种情况中,我在运行基准测试的同时, 还能用计算机作很多其它事儿,
所以, 也能自然的通报从上次测量后退化了多少;
总之,非常的COOL!</p>
<pre><code>    Found 11 outliers among 100 measurements (11.00%)
      2 (2.00%) low mild
      4 (4.00%) high mild
      5 (5.00%) high severe
    from_elem/8192          time:   [79.816 ns 79.866 ns 79.913 ns]
                            thrpt:  [95.471 GiB/s 95.528 GiB/s 95.587 GiB/s]
                     change:
                            time:   [+7.3168% +7.9223% +8.4362%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-7.7799% -7.3407% -6.8180%]
                            Performance has regressed.
    Found 3 outliers among 100 measurements (3.00%)
      2 (2.00%) high mild
      1 (1.00%) high severe
    from_elem/16384         time:   [107.22 ns 107.28 ns 107.34 ns]
                            thrpt:  [142.15 GiB/s 142.23 GiB/s 142.31 GiB/s]
                     change:
                            time:   [+3.1408% +3.4311% +3.7094%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-3.5767% -3.3173% -3.0451%]
                            Performance has regressed.
</code></pre>
<h3 id="通过阅读标准库来理解关键概念"><a class="header" href="#通过阅读标准库来理解关键概念">通过阅读标准库来理解关键概念!</a></h3>
<p>我喜欢徜徉在标准库中,尤其是 std::rc, std::iter, and std::collections;
以下是我自己从中学习到的一些很赞的技巧:</p>
<ul>
<li>vec 是如何切实实现的</li>
<li>通过 std::cell 和 std::rc 中的不同方法, 实现内部可变性的方式</li>
<li>如何在 std::sync 中实现通道</li>
<li>std::sync::Arc 的魔力</li>
<li>了解 Rust 作者对开发对应库时,如何作出设计决策的详尽解释</li>
</ul>
<p>有希望这篇文章能为进入 Rust 并遇到一些障碍的人们提供可用信息;
期待更多 Rust 内容能推出,
尤其是关键更高级主题的...</p>
<h3 id="shoutout"><a class="header" href="#shoutout">Shoutout</a></h3>
<p>感谢 Offchain Labs 同事 Rachel 和 Lee Bousfield 对这门语言的广泛了解;
他们的一些技巧启发了这篇文章;</p>
<h2 id="refer-12"><a class="header" href="#refer-12">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/">Rust Bug Minimization Patterns - The {pnk}f(eli)x Blog</a></li>
<li><a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></li>
<li><a href="https://github.com/sger/RustBooks#advanced-books">sger/RustBooks: List of Rust books</a>
<ul>
<li><a href="https://veykril.github.io/tlborm/decl-macros/macros2.html">Macros 2.0 - The Little Book of Rust Macros</a></li>
<li>...</li>
</ul>
</li>
</ul>
<h2 id="logging-11"><a class="header" href="#logging-11">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230120 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧"><a class="header" href="#技巧">技巧</a></h1>
<blockquote>
<p>tips...重要也不重要</p>
</blockquote>
<h2 id="background-11"><a class="header" href="#background-11">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>刚刚开始感觉哪儿哪儿都要有技巧, 其实不一定...</p>
<h2 id="goal-9"><a class="header" href="#goal-9">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>将一头合格 Rustaceans 值得记忆的基本技巧,
收集到 42% 左右...</p>
<h2 id="trace-9"><a class="header" href="#trace-9">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>???</p>
<h2 id="refer-13"><a class="header" href="#refer-13">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h3 id="gpts"><a class="header" href="#gpts">GPTs</a></h3>
<blockquote>
<p>通用任务</p>
</blockquote>
<ul>
<li>ChatGPT 相关
<ul>
<li>ChatGPT for StackOverflow (https://stackoverflow.gg/) 查看 ChatGPT 对 StackOverflow 上每个问题的回复，甚至是未回答的问题</li>
<li>ChatGPT Detector (https://huggingface.co/spaces/Hello-SimpleAI/chatgpt-detector-single) 判断文本是否是AI生成</li>
</ul>
</li>
<li>poe (https://quorablog.quora.com/Poe-1) quora出品的对话式AI工具</li>
<li>tweetmonk (https://tweetmonk.com/) AI帮你打理社交网络</li>
</ul>
<blockquote>
<p>开发任务</p>
</blockquote>
<ul>
<li>README 生成器 (https://readme.rustc.cloud/zh) 用AI生成完整的GitHub readme</li>
</ul>
<blockquote>
<p>设计任务</p>
</blockquote>
<ul>
<li>图像:
<ul>
<li>Galileo AI (https://www.usegalileo.ai/) 用AI设计生成UI设计</li>
<li>animeai (https://animeai.app/) AI生成漫画风格图片</li>
<li>autodraw (https://www.autodraw.com/) AI辅助绘画</li>
<li>latentlabs (https://www.latentlabs.art/) 根据文本生成 360 度全景图</li>
<li>playgroudai (https://playgroundai.com/) 获取AI绘图提示词，帮助你编辑图片</li>
<li>stockimg (https://stockimg.ai/) AI设计图标</li>
</ul>
</li>
<li>声音:
<ul>
<li>image-to-sound-fx (https://huggingface.co/spaces/fffiloni/image-to-sound-fx) 图片转换为相对应的声音内容</li>
<li>MetaVoice Studio (https://studio.themetavoice.xyz/) AI声音编辑平台</li>
</ul>
</li>
<li>视频:
<ul>
<li>invideo (https://invideo.io/ai/) 根据文本生成视频</li>
<li>murf (https://murf.ai/) AI生成真人演讲视频</li>
<li>tosummary (https://tosummary.com/) 利用AI提取书籍、YouTube视频摘要</li>
</ul>
</li>
</ul>
<blockquote>
<p>办公任务</p>
</blockquote>
<ul>
<li>文档:
<ul>
<li>周报生成器 (https://weeklyreport.avemaria.fun/zh) 简单描述工作内容，帮你生成完整周报</li>
<li>email-helper (https://email-helper.vercel.app/) AI帮你写邮件</li>
<li>campbell (https://review.gobudapest.io/) AI生成评语</li>
<li>penlope (https://penelopeai.com/) AI辅助markdown编辑器</li>
</ul>
</li>
<li>大纲:
<ul>
<li>bearly (https://bearly.ai/) AI帮助你阅读、创作，撰写，提高你的工作效率</li>
<li>humata (https://app.humata.ai/signin) 利用AI来分析论文内容</li>
</ul>
</li>
<li>docuchat (https://www.docuchat.io/) 上传文档，AI回答对应的问题</li>
</ul>
<h2 id="logging-12"><a class="header" href="#logging-12">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-运算符重载六件趣事"><a class="header" href="#rust-运算符重载六件趣事">Rust 运算符重载六件趣事</a></h1>
<p>原文: <a href="https://wishawa.github.io/posts/fun-rust-operators/">Six fun things to do with Rust operator overloading | Wisha Wanichwecharungruang</a></p>
<p><img src="https://wishawa.github.io/posts/fun-rust-operators/dot-product-pooh.jpg" alt="dot-product-pooh" /></p>
<h2 id="快译-1"><a class="header" href="#快译-1">快译</a></h2>
<h3 id="c-输入出"><a class="header" href="#c-输入出">C++ 输入/出</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stdin().read_line(&amp;mut buffer).unwrap();
println!(&quot;Hello I am {name}!!!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>可以重载 cin 和 count 上的移位运算符来达成:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cin &gt;&gt; &amp;mut buffer;
cout &lt;&lt; &quot;Hello I am &quot; &lt;&lt; name &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>看起来意义更加不明了了?
)</p>
<h3 id="可变函数"><a class="header" href="#可变函数">可变函数</a></h3>
<p>想替代</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::cmp::max(x, y);
[w, x, y, z].into_iter().max();
<span class="boring">}</span></code></pre></pre>
<p>可以搞成:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// max+ is like std::cmp::max but better
// it supports &gt;2 arguments
max+(x, y);
max+(w, x, y, z);
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>内置标准库太丰富了...简直必须要有一个信仰过程</p>
<p>)</p>
<h3 id="更简洁的构建器"><a class="header" href="#更简洁的构建器">更简洁的构建器</a></h3>
<p>这是一个更严重的问题;
构建器模式有时涉及大量重复的方法调用;
以 warp web 框架的这种用法为例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
    .and(warp::path::param())
    .and(warp::header(&quot;user-agent&quot;))
    .map(|param: String, agent: String| {
        format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
    });
<span class="boring">}</span></code></pre></pre>
<p>如果 API 看起来像这样呢?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
	+	warp::path::param()
	+	warp::header(&quot;user-agent&quot;)
	&gt;&gt;	|param: String, agent: String| {
			format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
		};
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>等等, 这就是语法糖了吧?
)</p>
<h3 id="中缀函数"><a class="header" href="#中缀函数">中缀函数</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.pow(y);
dot_product(a, b);
a.cross(b.cross(c).cross(d))
<span class="boring">}</span></code></pre></pre>
<p>我们可以这么来:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x ^pow^ y;
a *dot* b;
a *cross* (b *cross* c *cross* d);
<span class="boring">}</span></code></pre></pre>
<p>很多人就想要这个!</p>
<p>(<code>是也乎:</code></p>
<p>嗯哼? 的确流畅很多哪...
)</p>
<h3 id="doublefish"><a class="header" href="#doublefish">Doublefish</a></h3>
<p>std::mem 提供有这些功能:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val(&amp;value);
<span class="boring">}</span></code></pre></pre>
<p>Turbofish 爱好者会喜欢 size_of,
但是对 size_of_val 没什么感觉;
所以, 我们可以自行改造出新版本的 size_of_val ,
看起来更象 turbofishy:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val&lt;&lt;&amp;value&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h3 id="join-和-race"><a class="header" href="#join-和-race">Join 和 Race</a></h3>
<p>特性组合器可能具有短路行为能力;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// quit if any of the 3 errors
(fut1, fut2, fut3).try_join().await;

// quit if any of the 3 succeeds
(fut4, fut5, fut6).race_ok().await;
<span class="boring">}</span></code></pre></pre>
<p>可以通过 &amp; 和 | 在形式上表达出这点:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(TryJoin &gt;&gt; fut1 &amp; fut2 &amp; fut3).await;
(RaceOk &gt;&gt; fut4 | fut5 | fut6).await;
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>这是从形式上和语义同步了.
)</p>
<h2 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h2>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/10golkq">Discuss this on Reddit</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=71da59351b0988249a69014e6b191353">Playground</a> containing the implementations behind some of the code shown here</li>
<li><a href="https://doc.rust-lang.org/std/ops/index.html">std::ops docs</a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">Rust operators precedence table</a></li>
</ul>
<h2 id="refer-14"><a class="header" href="#refer-14">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-13"><a class="header" href="#logging-13">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230125 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-超越面向对象第1部分"><a class="header" href="#rust-超越面向对象第1部分">Rust 超越面向对象,第1部分</a></h1>
<p>原文: <a href="https://www.thecodedmessage.com/posts/oop-1-encapsulation/">Rust Is Beyond Object-Oriented, Part 1: Intro and Encapsulation :: The Coded Message</a></p>
<h2 id="快译-2"><a class="header" href="#快译-2">快译</a></h2>
<p>是的, Rust 不是一种 OOP 编程语言;</p>
<p>Rust 可能看起来像一种 OOP 编程语言:
类型可以和 &quot;“methods&quot; 关联,
可以是 &quot;intrinsic&quot; 的或是通过 &quot;traits&quot;;
通常可以使用 C++ 或是 Java 风格的 OOP 语法调用方式:
map.insert(key, value) 或 foo.clone();
就像在 OOP 语言中一样,
此语法涉及放置在调用者的 <code>.</code> 中, 而在被调用者中称为 self;</p>
<p>但请不要误会: 尽管 Rust 可能借用了一些技巧/术语和语法,
但是, Rust 并不是一种面向对象的编程语言;
面向对象编程的三大支柱理念: 封装/多态/继承;
其中, Rust 完全否决了 继承,
因此, 永远不可能成为&quot;真正的&quot; OOP 语言;
不过, 即便对于封装和多态, Rust 实现的方式也和 OOP 语言不同 --- 稍后将对此进行更加详细的介绍;</p>
<p>这一切都让很多程序员感到惊讶以及无措;
我在 Reddit 上看到 Rust 新手询问如何按字面意思实现 OOP 设计模式,
试图获得像“shapes” 或是 “vehicles”这种&quot;类层次结构&quot;,
使用作为&quot;Rust 版本继承&quot;的 traits --- 换句话说, 
试图解决他们想象中的问题, 
因为, 他们致力于 OOP 方法, 并通过构建人为的 OOP 示例来尝试了解他们期待的应该存在的另外一个版本 Rust;</p>
<p>这对很多人来说是一个绊脚石;
我经常看到 Rust 新手和怀疑论者在互联网上提到&quot;缺乏OOP&quot;,
这是 Rust 难以适应/不合适他们的关键原因,
甚至是 Rust 永远不会流行的原因;
对于那些在 OOP 的高度来学习编程的人来说 --- 当像 C 和 ML 那样完美的语言都必须变成 Object-C 和 OCaML 这种面向对象的语言 --- 
对非 OOP 语言的大量炒作感觉就不太香了;</p>
<p>这也不是一个容易的调整;
如此多的程序猿以明确的面向对象的方式学习软件设计和体系结构;
我看到一个又一个问题,
一个初级或中级 Rust 程序员想要作一个面向对象的事儿,
并想要一个字面上的 Rust 等价物;
通常, 这些都是经典的 &quot;XY 问题&quot; (原文:<a href="https://xyproblem.info/">XY problem</a>, 酷壳有精采的翻译:<a href="https://coolshell.cn/articles/10804.html">X-Y Problem | 酷 壳 - CoolShell</a>)案例, 他们很难调头用更 Rusty 的方式解决问题;</p>
<p>这其实都不是 Rust 的错;
答案还是要我们去调整,
虽然不容易;
我们要成为更好的程序员, 不仅精通多种语言,
而且要精通不同的编程范式;</p>
<p>而且, 作为一种范式, OOP 实际上非常平庸 --- 以至于我写了一整篇文章来解释为什么,
以及为什么 Rust 的方法更好;</p>
<h3 id="面向对象思想"><a class="header" href="#面向对象思想">面向对象思想</a></h3>
<blockquote>
<p>OOP Ideology</p>
</blockquote>
<p>嗯哼,好象明白了;
我曾经是自己主动变成 OOP 信徒的;
还记得当年是如何向我们收费的:
不仅仅是一套代码组织实践,更加是编程方面的一场革命;
OOP 方法被认为更直观,尤其对非程序员而言, 因为更加符合我们对自然世界的看法;</p>
<p>对于这种营销的典型示例, 以下是流行杂志(Byte Magazine, 1981年)中关于 OOP 第一篇公开文章的摘录:</p>
<hr />
<blockquote>
<p>许多不知道计算机如何工作的人发现 OOP 想法很自然;
相比之下, 反而是很多有计算机经验的人最初认为 OOP 系统有些奇怪...</p>
</blockquote>
<hr />
<p>为 OOP 买帐很容易;
当然, 我们的日常生源没有任何子程序或是变量之类的东西 --- 或者,
即便有, 我们也没有明确的考虑它们!
但是, 生活中确实有我们可以与之交互的对象, 每个对象都有自己的功能;
怎么可能不直观呢?</p>
<p>这是非常引人注目的伪认知科学,轻研究,重说服力;
这些 object/对象 可以认为是 &quot;agents&quot;, 几乎象人一样,
所以, 你可以利用你的社交技能来处理它,
而不仅仅是分析性思维
(嫑介意 object/对象 的行为一点儿也不像人,而且,实际上在某种程序上更加笨,
这时仍然需要分析思维);
或是, 你可以将对象和类视为形式世界本身的近乎柏拉图式的表达, 使其在哲学上引人注目;</p>
<p>哦, 当年我是如何接受的? 尤其是在肆意鲁莽的青年时期；
我个人吸收了 OOP 和柏拉图之间的联系;
深入研究了元对象协议, 
以及在 Smalltalk 中每个类都必须有一个元类的事实;
Smalltalk 代码元类的概念对我来说几乎是神秘的,
因为, 任何值都可以组织在同一层次结构中,
对象反而位于其根部;</p>
<p>我赢得在一本书中读到 OOP 风格的多态使得 if-else 语句变得多余,
因此,我们应该努力最终只使用 OOP 风格的多态;
不知何故, 这没让我失望, 这让我当时很兴奋;
而且,当我了解到 Smalltalk 实际正是这样作的,
就更加兴奋了
(如果你忽略优化掉某些抽象的实现细节):
在 Smalltalk 中, if-than-else 的概念是通过 ifTrue: 和 ifElse: 以及 ifTrue:ifFalse: 等方法实现的,
还得配套单实例的 True 和 False 类,以及其全局对象 true 和 false;</p>
<p>(译按: 光是听起来就非常,嗯哼? 这不是一样的东西嘛?)</p>
<p>作为一名更成熟的程序员,接触到意识形态较少的 C++ OOP 以及 Haskell 中的函数式编程替代方案后,
我的立场就软化了, 然后, 发生了巨大转变, 现在我几乎不再是 OOP 的脑残粉,
尤其是当其最佳思想已经在 Haskell 和 Rust 中进行了更新综合;
我已意识到这种对新程序员的炒作对于任何范式都是典型的(FUD ~ Fear/Uncertainty/Doubt, 意为:懼、惑、疑, 现在统称为 PUA 技术);
对于新手来说, 任何新编程范式都来了使用不同范式的资深程序员更加直观;
函数式编程也是如此;
甚至对于 Rust 也有同样的说法;
其实和范式是否更好并无太大的关系;</p>
<p>至于 if-else 语句完全用多态来替换,
好吧, 很容易想出一组图灵完备的元语;
你不邕为用多态来模拟 if 语句以及 true;
你还可以模拟带有递归的 shile 循环,
又或是带有 while 循环和堆栈的递归；
你可以使用 while 循环模拟 if 语句;</p>
<p>这些事实都不能使用这种替代成为一个好主意;
对于不同的情况, 编程语言中存在不同的特性,
适度的对应使用, 实际上原本就是一件好事情;</p>
<p>毕竟,编程的目的是编写程序, 而不是证明图灵完备性/哲学研究又或是写概念诗;</p>
<p>(译按: 不过, 现实中的确有这类研究僧, 主要社会贡献就是制造新概念哪...)</p>
<h3 id="实用性"><a class="header" href="#实用性">实用性</a></h3>
<blockquote>
<p>Practicality</p>
</blockquote>
<p>因此, 在这个系列文章中, 我打算从实际角度评估 OOP,
作为一名程序猿, 在使编程语言在认知上更易于管理或是更容易进行抽象方面具有经验;
我将根据我解决实际编程问题的经验来进行评估 --- 我认为这是种不好的迹象,
很多 OOP 抽象如何工作的案例只有在真正高级的程序中才有意义,
或是关于动物园中不同类型的形状或是动物的人为例子才有意义;</p>
<p>和大多数 OOP 介绍不同, 我不会关注 OOP 和 OOP　之前的编程语言的比较；
相反, 我将主要和 Rust 进行比较,
Rust 从 OOP 中汲取了很多好想法,
也许还会和函数式编程语言(比如 Haskell)进行比较;
这些编程语言采纳了 OOP 的一些好想法,
但是, 都以一种修复缺陷并进一步超越的姿态, 对合理的 OOP 进行了改造;</p>
<p>我将根据面向对象编程的三个传统支柱: 封装/多态和继承来组织这种比较,
第一篇将重点放在封装上;
对于每个支柱, 将讨论 OOP 如何定义, 以及在 OOP 世界之外存在哪些等价物或是替代品,
以及这些在实际易用性和编程能力方面进行对比;</p>
<p>不过,在开始之前,想先谈谈一个用例, 这个用例曾颠覆过大部分内容: 图形用户界面或是说 GUI;
尤其是在浏览器时代之前,
编写 GUI 程序以便直接在台式机(或笔记本电脑)上运行,
是程序员工作的主要部分;
OOP 的许多早期开发是和 Xerox PARC 的图形用户界面研究一起完成的,
OOP 非常适合该用例;
因此, 值得优先考虑 GUI;</p>
<p>例如, 人们通常会在其它编程语言中模拟 OOP;
GTK+ 就是一个很好的例子,
将 OOP 实现为 C 中一系列宏和约定;
这样作的原因有很多,包括熟悉 OOP 设计和希望创建某种运行时的多态;
但是,根据我的经验, 这在实现 GUI 框架时最为常见;</p>
<p>在本系列文章中, 主要关注将 OOP 应用在其它用途的场景,
但是,也会酌情讨论 GUI;
在这个介绍性部, 我仅指出 GUI 框架在传统 OOP 设计和编程语言之外显然是可能的,
甚至于在 Rust 中也是如此;
有时, GUI 可以通过完全不同的机制工作,
例如主要在 Haskell 中开创性的功能响应式了渔的哪, 我个人更加喜欢传统的基于 OOP 的编程,
而传统的 OOP 功能对此却并没有什么帮助;</p>
<p>现在, 事不宜迟, 让我们从实用角度, 逐一比较 OOP 和 Rust 以及其后各种 OOP 编程语言;
对于首篇文章, 其余部分将重点关注封装;</p>
<h3 id="第一支柱-封装-encapsulation"><a class="header" href="#第一支柱-封装-encapsulation">第一支柱: 封装/ Encapsulation</a></h3>
<p>在面向对象编程中, 封装和类的概念密切相关,
类是面向对象编程中的基本抽象层;
每个类都包含一些记录数据的格式/布局,
即, 每个实例包含一定数量字段的数据结构;
记录类型的单个实例称为&quot;对象&quot;;
每个类还包含和该记录类型紧密配对的代码,
组织成称为方法的过程;
核心想法是, 所有字段都只能从方法内部访问,
无论是通过 OOP 意识形态的约定还是通过编程语言的强制规则;</p>
<p>这里的基本好处是 接口/interface ,也就是代码如何和其它代码交互,
或者说你必须知道什么才能使用代码,
比 实现/implementation 要简单的多, 实现/implementation 是代码如何实际完成 的更加流畅变化的细节, 其原本的工作;</p>
<p>但是, 虽然许多编程语言都有这样的抽象;
任何超过十几行的程序就有太多的部分, 无法一次全部反映到你的大脑中,
因此,所有现代编程语言都有将程序划分为更小组件的方法,
作为管理复杂性的一种方式,
接口/interface 总是比 实现/implementation 更加简单,
无论是由编程语言强制执行, 还是&quot;荣誉系统&quot;的问题;
因此, 从广义上玛, 所有现代编程语言都有某种版本的封装;</p>
<p>一种简单的封装形式 --- 太多数面向对象的编程语言将其作为类中的一层来维护 --- 就是过程,
也称为函数/子例程或是(OOP 中的称呼)方法;
现代编程语言不允许任何代码行直接跳转到任何其它代码行,
而是倾向将代码块组合为过程,
然后, 你可以在不影响外部代码的情况下,
更改过程的内容, 并更改外部代码, 同样在不影响程序的情况下,
嘦都遵循相同的 接口/interface 和 契约/contract;</p>
<p>契约/contract 通常至少部分是人类层面的约定;
一般没有什么可以阻止你采用一个应该处理一些数据的过程,
而是让其无限循环或是令程序崩溃;
但是, 其中的一些, 例如过程和程序其余部分的分离, 
以及在许多情况中, 允许在调用中接受和返回的值的数量和类型,
将由编程语言强制执行;</p>
<p>例如,在过程内部声明的变量通常是局部的,
而且没有办法在过程外部引用;
输入和输出通常姴在过程顶部的签名中;
通常, 外部代码只能在第一行进入过程, 而不能在中途的任意一行进入;
某些编程语言(包括 Rust)中, 过程甚至于可以包含其它过程,
这些过程只能在外部过程中调用;</p>
<p>但是,当然现代程序通常比少数用锥程序更复杂;
因此,现代编程语言(再次强调: <strong>&quot;现代&quot;</strong> 一词在这里的使用非常宽松)具有另一层封装抽象:模块;</p>
<p>模块通常包含一组过程,有些可以从外部访问, 有些则不能;
在非 duck 类型语言中, 通常要定义很多聚合类型, 同样是有些可以从外部访问,有些不行;
通常甚至于可以抽象的公开这些类型,因此,程序的其余部分可以访问类型的实在,但是不能访问记录字段,
甚至于不能访问是记录类型的事实;
甚至于 C 在其模块系统中也有这种能力 --- 反而是 C++ 没有引入这点, 只是追加了一个额外的/正交级别的逐字段访问控制;</p>
<p>从务实的角度来看,基于类的封装并不是 OOP 的某个特殊见解,
而是一种专门的---或是更确切的说, 严格限制的---模块形式;
在 OOP 编程语言中, 我们有类的概念, 是一种特殊形式的模块
(有时是唯一受支持的形式, 有时甚至于在完全不同的/更加传统的模块概念下分层,以便增加概念上的混淆);
只是,对于一个&quot;类&quot;,通常只能定义一个主要类型, 和模块本身共享一个名称,
而且,该类型的字段被给予特殊保护, 以便防止类外代码的访问;</p>
<p>当然, 类和模块之间还有其它区别,但是,这些和其支柱有关, 我们稍后将论及;
现在我们只讨论和封装相关的 &quot;类&quot; 概念 --- 其中, 类只是具有一种特权抽象类型的特殊模块;</p>
<p>这是一种编写模块的合理方式,但是, 并不像面向对象编程思想所表明的那样特别
(特别是当我们讨论其它支柱的替代方案时,但是,同样稍后再讨论);
在某些情况中,模块没有定义任何记录类型,这在 Java 等编程语言中很尴尬,
无论如何你都必须定义一个空记录类型, 并仍然创建一个 &quot;类&quot;;
在某些情况中, 一个模块定义了多个可以公开访问的类型,
这些类型紧密的纠缠在一起 --- 并且 OOP 风格鼓励你在这些类型之间进行封装, 这样一来更多的阻碍而不是帮助;</p>
<p>从根本上说, 能够对其它模块隐藏记录的字段很重要, 这就是为什么 C 也支持;
甚至对于在 Rust 中实现对不安全特性的安全抽象是必不可少的,
例如集合/collections, 其中原始指针和一同记录的其它字段相结合具有不变量;
但是, 这对 OOP 来说并不陌生,而且, 这并不是每种可能类型的最佳选择;</p>
<p>作为这点的证据,在 Java 和 Smalltalk 中,
在较小程度上甚至在 C++ 或是 Python 中,
坚持每一种类型的封装风格意味着你可以获得这些样板方法,
比如说 setFoo 和 getFoo;
这些方法什么都不作,只是充当一些本质上是哑记录类型的字段访问器;
从理论上说, 如果你想更改设置或是读取这些字段时发生的事情,
这会有所帮助,得是不是, 实际上, 这只是原始字段访问器, 本质上就是 契约/contract 的一部分;
例如, 如果她们改为进行网络调用而不是仅仅返回一个值,
那么对于这种简单命名的方法, 将强烈触发惊喜原则:</p>
<p>说起来要简单的多:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Point {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
<span class="boring">}</span></code></pre></pre>
<p>... 相比俺还是 Java 程序员时惯用的 “JavaBean” 等价物
(Java 从那时起显然发生了变化,
但是, 这代表了很多 OOP 编程琂,包括 Smalltalk 和许多关于如何编程的书籍):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>class Point {
    private double x;
    private double y;
    private double z;

    double getX() {
        return x;
    }

    double setX(double x) {
        this.x = x;
    }

    double getY() {
        return y;
    }

    double setY(double y) {
        this.y = y;
    }

    double getZ() {
        return z;
    }

    double setZ(double z) {
        this.z = z;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>此类数据类型通常不使用 OOP 类获得的任何其它功能,
例如多态或是继承;
在此类 “JavaBean” 类中使用此类功能也将违反最小意外原则;
&quot;类&quot;概念对于这些记录类型来说,根本就是矫枉过正;</p>
<p>当然, Java 开发者(或是 Smalltalk 又或 C#) 会说,
应该通过这些 getter 和 setter 方法间接访问字段, 他们是面向未来的类,
以防设计发生变化
(事实上我是当 Reddit 上有人提出这点时,才被提醒到, 追加了这段);
但是,我发现这是虚伪的,
或者蕛是被误导的 --- 它通常用于程序内部结构的一部分,
在这种情况中, 更加合理的作法是向结构所有用户公开更改字段;
除了字面意义上的设置或是获取字段之外，
也很难想到这些方法还可以作什么不足为奇的事儿，
正如方法名称所暗示的那样 --- 例如,
进行网络调用对于获取或是设置方法来说,
将是一个令人震惊的惊喜,
并且,因此至少违反了隐含的协约;
在我编写 OOP 代码时,
我从来没见过适合 getter 或是 setter 执行任何操作的情况,
除了字面上的获取或是设置字段;</p>
<p>如果代码确实更改为要求 getter 或是 setter 执行其它操作,
我宁愿更改方法的名称以便反映具体还作了什么,
而不是假装这不是重大变更;
fetchZFromNetwork 或是 setAndValidateZ 似乎比 getZ 或是 setZ 更加合适,
它们所作的事儿, 比我们假设 setter 或是 getter 所作的简单字段访问到的更多;
OOP 坚持每个类型都应该是其自己的代码抽象边界,
这在应用这些轻量级聚合类型时, 常常就变的荒谬了;
这些类型的 getter 和 setter 用以保护不应该存在且哪小得小妨碍的抽象边界,
并且,在未来防止在不更改接口的情况中,
不应该进行的实现变更;</p>
<p>setter 和 setter 简而言之,
是一种反模式;
如果你打算创建除 &quot;数据结构&quot; 之外的抽象,
其中验证或是网络调用又或原始字段访问之外的任何其它内容加班是合适的,
那么这些 get 和 set 名称就是该抽象的错误名称;</p>
<p>2023-02-13 追加了此段:
明确的说, 这些异议也适用于属性;
我反对的不是语法上的不便,
而是使用代码透明的替换字段访问的整个概念是一件值得努力的好事,
或者是保持开放的重要可能性;
有希望 foo.bar = 3 永远不会在 Rust 中触发进行网络调用!
如果这必须是异步的呢?
如果我在调用函数,应该很清楚;
而 Rust 是关于明确性的思考成果;</p>
<p>实际上, get 和 set 函数仅用作包装器以便满足 OOP 思想的约束;
领导作用称提供的面向未来的证明是一种幻想;
如果你在抽象边界上提供“JavaBean”样式类型或是具有属性的类型,
那么你实际上就像提供原始字段访问一样被锁定 --- 你最有可能希望对这些结束进行的更改不允许移动 getter 和 setter 以保持兼容性;
对于你想要进行的更改,
利用这种面向未来的方法可能是完全不可能的,
充其量会涉及可怕的骇客攻击;</p>
<p>在所有这些方面, Rust 似乎和 OOP 语言相同;
从表面上看, 又和类非常相似;
你可以定义和给定类型关联的函数 --- 它们甚至于被称为方法!
和 OOP 方法一样,
在语法上优先采用该类型的值
(或是对这些值的引用)作为第一个参数,
称为特殊名称 self;
你甚至于可以将记录类型(在 Rust 中称为结构)的字段标记为公共或
(默认情况下)私有,
就像在面向对象的编程语言中一样鼓励私有字段;</p>
<p>根据这个支柱, Rust 似乎非常接近 OOP;
对于这个支柱来说, 这是个公平的评估,
也是一个有意的选择,目的是让习惯了 C++
(或是 Java 又或 JavaScript) OOP 编程日常语法的人们更容易使用
Rust 编程;</p>
<p>但是, 相似之处只是肤浅的;
封装其实是 OOP 中最不明显的支柱
(毕竟, 所有现代编程语言都有某种形式的封装),
Rust 中的实现不受类型约束;
当你在 Rust 中声明一个字段私有时(通过不指定 pub),
这并不意味着对其方法私有,
这只是意味着对模块私有;
一个模块可以提供多种类型,
并且该模块中的任何函数, 无论是否是该类型的&quot;方法&quot;,
都可以访问该类型中定义的所有字段;
在适当的时候鼓励传递记录,
而不是鼓励访问者被强制访问,
即便在紧密绑定的相关代码中也是如此;</p>
<p>这是我们看到 Rust 的第一个迹象,
尽管语法很简洁, 但是, 并不是一种 OOP 编程语言;</p>
<p>This is the first sign we see that Rust, in spite of its superficial syntax, is not an OOP programming language.</p>
<h3 id="接下来"><a class="header" href="#接下来">接下来</a></h3>
<p>在这点上, 今天不得不暂停一下;</p>
<p>当然, 封装并不是 OOP 风格类所能作的唯一奇特的事儿;
如果是这样, 那么类就不会迷惑这么多人这么多年了:
每个人都会明白,类不过是美化的模块,
而方法不过是美化的过程;</p>
<p>在本系列下篇文章中,
我们将讨论和 OOP 相关的其它特性,
OOP 剩下的两大传统支持,
多态和继承,
从实践的角度分析,
并了解 Rust 和 OOP 在性能方面的比较, 针对那些支柱概念;</p>
<p>接下来将是 多态!</p>
<h2 id="logging-14"><a class="header" href="#logging-14">logging</a></h2>
<ul>
<li>230225 ZQ v1 done</li>
<li>230220 ZQ re-start</li>
<li>230215 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-超越面向对象第2部分"><a class="header" href="#rust-超越面向对象第2部分">Rust 超越面向对象,第2部分</a></h1>
<p>原文:<a href="https://www.thecodedmessage.com/posts/oop-2-polymorphism/">Rust Is Beyond Object-Oriented, Part 2: Polymorphism :: The Coded Message</a></p>
<h2 id="快译-3"><a class="header" href="#快译-3">快译</a></h2>
<p>在这篇文章中, 通过讨论 OOP 三大传统支柱中的第二个: 多态,
继续系列文章:关于 Rust 和传统 OOP 范式的不同;</p>
<p>多态性是面向对象编程中的一个特别重要的话题，
也许是其三大支柱中最重要的一个;
关于多态性是什么, 各种编程语言如何实现(在 OOP 世界内外---是的,多态性也存在于 OOP 宇宙之外),
如何有效的使用, 以及更加关键的何时嫑使用;
可以写一些关于如何单独使用多态的 Rust 版本的书了;</p>
<p>不幸的是, 这只是一篇 blog,所以,
我无法像我想的那样详细或是多样性的介绍多态;
相反,我将特别关注 Rust 和 OOP 概念的不同之处;
我将从描述其在 OOP 中的工作方式开始,
然后, 讨论如何在 Rust 中实现相同的目标;</p>
<p>在 OOP 中,多态性就是一切;
试图采取所有决策(或是尽可能多的决策)并将其统一在一个通用的狭义机制中:
运行时多态;
但是, 不幸的是, 并不是任意运行时多态, 而是一种特定的/狭义的运行时多态形式,
受到 OOP 哲学和实现如何工作细节的限制:</p>
<ul>
<li>间接需求: 每个对象通常都必须存储在堆上,才能使运行时多态生效, 因为,不同的&quot;运行时类型&quot;具有不同的尺寸; 这鼓励了可变对象的别名使用;不仅如此,要真正调用一个方法,必须穿过三层间接:
<ul>
<li>解引用对象引用</li>
<li>解引用类指针或是 “vtable” 指针</li>
<li>最后完成间接函数调用</li>
</ul>
</li>
<li>排斥优化: 除了间接函数调用的内在成本之外, 调用是间接的这一事实, 意味着内联是不可能的；通常,多态方法很小,甚至于微不足道,例如返回常量/设置字段或是重新排列参数并调用另一个方法, 因此, 内联会很有用; 内联对于允许优化跨内联边界也很重要;</li>
<li>仅能在单一参数上多态: 特殊的接收者参数,称为 self 或是 this, 是运行时多态也的并上通常可能通过的唯一参数; 其它参数的多态可以用那些类型中的辅助方式来模拟, 这就很尴尬, 而且, 返回类型的多态也是不可能的;</li>
<li>每个值都是独立多态的: 在运行时多态中, 通常没有办法说集合的所有元素都属于实现相同接口/interface 的某种类型 T,但是, 该类型是什么又应该在运行时能确定;</li>
<li>和其它 OOP 特性纠缠在一起: 在 C++ 中,运行时多态和继承紧密耦合；　在很多 OOP 语言中, 多态仅适用于类的类型, 正如我在上篇 blog 中讨论的那样, 类类型是一种受约束的模块形式;</li>
</ul>
<p>其实我完全可以针对以上每条吐糟单独写一大篇文章 --- 也许有一天真的会;</p>
<p>不过,尽管有这么多限制, 多态仍然被视为使用 OOP 语言进行决策的首选方式,
并且, 特别直观且易于访问;
受过训练的程序员, 嘦可能就一定使用此工具,
无论是否是手上决策是最佳工具, 即便当前不需要用多态进行运行时决策;
有些编程语言,例如 Smalltalk 甚至折叠了 &quot;if-then&quot; 逻辑,
并循环到 this 这个奇怪的特定决策结构中,
通过多态方法(如: ifTrue:idFalse)最终实现,
这些方法将在 True 和 False 类中以不同方式再实现
(和 therefore 在 true 以及 false 对象上配套);</p>
<p>需要明确的是, 拥有基于 vtable 的运行时多态性机制本身并不是一件坏事儿 --- Rust 甚至有也一个
(和上述 OOP 版本相似,但是,并不完全对等);
但是, Rust 版本只用以相对罕见的情况, 在这种情况中,
该机制最适合整个儿 palette 机制;
在 OOP 中, 将这种严格约束且忾和用低下的决策制定形式提升到所有其它形式之上,
以及使用多态是表达程序注释和业务编辑的最佳方式以及最直观方式的哲学断言,
本身就是个问题;</p>
<p>事实证明,当你选择最适合手头情况的工具时, 编程更加吻合人体工程学 --- 而 OOP 运行时多态性,
只是偶尔才是最合适完成当前工作的实效工具;</p>
<p>因此, 让我们看看在 OOP 使用运行时多态性时, 可以使用的 Rust 版四种替代方案;</p>
<h3 id="备选方案0枚举"><a class="header" href="#备选方案0枚举">备选方案#0：枚举</a></h3>
<p>不仅有其它形式的多态性, 而且具有更少的严格约束
(例如 Haskell 的类型类)或一组不同的权衡
(例如 Rust 的 trait,主要基于 Haskell 类型类),
Rust 中还有另外一个决策系统, 即:代数数据类型(ADTs, algebraic data types)
或曰求合/sum 类型,
也能接管 OOP 样式多态的很多应用程序;</p>
<p>在 Rust 中, 这些被称为 枚举/enums;
很多编程语言中的枚举是存储在整数尺寸类型中的常量列表,
有时以类型安全的方式实现(比如在 Java 中),
有时不是(比如在 C 中),
有时可以使用任何一种选项(比如,在 C++ 中枚举和枚举类之间就有区别);</p>
<p>Rust 枚举支持这种熟悉的用例, 而且具有类型安全:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Visibility {
    Visible,
    Invisible,
}
<span class="boring">}</span></code></pre></pre>
<p>但是, 还支持和每个选项关联的附加字段,
创建类型理论中称为&quot;总和类型&quot;(sum type)的东西,
但在 C 或是 C++ 程序员中更加广为人知识的叫&quot;联合标记&quot;(tagged union)
--- 不同之处在于, Rust 中, 编译器知道并能强制执行标记;</p>
<p>以下是一些枚举声明的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum UserId {
    Username(String),
    Anonymous(IpAddress),
    // ^^ This isn't supposed to be a real network type,
    // just an example.
}

let user1 = User::Username(&quot;foo&quot;.to_string());
let user2 = User::Anonymous(parse_ip(&quot;127.0.0.1&quot;)?);

pub enum HostIdentifier {
    Dns(DomainName),
    Ipv4Addr(Ipv4Addr),
    Ipv6Addr(Ipv6Addr),
}

pub enum Location {
    Nowhere,
    Address(Address),
    Coordinates {
        lat: f64,
        long: f64,
    }
}

let loc1 = Location::Nowhere;
let loc2 = Location::Coordinates {
    lat: 80.0,
    long: 40.0,
};
<span class="boring">}</span></code></pre></pre>
<p>你可能会问,这些<code>联合标记</code>和多态有什么关系?
好吧, 大多数 OOP 语言对于这些 求合类型/sum type 没什么好办法,
但是, 她们确实有强大的运行时多态机制,
所以, 你会看到运行时多态用 Rust 枚举实现也是一样的适合
(我可能进一步争辩: 更加合适):
每当有一些小关于如何协商会议值的选项, 但是,这些选项又包含不同细节时;</p>
<p>比如, 这是一种使用继承和运行时多态在 Java 中表示 UserId 类型的方法 --- 当我还是学生时, 
肯定会这么来(将每个类放在不同的文件中):</p>
<pre><code class="language-java">class UserId {
}

class Username extends UserId {
    private String username;
    public Username(String username) {
        this.username = username;
    }

    // ... getters, setters, etc.
}

class AnonymousUser extends UserId {
    private Ipv4Address ipAddress;
    
    // ... constructor, getters, setters, etc.
}

UserId user1 = new Username(&quot;foo&quot;);
UserId user2 = new AnonymousUser(new Ipv4Address(&quot;127.0.0.1&quot;));
</code></pre>
<p>重要的是, 就像在枚举示例中一样,
我们可以将 user1 和 user2 给定相同类型的变量,
并将她们得狮给相同类型的函数, 并通常对她们执行相同的操作;</p>
<p>现在这些 OOP 风格的类看起来轻飘到飞溅的程度,
但是, 这主要是因为我们没有为这种情况添加任何真正的操作代码 --- 只有数据和结构, 
以及一些变量定义和模板;
让我们考虑一下, 如果我们真的对用户 ID 尝试进行任何操作时会怎么样?</p>
<p>例如,我们可能想确认她们是否为管理员;
在我们的假设中, 假设匿名用户永远不是管理员,
而拥有用户名的用户只有在用户名以字符串 admin_ 开头时,才是位管理员;</p>
<p>理论上认可的 OOP 方法是添加一个方法,
比如: administrator;
为了让这个方法起作用, 我们必须将其追加到所有三个类: 基数以及两个子类:</p>
<pre><code class="language-java">class UserId {
    // ...
    public abstract bool isAdministrator();
}

class Username extends UserId {
    // ...
    public bool isAdministrator() {
        return username.startsWith(&quot;admin_&quot;);
    }
}

class AnonymousUser extends UserId {
    // ...
    public bool isAdminstrator() {
        return false;
    }
}
</code></pre>
<p>因此, 为了在 Java 中为这种类型添加这种简单的操作,如此简单的能力,
我们却必须使用三个类,
而且必须存储在三个文件中;
丫们每个对象都包含一个方法来作一些简单的事儿,
但是, 在任何羌族都看不到谁是管理员, 又或者不是管理员的完整逻辑 --- 有人可能会很不合时宜的问出这个问题;</p>
<p>Rust 则为这种操作使用 match,
将有关所有信息放在一个地方完成判定:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_administrator(user: &amp;UserId) -&gt; bool {
    match user {
        UserId::Username(name) =&gt; name.starts_with(&quot;admin_&quot;),
        UserId::AnonymousUser(_) =&gt; false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>诚然, 这将产生更加复杂的单个函数,
但是,具有明确的所有逻辑;
让编辑明显而不是隐含在继承屡次结构中, 
这就违反了 OOP 原则, 
在 OOP 宇宙中, 方法应该简单, 多态性用于隐含的表达逻辑;
但是,这并不能保证任何事儿, 只是将其扫到地毯下而已:
事实证明, 隐藏复杂性会令其更难应对, 而不是相反;</p>
<p>让的我们来看另外一个例子;
我们已经用了一段时间的 UserId 代码,
你的任务是为这个系统编写一个新的 Web 前端;
你需要某种方式, 以 HTML 格式显示用户信息,
要么是指向用户配置文件的链接(对于指定用户),
要么是将 IP 地址字符串化为红色(对于匿名用户);
因此, 你决定为这个小型类型追加一个新操作 toHTML,
将输出新前端的专用 DOM 类型;
(也许 Java 被编译为 WebAssembly 呢? 我也不确定,不过细节不重要;-)</p>
<p>你逈后端核心库深入的 UserId 类屡次结构的维护者提交了 pull request;
然后, 他们拒绝了;</p>
<p>事实上, 他们有很好的理由, 你必须勉强承认;
他们说:&quot;这是一种荒谬的关注点分离&quot;;
此外, 公司也无法从你的前端获得此核心库处理类型;</p>
<p>所以, 你叹了口气, 写了个 Rust 匹配表达式的等价物, 但是用的是 Java
(请原谅我荒谬的假设有个 HTML 库):</p>
<pre><code class="language-java">Html userIdToHtml(UserId userId) {
    if (userId instanceof Username) {
        Username username = (Username)userId;
        String usernameString = username.getUsername();
        Url url = ProfileHandler.getProfileForUsername(usernameString);
        return Link.createTextLink(url, username.getUsername());
    } else if (userId instanceof AnonymousUser) {
        AnonymousUser anonymousUser = (AnonymousUser)userId;
        return Span.createColoredText(anonymousUser.getIp().formatString(), &quot;red&quot;);
    } else {
        throw new RuntimeException(&quot;IDK, man&quot;);
    }
}
</code></pre>
<p>你的老板们在代码审查时拒绝了这段代码,
你你使用了 instanceof 反模式,
但是, 后来在你让他们和不接受你的其它补丁的核心库维护者争论之后,
丫们勉强接受了这段代码;</p>
<p>但是, 看看那坨 instanceof 代码有多难看!
难怪 Java 程序员认为这是一种反模式!
但是, 在这种情况中, 已经是最合理的事儿了,
实际上, 是除了实施观察者东西方或是访问者模式又或是其它相当于基础设施的东西之外,
唯一可能的实现, 只是用来创造具有控制反转的实例而已;</p>
<p>当操作集有界(或是接近有限)并且该类的子类数量可能以意想不到的方式增长时,
通过向每个子类追加一个方法来实现操作是有意义的;
可是,通常情况中, 操作的数量又会以意想不到的方式增长,
而子类的数量总是有限的(又或是接近有限);</p>
<p>对于后一种情况, 这种情况比 OOP 拥护者想象的更加常见,
Rust 枚举 --- 以及一般的 求和类型 --- 是完美的;
一但你习惯了她们, 你就会发现自己一直在使用;</p>
<p>我要郑重声明,
在所有面向对象的编程语言中,都没有这么糟糕;
在某些情况中, 你可以按任何顺序编写任意类方法组合,
因此,如果你愿意, 可以将所有三个实现写在一个地方;
Smalltalk 传统上允许你在一个特殊的浏览器中游览代码库,
你可以在其中看到一个类实现的方法列表,
或者一个接受给定&quot;消息&quot;的类列表,
正如 Smalltalk 所说的那样,
这样你就可以随心所欲的操弄对象了;</p>
<p>(译按: 当然, 你必须在 Salltalk 对应解释器的 IDE 环境中, 一但出了这个对象镜像, 将失去一切观察能力, 这导致 Smalltalk 没办法使用其它传统 IDE)</p>
<h3 id="备选方案-1-闭包"><a class="header" href="#备选方案-1-闭包">备选方案 #1: 闭包</a></h3>
<blockquote>
<p>Alternative #1: Closures</p>
</blockquote>
<p>有时, 一个 OOP 接口或是多态决策只涉及一个实际操作;
在这种情况中,只能使用闭包;</p>
<p>我不想在这方面花太多时间,
因为, 大多数 OOP 程序员已经意识到这点,
并且, 自从他们的 OOP 语言已经赶上了函数式语言,
并获得了 lambda 语法 --- Java 中的 Java 8 ,
C++ 中的, C++11;
因此, 像 Java 的 Comparator 这种愚蠢的单一方法接口 ---
幸运的是 --- 基本上已经都感染过去式了;</p>
<p>此外, Rust 中的闭包在技术上涉及 traits,
因此,使用和接下来的两个替代方案相同的机制来竀,
所以,也有人可能会争辩说这在 Rust 中并不是真正的独立选项;
然而,在我看来 lambda/闭包和
FnMut/FnOnce/Fn 等 trait 们在美学上和情境上都非常特别,
值得花点时间掌握;</p>
<p>因此, 我将花些时时间来说明这点:
如果你发现自己只使用一种方法编写 trait 
(Java 接口或是 C++ 类),
请考虑你是否应该改用某种闭包或是 lambda 类型;
毕竟只有你自己才能防止过度设计;</p>
<h3 id="alternative-2-polymorphism-with-traits"><a class="header" href="#alternative-2-polymorphism-with-traits">Alternative #2: Polymorphism with Traits</a></h3>
<p>Just like Rust has a version of encapsulation more flexible and more powerful than the OOP notion of classes, as I discuss in the previous post, Rust has a more powerful version of polymorphism than OOP posits: traits.</p>
<p>Traits are like interfaces from Java (or an all-abstract superclass in C++), but without most of the constraints that I discuss at the beginning of the blog post. They have neither the semantic constraints or the performance constraints. Traits are heavily inspired in semantics and principle by Haskell’s typeclasses, and in syntax and implementation by C++’s templates. C++ programmers can think of them as templates with concepts (except done right, baked into the programming language from the get-go, and without having to deal with all the code that doesn’t use it).</p>
<p>Let’s start with the semantics: What can you do with traits that you can’t do with pure OOP, even if you throw all the indirection in the world at it? Well, in pure OOP terms, there’s no way you can write an interface like Rust Eq and Ord, given greatly oversimplified definitions here (the real definitions of Eq and Ord extend other classes that allow partial equivalence and orderings between different types, but like these simplified definitions, the Rust standard library version of non-partial Eq and Ord do cover equivalence and ordering between values of the same type):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Eq {
    fn eq(self, other: &amp;Self) -&gt; bool;
}

pub enum Ordering {
    Less,
    Equal,
    Greater,
}

trait Ord: Eq {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p>See what’s happening? Like in an OOP-style interface, the methods take a “receiver” type, a self parameter, of the Self type – that is, of whatever concrete type implements the trait (technically here a reference to Self or &amp;Self). But unlike in an OOP-style interface, they also take another argument of &amp;Self type. In order to implement Eq and Ord, a type T provides a function that takes two references to T. That’s meant literally: two references to T, not one reference to T and one reference to T or any subclass (such a thing doesn’t exist in Rust), not one reference to T and one reference to any other value that implements Eq, but two bona-fide non-heterogeneous references to the same concrete type, that the function can then compare for equality (or ordering).</p>
<p>This is important, because we want to use this to implement methods like sort:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec&lt;T&gt; {
    pub fn sort(&amp;mut self) where T: Ord {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>OOP-style polymorphism is ideal for heterogeneous containers, where each element has its own runtime type and its own implementation of the interfaces. But sort doesn’t work like that. You can’t sort a collection like [3, &quot;Hello&quot;, true]; there’s no reasonable ordering across all types.</p>
<p>Instead, sort operates on homogeneous containers. All the elements have to match in type, so that they can be mutually compared. They don’t each need to have different implementations of the operations.</p>
<p>Nevertheless, sort is still polymorphic. A sorting algorithm is the same for integers or strings, but comparing integers is a completely different operation than comparing strings. The sorting algorithm needs a way of invoking an operation on its items – the comparison operation – differently for different types, while still having the same overall structure of code.</p>
<p>This can be done by injecting a comparison function, but many types have an intrinsic, default ordering, and sort should default to it. Thus, polymorphism – but not an OOP-friendly variety.</p>
<p>See the contrivance Java goes through to define sort:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static &lt;T extends Comparable&lt;? super T&gt;&gt; 
void sort(List&lt;T&gt; list)
<span class="boring">}</span></code></pre></pre>
<p>There is no simple trait that can require T to be comparable to other Ts, for T to be ordered. Instead, as far as the programming language is concerned, the idea that T is comparable to itself, rather than to any other random type, is only articulated as an accident to this method. Nothing is stopping someone from implementing the Comparable interface in an inconsistent way, like having Integer implement Comparable<String>.</p>
<p>Additionally, when it actually looks up the implementation of Comparable, it decides what implementation to use based on the first argument of any comparison, not based on the type. Normally, they will all be the same type, but theoretically, this list could be heterogeneous, as long as all the objects “extend” T, and they could implement Comparable differently. The computer has to do extra work to indulge this possibility, even though it would certainly be a mistake.</p>
<p>As we’re now drifting outside of the realm of semantics, and into the realm of performance, let’s discuss the performance implementations of this fully.</p>
<p>The Java sort method, as we mentioned, requires every item in the collection to be a full object type, which means that instead of storing the values directly in the array, the values are stored in the heap, and references are stored in the array. This is unnecessary with a traits-based approach – the values can live directly in the array.</p>
<p>This means that different arrays will have different element sizes, so this has to be handled by a trait as well. And it is: The size of the values is also parameterized via the Sized trait. The size does have to be consistent among all the items of the array, but this is enforceable because we can express that all the elements are actually the exact same type – unlike Java’s List<T> which only expresses that they’re of type T or some subtype of T.</p>
<p>Rust’s sort method could have been implemented by passing the size information (from the Sized trait) and the ordering function (from the Ord trait) at runtime as an integer value and a function pointer. This is how typeclasses work in Haskell, which was the inspiration for Rust traits. This would still be more efficient than the Java, as there would be a single ordering function, rather than a different indirect lookup for every left side of the comparison, allowing indirect branch prediction to work in the processor.</p>
<p>But Rust goes even further than that, and implements its traits instead via monomorphization. This is similar to C++ template instantiation, but semantically better constrained. The premise is that while sort is only one method semantically, in the outputted, compiled code, a different version of sort is outputted for every type T that it is called with.</p>
<p>C++ templates create infamously bad error messages and are difficult to reason about, because they are essentially macros, and awkward ones. Even Rust cannot create great error messages with its macro system. But also, writing them requires expertise, and means that the programmer is forgoing many of the benefits of the type system – templates are often called, in my opinion rightly so, a form of compile time duck-typing. For these reasons, template programming in C++ is often considered more advanced (read as harder and less convenient rather than more powerful) than OOP-style polymorphism.</p>
<p>In Rust, however, traits provide an organized and more coherent way of accessing similar technology, getting the performance benefits of templates while still giving the structure of a solid type system.</p>
<h3 id="alternative-3-dynamic-trait-objects"><a class="header" href="#alternative-3-dynamic-trait-objects">Alternative #3: Dynamic Trait Objects</a></h3>
<p>Sometimes, however, you do need full run-time polymorphism. You have the opposite of the scenario with the enum: You have a closed set of operations that can be performed on a value, but what those operations actually do will change dynamically in a way that cannot be bounded ahead of time.</p>
<p>In such situations, Rust has you covered with the dyn keyword. Please don’t overuse it, though. In almost all situations where I’ve thought it might be appropriate, static polymorphism combined with other design elements have worked out better.</p>
<p>Legitimate use cases for dyn tend to come up in situations involving inversion of control, where a framework library takes on a main loop, and the client code says how to handle various events. In network programming, the framework library says how to juggle all the sockets and register them with the operating system, but the application needs to say what to actually do with the data. In GUI programming, the framework code can say what widget was being clicked on, but very different things happen if that widget is a button versus a text box versus a custom widget you invented for this particular app.</p>
<p>Now, you don’t strictly need run-time polymorphism for this. You could use closures (or even raw function pointers) instead, creating struct of closures (or function pointers) if multiple operations are called for – which amounts to basically doing what dyn does the hard way by hand. For example, I fully expected tokio to use Rust’s run-time polymorphism feature internally to handle this inversion of control in task scheduling. Instead, for what I imagine are performance reasons, tokio implements dyn by hand, even calling its struct of function pointers Vtable.</p>
<p>But dyn does all of this work for you, for your trait. The only requirement is that your trait be object-safe, and the list of requirements may seem familiar, especially when it comes to the requirements for an associated function (e.g. a method) to be “dispatchable”:</p>
<hr />
<ul>
<li>Not have any type parameters (although lifetime parameters are allowed),</li>
<li>Be a method that does not use Self except in the type of the receiver.</li>
<li>Have a receiver with one of the following types:
<ul>
<li>&amp;Self (i.e. &amp;self)</li>
<li>&amp;mut Self (i.e &amp;mut self)</li>
<li>Box<Self></li>
<li>Rc<Self></li>
<li>Arc<Self></li>
<li>Pin<P> where P is one of the types above</li>
</ul>
</li>
<li>Does not have a where Self: Sized bound (receiver type of Self (i.e. self) implies this).</li>
</ul>
<hr />
<p>That is to say, it can be polymorphic in exactly one parameter, and that parameter must be by reference – more or less the exact requirements for methods to support run-time polymorphism in OOP.</p>
<p>This is of course because dyn uses almost exactly the same mechanism as OOP to implement run-time polymorphism: the “vtable.” Box<dyn Foo> really contains two pointers rather than one, one to the object in question, and the pointer to the “vtable,” the automatically-generated structure of function pointers for that type. The one-parameter requirement is because that is the parameter whose vtable is used to look up which concrete implementation of a method to call, and the indirection requirement is because the concrete type might be different sizes, with the size only known at run-time.</p>
<p>To be clear, these are limitations on one particular implementation strategy for run-time polymorphism. Alternative strategies exist that fully decouple the vtable from individual values of the type, as in Haskell.</p>
<p>There are still a few advantages of Rust’s version of run-time polymorphism with traits as opposed to OOP-style interfaces.</p>
<p>Performance-wise, it’s something done alongside a type, rather than intrinsic to the type. Normal values don’t store a vtable, spreading the cost of this throughout the program, but rather, the vtables are only referenced when a dyn pointer is created. If you never create a dyn pointer to a value of a given type, that type’s vtable doesn’t even have to be created. Certainly, you don’t have 8 bytes of extra gunk in every allocation for all the vtable pointers! This also means there’s one fewer level of indirection.</p>
<p>Semantically, it’s also a good thing that it’s just one option among many, and that it’s not the strongly preferred option that the entire programming language is trying to push you towards. Often, even usually, static polymorphism, enums, or even just good old-fashioned closures more accurately represent the problem at hand, and should be used instead.</p>
<p>Finally, the fact that run-time and static polymorphism in Rust both use traits makes it easier to transition from one system to another. If you find yourself using dyn for a trait, you don’t have to use it everywhere that trait is used. You can use the mechanisms of static polymorphism (like type parameters and impl Trait) instead, freely mixing and matching with the same traits.</p>
<p>Unlike in C++, you don’t have to learn two completely different sets of syntax for concepts vs parent classes, and vastly different semantics. Really, in Rust, dynamic polymorphism is just a special case of static polymorphism, and the only differences are the things that actually are different.</p>
<h2 id="logging-15"><a class="header" href="#logging-15">logging</a></h2>
<ul>
<li>230215 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-和默认参数"><a class="header" href="#rust-和默认参数">Rust 和默认参数</a></h1>
<p>原文: <a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></p>
<blockquote>
<p>快译</p>
</blockquote>
<p>Rust 不支持函数声明中的默认参数;
而且和很多语言不同, 无法通过函数重载来模拟;
这让很多来自其它编程语言的 Rustacean 新人感到沮丧,
所以, 就想解释一下为什么这其实是件好事儿,
以及,如果使用默认 trait 和结构更新语法来实现类似的效果;</p>
<p>默认参数(和函数重载)不是面向对象编程的一部分,
但是,又是许多 Rustaceans 新人原先编程语言的共同特征;
因此, 这篇文章在某些方面和我正在进行的关于 Rust 如何不是面向对象的系列文章相吻合,
故而, 被标准为这个系列的文章;
还受到 Reddit 中对我第一篇 OOP 相关贴子回复的启发;</p>
<h2 id="默认秋粮是如何工作咯比如-c"><a class="header" href="#默认秋粮是如何工作咯比如-c">默认秋粮是如何工作咯(比如 C++)</a></h2>
<p>在开始讨论为什么 Rust 没有默认参数以及我们可以折腾什么之前,
得先聊明白什么是默认参数以及在哪些情况下有用;</p>
<p>假设你有一个带有很多参数的函数,
比如(以 Reddit 回复中的示例)在 GUI 中创建一个窗口:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible)

auto handle = createWindow(10, 30, false); // Create invisible window
auto handle2 = createWindow(100, 500, true); // Create visible window
</code></pre>
<p>现在, 假设你准备创建的大多数窗口都是可见的,
并且,你不想让程序员负担必须指定窗口是否可见的担心 --- 甚至于不想明确的考虑这事儿 --- 在正常情况下,
在支持默认参数的编程语言中,你可以为可见性提供默认值:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true)

auto handle = createWindow(10, 30, false); // Create invisible window!

auto handle2 = createWindow(100, 500, true); // Create visible window!

auto handle3 = createWindow(100, 500); // Also create visible window!
auto handle4 = createWindow(100, 500); // Most of the time, that's what
auto handle5 = createWindow(100, 500); // you want, so why have to say it?
Default parameters can also be simulated with function overloading for programming languages where function overloading is available but default parameters are not:

WindowHandle createWindow(int width, int height, bool visible);

WindowHandle createWindow(int width, int height) {
    return createWindow(width, height, true);
}
</code></pre>
<p>Rust 也没有函数重载,这是个复杂的多的问题,
但是, 很多相同的论点都适用这个习惯用法的理解;</p>
<h2 id="默认参数的好处和坏处"><a class="header" href="#默认参数的好处和坏处">默认参数的好处(和坏处)</a></h2>
<p>默认值很好,这种风格的默认参数是实现并从中获益的一种方式;</p>
<p>默认值是好的,因为,她们坚持 DRY 原则 --- 不要重复自己(Don’t Repeat Yourself);
如果我们没有默认值, 就不得不重复那些实际上对理解代码没有帮助的参数;
如果最佳默认秋粮的更改方式楼主更新代码的最佳方法是继续使用默认值--- 也许因为最佳实践发生了变化 ---
我们将不得不更新每个调用, 而不是只要更改一处, 定义了默认参数那里;</p>
<p>默认徝很好,因为,她们减少了程序员的认知负担;
程序员必须一次性在大脑中保留大量信息,
而默认设置通过不强迫在无关场景时要考虑额外的细节来帮助程序员---这是太多数默认设置的常见作用场景;</p>
<p>默认秋粮也使代码更加简洁,
因此, 很受欢迎;
但是,这不是专有的特殊价值;
我相信 DRY 原则很重要, 这通常意味着更加简洁的代码,
但是,考虑到现代编辑器和 IDE, 以及现代人劝为把不用又和阅读速度的期待,
适度的冗长以能换取其它好处(比如, 清晰度和明确性),
我还是完全可以接受的;
相信默认参数,因为这是在 C++ 和 Python 中实现的,
在清晰度和明确性方面付出了巨大的代价,
因此,简洁性并不是证明她们合理的充分理由;</p>
<p>在这种情况中, 让我特别困扰的是代码中的不清晰之处,
在于代码的读者不知道可能还有更多的参数;
没有暗示可能还有其它秋粮;
如果维护者想更改其中一个调用以便创建不可见的窗口,
领导作用可能没有意识到应该先检验 create_window 的文档:
毕竟, 似乎只接受两个参数,
而且也没有任何远程反应针对不可见窗口;</p>
<p>幸运的是, Rust 具有替代特性,
使我们能在不牺牲明确性和清晰性的情况下,
也获得认知负荷和 DRy 的好处;</p>
<h2 id="rust-中的默认值-默认-trait"><a class="header" href="#rust-中的默认值-默认-trait">Rust 中的默认值: 默认 trait</a></h2>
<p>Rust 不允许使用默认参数,
而是允许你使用 Default trait 有选择的为你的类型指定默认值;</p>
<p>是这样工作的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
}

impl Default for Foo {
    fn default() -&gt; Self {
        Foo::Bar
    }
}
<span class="boring">}</span></code></pre></pre>
<p>或是, 使用更加简洁的 派生/derive 语法编写:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum Foo {
    #[default]
    Bar,

    Baz,
}
<span class="boring">}</span></code></pre></pre>
<p>一旦定义了这个默认值,
Foo::default() 或是(在类型明确的上下文中) Default::default() 就可以代表 Foo::Bar ;</p>
<p>如果你习惯为你的函数参数重用现有类型,
这可能看起来比不用更加糟糕;
毕竟, 我们默认的参数是 bool 类型的,
孤儿规则(在 Rust 的 trait 相关章节有解释) 禁止我们在 bool 上定义默认 trait ---
正如我在上面提及的, Default 允许你对类型定义默认值;
即便,我们可以为 bool 设置默认值也是一件过于强大的事儿,
无法仅仅为这个函数参数提供默认值!
毕竟, 其它一些函数也可能有一个具有不同默认值的 bool 类型参数;</p>
<p>但是,如果在 Rust 中考虑, 这更加有意义 --- 甚至是惯用的和首选的 --- 为配置和函数参数等等创建自定义类型;
毕竟, 如果你不查实文档, 可能不清楚 true 的含义;
甚至于不清楚和可见性有什么关系,
更不用说很容易将 true 当参数时意味着不可见窗口是可见的;</p>
<p>在 Rust 中,我们更加愿意为这一情况定义一个新类型, 一个列出可见性选项的枚举---如果创建一个新的可见性选项,
这才有所帮助;
在这个枚举上, 声明一个默认值才是合理的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum WindowVisibility {
    #[default]
    Visible,

    Invisible,
}
<span class="boring">}</span></code></pre></pre>
<p>是的, 这比我们的原始代码有些冗长, 但更清晰,
而且不乏 DRY ;
简洁本身并不是一种价值;
明确的列出选项比隐式选项更可取;</p>
<p>然后, 当我们调用该函数时, 可以这么使用默认值:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_window(width: u32, height: u32, visibility: WindowVisibility) -&gt; WindowHandle;

let handle = create_window(10, 30, WindowVisibility::Invisible);
let handle2 = create_window(100, 500, WindowVisibility::Visible);

let handle3 = create_window(100, 500, WindowVisibility::default());
let handle4 = create_window(100, 500, WindowVisibility::default());
let handle5 = create_window(100, 500, Default::default()); // 也允许
<span class="boring">}</span></code></pre></pre>
<p>正如承诺的那样, 这样冗长些, 同样 DRY,
但是, 更加明确和清晰; (无歧义)</p>
<p>注意: 我使用独立函数只是为了举例;
实际上, 这个特定函数很可能是类型内部方法的一部分,
例如 WindowHandle::new 或是 WindowHandle::create_window;</p>
<h3 id="rust-中默认值缩放-结构更新语法"><a class="header" href="#rust-中默认值缩放-结构更新语法">Rust 中默认值缩放: 结构更新语法</a></h3>
<p>所以, 这对于一个默认值来说形式上更好;
但是,拓展性并不好;
如果我们想在我们的窗口创建函数中追加另外3个参数怎么办?
在 C++ 中, 可以可以为她们提供默认值,
调用者甚至不需要更新(参数仅用来示例, 并不代表在创建窗口):</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true,
                          WindowStyle windowStyle = WindowStyle::Standard,
                          int z_position = -1,
                          bool autoclose = false);

createWindow(100, 500); // Still works identically
createWindow(100, 500, false); // Also still works
createWindow(100, 500, false, WindowStyle::Standard, 2, true); // Specify everything
</code></pre>
<p>这是一个有用的功能;
在 Rust 中,使用目前讨论的技术,
无论参数有多少,我们都必须重复编写 Default::default() ;
这是 DRY 违规行为, 会干挠追加新参数的能力;</p>
<p>但是, 此功能也存在缺陷;
你现在已经限制自己在左侧指定参数,
以便在右侧追加参数;
在调用 createWindow 最后一个示例中, 我们通过显式指定一个值来违反 DRY,
当时我们可能想使用默认值,但是,该值不可用, 因为,我们想为以后的参数覆盖默认值;</p>
<p>幸运的是, Rust 也有这种版本;
正如我们只是为了这个函数调用而创建了一个枚举一样,
在 Rust 中为这种配置参数创建结构也是惯用的;
该结构看起来像这样:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowConfig {
    pub width: u32,
    pub height: u32,
    pub visibility: WindowVisibility,
    pub window_style: WindowStyle,
    pub z_position: i32,
    pub autoclose: AutoclosePolicy,
}
<span class="boring">}</span></code></pre></pre>
<p>然后, 我们就可以为整个结构指定 Default:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for WindowConfig {
    fn default() -&gt; Self {
        Self {
            width: 100,
            height: 100,
            visibility: WindowVisibility::Visible,
            window_style: WindowStyle::Standard,
            z_position: -1,
            autoclose: AutoclosePolicy::Disable,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>现在, 似乎使用起来很乏味;
你可能想象得这么使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = WindowConfig::default();
config.width = 500;
config.z_position = 2;
config.autoclose = AutoclosePolicy::Enable;
let handle = create_window(config);
<span class="boring">}</span></code></pre></pre>
<p>我认为即便是这样也比默认秋粮可取,
因为,这样是明确的;
然而, Rust 有一个专门为这种情况设计的语法结构:
struct update syntax ;
有了这,我们获得的东西和默认参数非常相似,
但是,更冗长/明确/灵活:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = create_window(WindowConfig {
    width: 500,
    z_position: 2,
    autoclose: AutoclosePolicy::Enable,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<p>不像 C++ 风格的言论参数,
我们可以完全覆盖我们想要的默认值;
同样明确的是,
如果我们愿意, 甚至可以修改其它参数,
而不需强制维护开发者检查文档;</p>
<p>除此之外, 这样允许定义其它默认值集;
除了 WindowConfig::default 之渑, 可能还有另外一组用来创建对话框的配置参数,
例如: like WindowConfig::dialog() 或是 WindowConfig::default_dialog ;
程序员通常在创建不可见窗口, 或是高度相同的窗口应用,
可能会定义自己的默认设置, config::app_local_default_window_config();
这些不会通过 Default 特性来调解,
但是, Default 只是一个 trait ,
而 Default::default() 是一个方法调用;
你可以改为调用自己的方法,
并仍然使用此<code>结构更新语法</code>;</p>
<p>所以,现在我们在 Rust 中有一个习惯用语系统来替换默认参数;
这和 DRY 一样,
并且同样减少了认知负荷;
更加重要的是, 这样作并没有牺牲对到底发生了什么的明确性与清晰性 --- 一个给定的函数总是采用相同数量的参数,
这是 Rust 维护开发者可以(并且正在)依赖的不变量;</p>
<h3 id="构建器模式"><a class="header" href="#构建器模式">构建器模式</a></h3>
<p>在这点上, Rustacean 老手们应该能注意到还没讨论一种通用的 Rust 方法来设计这些配置结构,
即:  <code>构建器模式</code> (Builder Pattern);</p>
<p>这是有原因的: 我不喜欢丫的;
(译按: 千金婎买我愿意, 没错...)
我个人更加喜欢使用 Default 和 struct update 语法,
其它人可能会使用  <code>构建器模式</code>  ;
我认为这种模型不够明确, 而且由于在非 OOP 编程语言方面有很多经验,
所以,我觉得这是一种没有问题的解决方案, 主要成果只是令代码看起来更加 OOP 而已;</p>
<p>不过, 这也是 Rust 中常用的模式, 一般使用 <code>构建器模式</code> 的 crate,
因而值得熟悉之;
这和以往的概念相同:
使用充满参数的结构, 将配置发送到 构建函数或是函数调用;
有时这种会被称为 WindowBuilder 而不是 WindowConfig;</p>
<p>但是, 不直接使用结构更新语法, 而是添加了一堆辅助方法来执行结构更新:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>或者, 正如想指出的那样:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(self, height: u32) -&gt; Self {
        Self {
            height,
            ..self
        }
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>有时, 枚举被拆分为多个更新方法:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn autoclose_enable(mut self) -&gt; Self {
        self
        self.autoclose = AutoclosePolicy::Enable;
    }

    fn autoclose_disable(mut self) -&gt; Self {
        self.autoclose = AutoclosePolicy::Disable;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然后, 通常并不是调用例如: window constructor,
你调用在构建器上定义的构建方法
(此时,已经对影响设计的无偿 OOP 哲学感到畏缩)</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn build(self) {
        window_create(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>其实,不用 struct update 语法,
而是将对这些方法调用链接在一起:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = WindowBuilder::new()
    .width(500)
    .z_position(2)
    .autoclose_enable()
    .build();
<span class="boring">}</span></code></pre></pre>
<p>我仍然更加喜欢这个, 而不是默认参数,
但是, 同时也感觉有点俗气;
我不喜欢被迫使用像 构建器 这样的抽象&quot;对象&quot;来思考,
也不喜欢这种风格中更直观的假设;
为什么 &quot;构建器&quot; 是作某件事儿的对象?
为什么它比&quot;配置&quot;结构更受欢迎?
OOP 程序员是否意识到在现实生活中, 绝大多数对象根本不作任何事儿,
当然, 也不会构建其它对象?</p>
<p>但是, 对于熟悉 OOP 习惯用法的人来说,
这可能更可取;
这是一个普通选择的选项, 因此, 至少识别这种模式很重要;</p>
<h2 id="结论和应用"><a class="header" href="#结论和应用">结论和应用</a></h2>
<p>Rust 有很多不同于其它语言的习惯;
我经常看到新的 Rustacean 提议为 Rust 添加默认参数和其它类似的功能,
而这些新 Rustacean 感到困惑的是, 
领导作用感受到的强烈要求在更大的 Rust 社区中并没有被广泛感受到;</p>
<p>通常, 这和默认参数类似;
有实现相同目标的替代习语, 嘦这些目标符合 Rust 的价值观:
在此场景中, DRYness 并减少开发者认知负担;
根据 Rusty 的价值观, 她们在其它方面也是更好的解决方案: 额外的明确性值得多点冗长代码;</p>
<p>所以, 我希望这可以作为一个案例研究来报时大家理解,
通常总是有 Rusty 的方法来实现 OOP 领域流行功能目标,
以及, 为什么 Rustacean 更加喜欢这些方案而不是盲目的积累新功能;</p>
<h2 id="logging-16"><a class="header" href="#logging-16">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230220 ZQ v0 DONE</li>
<li>230212 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="笔记"><a class="header" href="#笔记">笔记</a></h1>
<blockquote>
<p>logging</p>
</blockquote>
<h2 id="background-12"><a class="header" href="#background-12">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>任何自学都需要探索+内省, 同时来, 否则, 很容易不知道在折腾什么...</p>
<h2 id="goal-10"><a class="header" href="#goal-10">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li>是谁?</li>
<li>在哪?</li>
<li>去哪?</li>
</ul>
<p>随时嗯哼明白...</p>
<h2 id="trace-10"><a class="header" href="#trace-10">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
基本环境</li>
<li><input disabled="" type="checkbox"/>
基本语法</li>
<li><input disabled="" type="checkbox"/>
基本 std</li>
<li><input disabled="" type="checkbox"/>
基本项目结构</li>
<li><input disabled="" type="checkbox"/>
基本经典工程</li>
<li><input disabled="" type="checkbox"/>
基本...习惯们?</li>
</ul>
<h2 id="refer-15"><a class="header" href="#refer-15">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-17"><a class="header" href="#logging-17">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-丑句法"><a class="header" href="#rust-丑句法">Rust 丑句法</a></h1>
<p>原文: <a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html#Rust-s-Ugly-Syntax">Rust's Ugly Syntax</a></p>
<h2 id="快译-4"><a class="header" href="#快译-4">快译</a></h2>
<p>大家抱怨 Rust 的语法;
不过,俺想大多数时候,
当人们认为在对 Rust 语法有疑问时,
实际上在反抗对应语义;
在这篇有点儿异想天开的文章中,
俺将尝试理清这两点;</p>
<p>先从一个丑陋的语法示例开始:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}</span></code></pre></pre>
<p>此函数读取给定二进制文件内容;
这是直接从标准库中提取的, 所以, 不算是稻草人式无用示例;
而且,至少对俺来说, 这绝对不算漂亮;</p>
<p>让我们想象一下,如果 Rust 有更好的语法, 这个函数应该是什么样儿;
如果和真正的编程语言有任何相似之处, 无论真假, 纯属试合!</p>
<p>从 Rs++ 开始:</p>
<pre><code class="language-c++">template&lt;std::HasConstReference&lt;std::Path&gt; P&gt;
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
std::read(P path) {
    return read_(path.as_reference());
}

static
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
read_(&amp;auto const std::Path path) {
    auto file = try std::File::open(path);
    std::vector bytes;
    try file.read_to_end(&amp;bytes);
    return okey(bytes);
}
</code></pre>
<p>Rhodes 变体:</p>
<pre><code class="language-ruby">public io.Result&lt;ArrayList&lt;Byte&gt;&gt; read&lt;P extends ReferencingFinal&lt;Path&gt;&gt;(
        P path) {
    return myRead(path.get_final_reference());
}

private io.Result&lt;ArrayList&lt;Byte&gt;&gt; myRead(
        final reference lifetime var Path path) {
    var file = try File.open(path);
    ArrayList&lt;Byte&gt; bytes = ArrayList.new();
    try file.readToEnd(borrow bytes);
    return Success(bytes);
}
</code></pre>
<p>经典 RhodesScript:</p>
<pre><code class="language-js">public function read&lt;P extends IncludingRef&lt;Path&gt;&gt;(
    path: P,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    return myRead(path.included_ref());
}

private function myRead(
    path: &amp;const Path,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    let file = try File.open(path);
    Array&lt;byte&gt; bytes = Array.new()
    try file.readToEnd(&amp;bytes)
    return Ok(bytes);
}
</code></pre>
<p>响尾蛇/Rattlesnake:</p>
<pre><code class="language-python">def read[P: Refing[Path]](path: P): io.Result[List[byte]]:
    def inner(path: @Path): io.Result[List[byte]]:
        file := try File.open(path)
        bytes := List.new()
        try file.read_to_end(@: bytes)
        return Ok(bytes)
    return inner(path.ref)
</code></pre>
<p>以及, CrabML:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>read :: 'p  ref_of =&gt; 'p -&gt; u8 vec io.either.t
let read p =
  let
    inner :: &amp;path -&gt; u8 vec.t io.either.t
    inner p =
      let mut file = try (File.open p) in
      let mut bytes = vec.new () in
      try (file.read_to_end (&amp;mut bytes)); Right bytes
  in
    ref_op p |&gt; inner
;;
<span class="boring">}</span></code></pre></pre>
<p>作为一个稍微严肃和有用的练习,
让我们作相反的尝试--保留 Rust 语法,
但是, 尝试简化语义直到最终结果, 看会是什么样儿;</p>
<p>这是我们的起点:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}</span></code></pre></pre>
<p>这时, 最大的噪音源是嵌套函数;
动机有点儿深奥;
外部函数是通用的,而内部不是;
使用编译模式,这意味着外部函数和用户代码一起编译,
而嵌的将优化;
相比之下, 内部函数是在编译 std 本身时编译的,
从而节省了编译用户代码的时间;
简化这一点(损失一些性能)的一种方法,
说是泛型函数总是单独编译,
但是,能在幕后接受一个额外的运行时秋粮, 可以描述物理维度上的输入参数;</p>
<p>这样我们获得:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path.as_ref())?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>下个噪音元素是 <code>&lt;P: AsRef&lt;Path&gt;&gt;</code> 约束;
这是必需的,因为 Rust 喜欢将内存中字节的物理布局作为接口公开,
特别是对可以带来性能的情况;
特殊的, Path 的含义并不是文件路径的某种抽象,
这里只是字面意义上内存中的一堆连续字节;
所以, 我们需要 AsRef 来将其和任何能够表示这种字节片的抽象一起工作;
但是, 如果我们不关心性能,
就可以要求所有接口都相当抽象,并通过虚函数调用进行调解,
而不是直接访问内存;
那么, 我们就不需要 AsRef 这堆东西了:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>这样简化后,我们实际上也可以摆脱 <code>Vec&lt;u8&gt;</code> -- 如果我们不再使用泛型来表达语言本身的高效可增长字节数组;
我们必须使用运行时提供的一些不透明字节类型:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Bytes&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Bytes::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>从技术上讲,我们仍然随身携带所有权和备用系统,
但是,由于无法直接控制类型的内存布局,
就无法带来巨大的性能优势;
仍然有助于避免 GC,防止迭代器失效,
并静态检验非线程安全代码是否实际上没有跨线程使用;
不过, 如果我们只切换到 GC, 我们可以轻松摆脱那些 &amp;指针;
我们甚至于不需要太担心并发性--因为,我们的对象是单独分配的,而且总是在指针后面,
我们可以通过注意到指针大小,
无论是否在 x86 系统上都是原子操作来消除数据竞争;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; io::Result&lt;Bytes&gt; {
  let file = File::open(path)?;
  let bytes = Bytes::new();
  file.read_to_end(bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>最后,我们在这对错误的处理过于迂腐 -- 我们并仅要关注返回类型失败的可能,
甚至于要用 ? 来突出指示任何可能失败的特定表达式;
完全不考虑错误处理,
让一些顶层处理程序来处理:
(比如: try { } catch (...) { /* intentionally empty */ })</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; Bytes {
  let file = File::open(path);
  let bytes = Bytes::new();
  file.read_to_end(bytes);
  bytes
}
<span class="boring">}</span></code></pre></pre>
<p>现在是否好多了?</p>
<h2 id="ps"><a class="header" href="#ps">PS:</a></h2>
<p>的确是篇奇想, 这样简化后, 几乎就是 多了一些控制符号的 Python 了,
又或是根本可以视为 TypeScript 了;
当然, 如果有这种低效版 Rust 多数程序员还是愿意使用的;
就象当年 CoffeeScript 的尝试;</p>
<h2 id="logging-18"><a class="header" href="#logging-18">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230206 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-课程笔记"><a class="header" href="#rust-课程笔记">Rust 课程笔记</a></h1>
<h2 id="background-13"><a class="header" href="#background-13">background</a></h2>
<p>Rust 社区很给力各种渠道中,有各种教程,
只是, 每个教程都有自己的特点和盲区...</p>
<h2 id="goal-11"><a class="header" href="#goal-11">goal</a></h2>
<p>高速刷过时, 见到有趣/有用/有种的片段, 收集摘录在一起, 形成自己的小抄...</p>
<h2 id="trace-11"><a class="header" href="#trace-11">trace</a></h2>
<h3 id="init"><a class="header" href="#init">init.</a></h3>
<p>Recommended tools:</p>
<ul>
<li><input disabled="" type="checkbox"/>
cargo readme - to regenerate README.md based on template and lib.rs comments</li>
<li><input disabled="" type="checkbox"/>
cargo insta - to review test snapshots</li>
<li><input disabled="" type="checkbox"/>
cargo edit - to add/remove dependencies</li>
<li><input disabled="" type="checkbox"/>
cargo fmt - to format code</li>
<li><input disabled="" type="checkbox"/>
cargo clippy - for all insights and tips
<ul>
<li>安装：rustup component add clippy</li>
<li>参考: <a href="https://skyao.io/learning-rust/docs/build/rustup/rustup-book.html">Rustup Book学习笔记 | Rust学习笔记</a></li>
<li>如果出问题:
<ul>
<li><a href="https://github.com/rust-lang/rustup/issues/1558">Fresh install on macos can't install rustfmt and clippy using rustup · Issue #1558 · rust-lang/rustup</a></li>
<li>rustup toolchain remove stable &amp;&amp; rustup toolchain install stable</li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>info: syncing channel updates for 'stable-x86_64-apple-darwin'
info: latest update on 2023-02-09, rust version 1.67.1 (d5a82bbd2 2023-02-07)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
info: downloading component 'rust-std'

...

  stable-x86_64-apple-darwin installed - rustc 1.67.1 (d5a82bbd2 2023-02-07)

info: checking for self-updates
</code></pre>
<ul>
<li><input disabled="" type="checkbox"/>
cargo fix - for fixing warnings</li>
</ul>
<h4 id="检验和切换工具链"><a class="header" href="#检验和切换工具链">检验和切换工具链</a></h4>
<p>~ <a href="https://github.com/gavadinov/Learn-Rust-by-Building-Real-Applications/tree/master/memory_management">Learn-Rust-by-Building-Real-Applications/memory_management at master · gavadinov/Learn-Rust-by-Building-Real-Applications</a></p>
<p>查实当前使用的工具链:</p>
<blockquote>
<p>rustup toolchain list</p>
</blockquote>
<p>安装指定工具链:</p>
<blockquote>
<p>rustup toolchain install nightly-x86_64-unknown-linux-gnu</p>
</blockquote>
<h4 id="宏查阅"><a class="header" href="#宏查阅">宏查阅</a></h4>
<p>~ <a href="https://github.com/dtolnay/cargo-expand">dtolnay/cargo-expand: Subcommand to show result of macro expansion</a></p>
<p>使用:</p>
<blockquote>
<p>crago expand</p>
</blockquote>
<p>在终端中展开宏并打印...如果工程大点儿, 就不可看了...</p>
<h3 id="project"><a class="header" href="#project">project</a></h3>
<h4 id="cli"><a class="header" href="#cli">CLI</a></h4>
<p>~ <a href="https://rust-cli.github.io/book/tutorial/index.html">A command line app in 15 minutes - Command Line Applications in Rust</a></p>
<p>还是老习惯, CLI-&gt;RESTful-&gt;GUI-&gt; ...</p>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<h4 id="dbg"><a class="header" href="#dbg">dbg!()</a></h4>
<p>类似 ic 的工具, 可以随时插入代码, 并在运行时打印对应变量名和值...</p>
<h3 id="testting"><a class="header" href="#testting">testting</a></h3>
<h3 id="coding"><a class="header" href="#coding">coding</a></h3>
<h2 id="refer-16"><a class="header" href="#refer-16">refer:</a></h2>
<blockquote>
<p>Udemy</p>
</blockquote>
<ul>
<li><a href="https://www.udemy.com/course/rust-programming-the-complete-guide/">The Complete Rust Programming Course | Udemy</a></li>
<li><a href="https://www.udemy.com/course/rust-fundamentals/">Learn Rust by Building Real Applications | Udemy</a>
<ul>
<li>用了一半篇幅来介绍内存管理模型,以及 GDB 观察过程...</li>
</ul>
</li>
</ul>
<blockquote>
<p>Youtube</p>
</blockquote>
<ul>
<li>110+<a href="https://www.youtube.com/playlist?list=PL3azK8C0kje1DUJbaOqce19j3R_-tIc4_">Rust 编程语言入门教程 [2021] - YouTube</a>
<ul>
<li>42+<a href="https://www.youtube.com/playlist?list=PLVvjrrRCBy2JSHf9tGxGKJ-bYAN_uDCUL">RUST PROGRAMMING TUTORIALS - YouTube</a></li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW">Intro to Rust - YouTube</a></li>
<li>14+<a href="https://www.youtube.com/playlist?list=PLKkEWK6xRmes17LQUEA5bNjYISuCEOTXx">Rust For Starters - YouTube</a></li>
</ul>
</li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8">The Rust Lang Book - YouTube</a></li>
<li>25+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDD5vy2BuSHvFZU0a6RDmgb">Rust Projects - YouTube</a>
<ul>
<li>24+<a href="https://www.youtube.com/playlist?list=PL5dTjWUk_cPYuhHm9_QImW7_u4lr5d6zO">50 RUST Projects - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/@jonhoo">Jon Gjengset - YouTube</a>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFgY2faCIYjJZv_RluGkTlKt">Rust live-coding - YouTube</a>
<ul>
<li>都是几个小时的连续调试过程</li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">Crust of Rust - YouTube</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图形描述-rust-中所有权和借用"><a class="header" href="#图形描述-rust-中所有权和借用">图形描述 Rust 中所有权和借用</a></h1>
<p>原文: <a href="https://rufflewind.com/2017-02-15/rust-move-copy-borrow">Graphical depiction of ownership and borrowing in Rust - Rufflewind's Scratchpad</a></p>
<h2 id="快译-5"><a class="header" href="#快译-5">快译:</a></h2>
<p>以下是 Rust 语言中 moving, copying, 和 borrowing 的图形描述;
这些概念中的大多数是 Rust 持有的,
因此, 也是很多学习者常见绊脚石;</p>
<p>为了避免图形混乱, 尽量减少了文字;
并不是要取代现有各种教程, 而是为喜欢直观理解概念的程序员提供不同的视角;
如果你正在学习 Rust 并发现这些图形有报时,
建议你使用这类图表注释自己的代码以便帮助巩固概念 ;-)</p>
<h2 id="rust-中所有权和借用"><a class="header" href="#rust-中所有权和借用">Rust 中所有权和借用</a></h2>
<p><img src="https://rufflewind.com/img/rust-move-copy-borrow.png" alt="" /></p>
<p>可以通过点击图像来放大, 也可以下载 <a href="https://rufflewind.com/img/rust-move-copy-borrow.svg">SVG</a>
和 <a href="https://rufflewind.com/img/rust-move-copy-borrow.pdf">PDF</a> 版本在本地放大;</p>
<p>上面的图形描述了你拥有数据的两种主要语义: 移动或是复制;</p>
<p>关于移动的解释(~&gt;)看起来太简单了;
这里没有把戏: 移动语义本身就很奇怪,因为,大多数语言允许变量被程序员随意使用多次;
这和现实世界的大部分情况形成鲜明对比:
我不能把我的笔给别人,然后,仍然用它继续写字!
在 Rust 中,任何类型未实现 Copy trait 的变量都具有移动语义,
并且会像所示那样运行;</p>
<p>复制语义(⎘)是为实现 Copy trait 的类型保留的;
在这种情况中, 对象的每次使用都会产生一个副本, 正如所示分叉; 中间的两个数字描绘了你可以借用你拥有物品的两种方式,
以及每种方式提供的操作;</p>
<p>对于可变借用, 我使用了锁符号(🔒)来表示原始对象在借用期间被有效锁定,
令其无法使用;</p>
<p>相反,对于非可变备用, 我使用了雪花符号(❄)来表示原始对象只是被冻结了:
你仍然可以获取更多非可变引用, 但是, 你不能移动或是获取其可变引用;</p>
<p>在这两个图中, <code>'ρ</code> 是我为引用的生命周期选择的名称;
我故意使用希腊字母是因为目前 Rust 中还没有具体生命周期的语法;</p>
<p>最后两个图以图形和文本形式总结了两种引用之间的主要区别和相似之处;
在这种场景中&quot;外部(<a href="https://doc.rust-lang.org/beta/book/mutability.html#interior-vs-exterior-mutability">exteriorly</a>)&quot;限定词很重要,
因为, 你仍然可以通过类似 <a href="https://doc.rust-lang.org/std/cell/">Cell</a> 的东西拥有内部可变性;</p>
<h2 id="logging-19"><a class="header" href="#logging-19">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230220 ZQ init.</li>
</ul>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->


                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">

        </nav>

    </div>




    <script>
        window.playground_copyable = true;
    </script>


    <script src="elasticlunr.min.js" charset="utf-8"></script>
    <script src="mark.min.js" charset="utf-8"></script>
    <script src="searcher.js" charset="utf-8"></script>

    <script src="clipboard.min.js" charset="utf-8"></script>
    <script src="highlight.js" charset="utf-8"></script>
    <script src="book.js" charset="utf-8"></script>

    <!-- Custom JS scripts -->

    <script>
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>

    <hr />

    <p style="text-align:center">

        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议"
                style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
        本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可;-)

    </p>
    <hr />

    <script src="https://utteranc.es/client.js" repo="zhrust/comments" issue-term="pathname" label="✨💬✨"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>

</html>