<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>be Rustaceans</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="如何成为一名合格的 Rustacean ? 肯定有个过程, 这儿记录了私人这个转化过程...">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/style.css">


</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="abt/index.html"><strong aria-hidden="true">1.</strong> 成为 Rustacean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="abt/gh-pages.html"><strong aria-hidden="true">1.1.</strong> gh-pages</a></li><li class="chapter-item "><a href="abt/zhrust.html"><strong aria-hidden="true">1.2.</strong> zhrust</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">自学练习</li><li class="spacer"></li><li class="chapter-item expanded "><a href="101/index.html"><strong aria-hidden="true">2.</strong> Rust 学习</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="101/chatgpt101.html"><strong aria-hidden="true">2.1.</strong> 伴学ChatGPT</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="101/chat_dyn101.html"><strong aria-hidden="true">2.1.1.</strong> dyn 初步</a></li></ol></li><li class="chapter-item "><a href="101/idioms.html"><strong aria-hidden="true">2.2.</strong> idioms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="101/idiom325_create_a_queue.html"><strong aria-hidden="true">2.2.1.</strong> idiom#325:构造队列</a></li></ol></li><li class="chapter-item "><a href="101/quiz.html"><strong aria-hidden="true">2.3.</strong> Quiz.rs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="101/quiz_1.html"><strong aria-hidden="true">2.3.1.</strong> Quiz#1</a></li></ol></li><li class="chapter-item "><a href="101/exercism.html"><strong aria-hidden="true">2.4.</strong> Exercism</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="101/ex42all-your-base.html"><strong aria-hidden="true">2.4.1.</strong> 42:all-your-base</a></li><li class="chapter-item "><a href="101/ex43Allergies.html"><strong aria-hidden="true">2.4.2.</strong> 43:Allergies</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">实践🌚🌘🌗🌖🌝</li><li class="spacer"></li><li class="chapter-item expanded "><a href="dev/index.html"><strong aria-hidden="true">3.</strong> Rust 开发</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/dama-projects.html"><strong aria-hidden="true">3.1.</strong> 小作品</a></li><li class="chapter-item "><a href="dev/tui4cli.html"><strong aria-hidden="true">3.2.</strong> TUI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/cli_nnera.html"><strong aria-hidden="true">3.2.1.</strong> 🌖 NNera</a></li><li class="chapter-item "><a href="dev/cli_ferris_art.html"><strong aria-hidden="true">3.2.2.</strong> 🌝 Ferris艺术</a></li><li class="chapter-item "><a href="dev/cli_bxmr.html"><strong aria-hidden="true">3.2.3.</strong> 🌝 BXMr</a></li><li class="chapter-item "><a href="dev/cli_rss4mdbook.html"><strong aria-hidden="true">3.2.4.</strong> 🌝 RSS4mdbook</a></li><li class="chapter-item "><a href="dev/cli_yuzu.html"><strong aria-hidden="true">3.2.5.</strong> 🌚 Yuzu</a></li></ol></li><li class="chapter-item "><a href="dev/web4async.html"><strong aria-hidden="true">3.3.</strong> 异步</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/tokio.html"><strong aria-hidden="true">3.3.1.</strong> Tokio</a></li><li class="chapter-item "><a href="dev/graphql.html"><strong aria-hidden="true">3.3.2.</strong> GraphQL</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.4.</strong> TTD</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust-unit-test-everything-wanted-know.html"><strong aria-hidden="true">3.4.1.</strong> Rust 单元测试得知道的一切</a></li><li class="chapter-item "><a href="dev/debug_rust_with_codelldb.html"><strong aria-hidden="true">3.4.2.</strong> CodeLLDB</a></li></ol></li><li class="chapter-item "><a href="dev/gui4web.html"><strong aria-hidden="true">3.5.</strong> GUI</a></li><li class="chapter-item "><a href="dev/embedded_rs.html"><strong aria-hidden="true">3.6.</strong> 嵌入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/emb_rp2040pico.html"><strong aria-hidden="true">3.6.1.</strong> Pico</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.7.</strong> CI/CD</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/cross-compiling.html"><strong aria-hidden="true">3.7.1.</strong> 交叉编译?</a></li></ol></li><li class="chapter-item "><a href="dev/20-things-ive-learned-in-my-20-years-as-a-software-engineer.html"><strong aria-hidden="true">3.8.</strong> 20年来作为软件工程师学到的10件事</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/concepts-i-wish-i-learned-earlier.html"><strong aria-hidden="true">3.8.1.</strong> 希望一早知道的关键概念</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.9.</strong> 实用工具推荐...</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/cli_btm.html"><strong aria-hidden="true">3.9.1.</strong> Bottom</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">工程经验</li><li class="spacer"></li><li class="chapter-item expanded "><a href="tip/index.html"><strong aria-hidden="true">4.</strong> Rust 技能</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tip/awesome4rs.html"><strong aria-hidden="true">4.1.</strong> Awesome.rs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tip/aw4rs_handlebars.html"><strong aria-hidden="true">4.1.1.</strong> Handlebars</a></li><li class="chapter-item "><a href="tip/tracing.html"><strong aria-hidden="true">4.1.2.</strong> tracing 初步</a></li><li class="chapter-item "><a href="tip/open_big_file_speed.html"><strong aria-hidden="true">4.1.3.</strong> 文件加速打开</a></li></ol></li><li class="chapter-item "><a href="tip/rust_min_bug_patterns.html"><strong aria-hidden="true">4.2.</strong> BMP:最小bug模式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tip/manag_growing_proj_with_crates_modules.html"><strong aria-hidden="true">4.2.1.</strong> Crate中合理划分目录</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.3.</strong> anti-OOP</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tip/default-params.html"><strong aria-hidden="true">4.3.1.</strong> OOP:Rust 和默认参数</a></li><li class="chapter-item "><a href="tip/oop-1-encapsulation.html"><strong aria-hidden="true">4.3.2.</strong> Rust 超越OOP,第1部分</a></li><li class="chapter-item "><a href="tip/oop-2-polymorphism.html"><strong aria-hidden="true">4.3.3.</strong> Rust 超越OOP,第2部分</a></li></ol></li><li class="chapter-item "><a href="tip/rust6fun-operator-overloading.html"><strong aria-hidden="true">4.4.</strong> 运算符重载六件趣事</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">笔记嗯哼</li><li class="spacer"></li><li class="chapter-item expanded "><a href="log/index.html"><strong aria-hidden="true">5.</strong> 笔记</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="log/rust101logging.html"><strong aria-hidden="true">5.1.</strong> Rust 课程笔记</a></li><li class="chapter-item "><a href="log/rust-s-ugly-syntax.html"><strong aria-hidden="true">5.2.</strong> Rust 丑句法</a></li><li class="chapter-item "><a href="log/graph-rust-move-copy-borrow.html"><strong aria-hidden="true">5.3.</strong> 图形描述 Rust 中所有权和借用</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.4.</strong> Choas嗯哼</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="log/c101.html"><strong aria-hidden="true">5.4.1.</strong> 0基础入门C?</a></li><li class="spacer"></li></ol></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">be Rustaceans</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/zhrust/rustacean/tree/main/src" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <h1 id="有关如何成为-rustacean"><a class="header" href="#有关如何成为-rustacean">有关&quot;如何成为 Rustacean&quot;...</a></h1>
<blockquote>
<p>as Zoom.Quiet</p>
</blockquote>
<h2 id="background"><a class="header" href="#background">background</a></h2>
<ul>
<li>自学使用 Python 第21年,</li>
<li>看着 Perl7 消失,</li>
<li>看着 Golang 突然变成 G+,</li>
<li>看着 Rust 突然变成显学,</li>
<li>忍不住了...</li>
</ul>
<h2 id="goal"><a class="header" href="#goal">goal</a></h2>
<p>充分复用以往各种技术栈的自学经验,
尽可能合理和效率的完成 Pythoneer -&gt; Rustacean 的转化;
或是外挂?</p>
<p>合适的时候注册到: <a href="https://rustaceans.org/">Rustaceans</a></p>
<h2 id="trace"><a class="header" href="#trace">trace</a></h2>
<ul>
<li>...</li>
<li>230225 mdbook 追加 RRS 失败, 不过, 根据其它公开图书项目的配置, 将菜单折叠了...</li>
<li>230101 锈周刊开始连载: <a href="https://weekly.rs.101.so/2023/RR23W1.html#%E6%96%87%E7%AB%A0%E5%97%AF%E5%93%BC">RR23W1 - Weekly for China Rustaceans</a></li>
<li>221111 最终以 rs.101.so ~ 如此基础的 Rust , 域名发布</li>
<li>221022 仓库创建</li>
<li>220918 确定肯定已经明确开始转化进程</li>
</ul>
<h2 id="refer"><a class="header" href="#refer">refer.</a></h2>
<ul>
<li>大妈:
<ul>
<li>主索引: <a href="https://zoomquiet.io/">mapping -&gt; ZoomQuiet.io {by gen4dot2htm.py vv.190718 at:190911 18:07:32,877571}</a></li>
</ul>
</li>
<li><a href="https://jsfiddle.net/Diggsey/3pdgh52r/embedded/result/">Animated Ferris - JSFiddle</a></li>
</ul>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<ul>
<li>...</li>
<li>221111 ZQ 尝试 .rs 域名失败</li>
<li>221101 ZQ init.</li>
</ul>
<pre><code>           _~`--~_
       \/ /  ^ →  \ ()
         '_   ⎕   _'
         \ '-----' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gh-pages"><a class="header" href="#gh-pages">gh-pages</a></h1>
<blockquote>
<p>免费使用的成本</p>
</blockquote>
<h2 id="background-1"><a class="header" href="#background-1">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>凡是可以编译为 静态网站 的, 都可以通过 gh-pages/GitHub-Pages 服务来进行免费发布;</p>
<h2 id="goal-1"><a class="header" href="#goal-1">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
本地编译好, 嘦 git push ,一切就可以自动完成发布</li>
<li><input disabled="" type="checkbox" checked=""/>
而且发布到指定域名</li>
</ul>
<h2 id="trace-1"><a class="header" href="#trace-1">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li>采购 cn.rust, china.rust 域名</li>
<li>各种尝试, 结果关键网络服务都不解析 .rust 这个根域名</li>
<li>...</li>
</ul>
<h2 id="refer-1"><a class="header" href="#refer-1">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages">验证 GitHub Pages 的自定义域 - GitHub Docs</a></li>
</ul>
<h2 id="logging-1"><a class="header" href="#logging-1">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<pre><code>       _~^+~~_
   \/ /  * ☉  \ \/
     '_   ∧   _'
     \ '--+--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zhrust"><a class="header" href="#zhrust">zhRust</a></h1>
<blockquote>
<p>cn.rust 域名</p>
</blockquote>
<h2 id="background-2"><a class="header" href="#background-2">background</a></h2>
<blockquote>
<p>名正言顺</p>
</blockquote>
<p>Ｒust 发布时间不短了,
rust 相关中文社区比当年 Python 的多不少,
所以, 2022年未很难找到简短好记的域名可以注册了</p>
<h2 id="goal-2"><a class="header" href="#goal-2">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>但是, 总是要有一个 Rust 方向的持续输出域名, 
要求从来不变</p>
<ul>
<li>rust,rustacean 相关</li>
<li>越短越好</li>
<li>越便宜越好</li>
<li>...</li>
</ul>
<h2 id="trace-2"><a class="header" href="#trace-2">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li>原先有 101.camp,101.so 所以尝试 rust.so, 已经没有</li>
<li>又尝试 rustacean.so 还有,只是贵而且又长...</li>
<li>那么 在 namecheap.com 再挖掘一下, 没想到
<ul>
<li>.rust 竟然有这个根域名</li>
<li>立即先注册 cn.rust 以及 china.rust</li>
</ul>
</li>
<li>可惜几天过去 dig 指令依然查不到记录,看来 <code>.rust</code> 还是一个预备根域名,至少中国根还不识别..
<ul>
<li>只能恢复使用 <code>rs.101.so</code> 这个域名</li>
<li>另外将 <code>weekly.rs.101.so</code> 也发布出来开始坚持关注每周社区关键变化...</li>
</ul>
</li>
</ul>
<h2 id="refer-2"><a class="header" href="#refer-2">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://github.com/zhrust">cn|china.rust</a></li>
<li>...</li>
</ul>
<h2 id="logging-2"><a class="header" href="#logging-2">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230101 ZQ 变更域名指向</li>
<li>221230 ZQ init.
<ul>
<li>迁移 utterances 🔮 评注到 https://github.com/zhrust/comments</li>
</ul>
</li>
</ul>
<pre><code>        _~∽+^~_
    () /  o *  \ \/
      '_   𝟂   _'
      | '--+--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学习"><a class="header" href="#学习">学习</a></h1>
<blockquote>
<p>learnning ...</p>
</blockquote>
<h2 id="background-3"><a class="header" href="#background-3">background</a></h2>
<blockquote>
<p>可能背景</p>
</blockquote>
<p>和其它语言不同, Rust 有太多公开的秘密,如果不能快速先习惯一批,
很难写出可以运行的软件来...</p>
<h2 id="goal-3"><a class="header" href="#goal-3">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>最常用的那 20% Rust 常识...以便解决 80% 应用场景</p>
<h2 id="trace-3"><a class="header" href="#trace-3">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"/>
基本概念
<ul>
<li><input disabled="" type="checkbox"/>
所有权/借用/作用域</li>
<li><input disabled="" type="checkbox"/>
Option</li>
<li><input disabled="" type="checkbox"/>
Box</li>
<li><input disabled="" type="checkbox"/>
...</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
核心数据结构,及其常用操作</li>
<li><input disabled="" type="checkbox"/>
推荐工程结构 ~&gt; <a href="https://www.sheshbabu.com/posts/rust-module-system/">Clear explanation of Rust’s module system</a>
<ul>
<li><input disabled="" type="checkbox"/>
crate 以及内部模块管理</li>
<li><input disabled="" type="checkbox" checked=""/>
logging
<ul>
<li>tracing = &quot;0.1&quot;</li>
<li>clia-tracing-config = &quot;0.2&quot;</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
实用开发/调试流程
<ul>
<li><input disabled="" type="checkbox"/>
MVP/ CLI 工程</li>
<li><input disabled="" type="checkbox"/>
MVP/ web 工程</li>
<li><input disabled="" type="checkbox"/>
MVP/ 微服务</li>
<li><input disabled="" type="checkbox"/>
MVP/ 系统服务</li>
<li><input disabled="" type="checkbox"/>
...</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
实效 TDD 流程</li>
<li><input disabled="" type="checkbox"/>
底层调试技巧: gdb ...</li>
</ul>
<h2 id="refer-3"><a class="header" href="#refer-3">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<p>必刷练习:</p>
<ul>
<li><a href="https://github.com/rust-lang/rustlings">GitHub - rust-lang/rustlings: Small exercises to get you used to reading and writing Rust code!</a> ~ 官方大佬亲自编撰的...形式上也充分利用了 Cargo 工具链, 非常的锈...</li>
<li><a href="https://dtolnay.github.io/rust-quiz/1">Rust Quiz #1</a></li>
<li><a href="https://exercism.org/tracks/rust">Rust on Exercism</a></li>
<li>...</li>
</ul>
<h3 id="自锈路径"><a class="header" href="#自锈路径">自锈路径</a></h3>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/11dofu8/i_wanna_be_a_crab/">I wanna be a crab. : rust</a></li>
<li><a href="https://gist.github.com/noxasaxon/7bf5ebf930e281529161e51cd221cf8a">Learn Rust!</a></li>
<li><a href="https://www.freecodecamp.org/news/author/shaun/">Learn Rust Programming Course – Interactive Rust Language Tutorial on Replit</a></li>
<li><a href="https://www.manning.com/books/learn-rust-in-a-month-of-lunches">Learn Rust in a Month of Lunches</a></li>
<li>...</li>
<li><a href="https://www.freecodecamp.org/news/edge-cloud-microservices-with-wasmedge-and-rust/">Michael Yuan - 袁钧涛</a> ~ 天体物理学博士, 早期 JBoss 成员, WEB3 专家...
<ul>
<li><a href="https://www.freecodecamp.org/news/author/michael/">The Top 8 Things I Learned From 4000 Rust Developers</a></li>
<li><a href="https://www.freecodecamp.org/news/learn-rust-with-github-actions/">How to Learn Rust Without Installing Any Software</a> ~ 白嫖专家...
<ul>
<li><a href="https://www.freecodecamp.org/news/learn-programming-in-your-browser-the-right-way/">GitHub Codespaces – How to Code Right in Your Browser with Your Own Cloud Dev Environment</a></li>
</ul>
</li>
<li><a href="https://www.freecodecamp.org/news/create-a-serverless-meme-as-a-service/">How to Create a Serverless Meme-as-a-Service</a></li>
<li><a href="https://www.freecodecamp.org/news/edge-cloud-microservices-with-wasmedge-and-rust/">Edge Cloud Microservices – How to Build High Performance &amp; Secure Apps with WasmEdge and Rust</a></li>
<li>WASM/
<ul>
<li><a href="https://www.freecodecamp.org/news/rust-webassembly-serverless-tencent-cloud/">How to use Rust + WebAssembly to Perform Serverless Machine Learning and Data Visualization in the Cloud</a></li>
<li><a href="https://www.freecodecamp.org/news/build-a-personal-dev-server-on-a-5-dollar-raspberry-pi/">How to Build a Personal Dev Server on a $5 Raspberry Pi</a></li>
</ul>
</li>
</ul>
</li>
<li>...</li>
</ul>
<h3 id="rustcc"><a class="header" href="#rustcc">rustCC</a></h3>
<blockquote>
<p>中文社区:</p>
</blockquote>
<ul>
<li><a href="https://lab.cs.tsinghua.edu.cn/rust/">程序设计训练（Rust）</a> ~2021-2022 年夏季学期起清华大学计算机系开设的《程序设计训练（Rust）》</li>
<li><a href="https://prev.rust-lang.org/zh-CN/documentation.html">Rust 语言文档 · Rust 程序设计语言</a>
<ul>
<li><a href="https://rustwiki.org/docs/">Rust 中文文档 | Rust 文档网</a></li>
<li><a href="https://rustwiki.org/wiki/translate/rust-translation-guide/#tong-yi-fan-yi-zhu-yu-he-gu-ding-yong-yu">Rust 文档翻译指引 | Rust 文档网</a></li>
<li><a href="https://prev.rust-lang.org/zh-CN/faq.html#lifetimes">常见问题解答 · Rust 程序设计语言</a></li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
<h3 id="youtube"><a class="header" href="#youtube">Youtube</a></h3>
<blockquote>
<p>真的是什么都有</p>
</blockquote>
<ul>
<li>各种劝解:
<ul>
<li><a href="https://www.youtube.com/watch?v=sDtQaO5_SOw">Rust Linz, June 2021 - Tim McNamara - How to learn Rust - YouTube</a></li>
</ul>
</li>
<li>110+<a href="https://www.youtube.com/playlist?list=PL3azK8C0kje1DUJbaOqce19j3R_-tIc4_">Rust 编程语言入门教程 [2021] - YouTube</a>
<ul>
<li>94+ <a href="https://www.youtube.com/playlist?list=PLVhhUNGAUIQScqB26DdUq4n1Y2n3auM7X">Rust - YouTube</a>
<ul>
<li>专题:<a href="https://www.youtube.com/watch?v=xhU8KDzL0vA&amp;list=PLVhhUNGAUIQRR7JheZsDaxF_Cd5Pf5slw">rusqlite - YouTube</a></li>
<li><a href="http://ogcrazcalm.blogspot.com/2015/11/sql-cheat-sheet.html">SQL Cheat Sheet | Crazcalm</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/database/sqlite.html#insert-and-select-data">SQLite - Rust Cookbook</a></li>
<li><a href="https://crates.io/crates/rusqlite">rusqlite - crates.io: Rust Package Registry</a></li>
<li><a href="https://doc.rust-lang.org/std/fs/struct.File.html#examples">File in std::fs - Rust</a></li>
</ul>
</li>
<li>42+<a href="https://www.youtube.com/playlist?list=PLVvjrrRCBy2JSHf9tGxGKJ-bYAN_uDCUL">RUST PROGRAMMING TUTORIALS - YouTube</a></li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW">Intro to Rust - YouTube</a></li>
<li>14+<a href="https://www.youtube.com/playlist?list=PLKkEWK6xRmes17LQUEA5bNjYISuCEOTXx">Rust For Starters - YouTube</a></li>
</ul>
</li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8">The Rust Lang Book - YouTube</a></li>
<li>25+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDD5vy2BuSHvFZU0a6RDmgb">Rust Projects - YouTube</a>
<ul>
<li>24+<a href="https://www.youtube.com/playlist?list=PL5dTjWUk_cPYuhHm9_QImW7_u4lr5d6zO">50 RUST Projects - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/@jonhoo">Jon Gjengset - YouTube</a>
<ul>
<li>14+ <a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">Crust of Rust - YouTube</a></li>
<li>14+ <a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFgY2faCIYjJZv_RluGkTlKt">Rust live-coding - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLZaoyhMXgBzoM9bfb5pyUOT3zjnaDdSEP">Rust Talks - YouTube</a>
<ul>
<li>各种畅想...</li>
<li><a href="https://www.youtube.com/playlist?list=PLnhCUtqrIE-zgfmf6hn6fLwhfR_hDSG9T">Contributing to Rustc - YouTube</a> ~ 牛人直播如何为 Rust 编译器贡献特性...</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=_jMSrMex6R0&amp;list=PLFjq8z-aGyQ6t_LGp7wqHsHTYO-pDDx84">Rust - YouTube</a>
<ul>
<li>各种前景分析</li>
<li><a href="https://www.youtube.com/watch?v=qjwWF6K-7uE&amp;list=PLFjq8z-aGyQ78CQu1G3C5CT9ieiNpsnbJ">WebAssembly - YouTube</a> ~ 各种实现应用</li>
</ul>
</li>
<li>...</li>
</ul>
<h3 id="free-books"><a class="header" href="#free-books">free Books</a></h3>
<blockquote>
<p>这个世界上免费好资源太多了...</p>
</blockquote>
<p><a href="https://github.com/EbookFoundation/free-programming-books/blob/main/books/free-programming-books-langs.md#rust">free-programming-books/free-programming-books-langs.md at main · EbookFoundation/free-programming-books</a></p>
<ul>
<li><a href="https://prev.rust-lang.org/zh-CN/documentation.html">Rust 语言文档 · Rust 程序设计语言</a></li>
<li><a href="https://github.com/rust-lang-cn/rustdoc-cn/fork">Rust 中文文档 | Rust 文档网</a></li>
<li><a href="https://tourofrust.com/11_zh-cn.html">Rust 语言之旅 - Let's go on an adventure!</a></li>
<li><a href="https://learnxinyminutes.com/docs/zh-cn/rust-cn/">Y分钟速成X ~ 其中 X=Rust</a>
<ul>
<li><a href="https://wangchujiang.com/rust-cn-document-for-docker/quick-reference/docs/rust.html">Rust 备忘清单 &amp; rust cheatsheet &amp; Quick Reference</a></li>
</ul>
</li>
<li><a href="https://github.com/sger/RustBooks#advanced-books">sger/RustBooks: List of Rust books</a>
<ul>
<li><a href="http://llogiq.github.io/2015/07/15/profiling.html">ctjhoa/rust-learning: A bunch of links to blog posts, articles, videos, etc for learning Rust</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/first.html">Introduction - Learning Rust With Entirely Too Many Linked Lists</a></li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
<h2 id="logging-3"><a class="header" href="#logging-3">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<pre><code>            _~`|-~_
        \) /  O =  \ ()
          '_   ⏡   _'
          | '-----' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="伴学chatgpt"><a class="header" href="#伴学chatgpt">伴学ChatGPT</a></h1>
<blockquote>
<p>chatting for debugging ...</p>
</blockquote>
<h2 id="background-4"><a class="header" href="#background-4">background</a></h2>
<p>通过网络中各种免费教程/图书学习时,
作者文字背后的思考过程无法交流...</p>
<h2 id="goal-4"><a class="header" href="#goal-4">goal</a></h2>
<p>合理使用 ChatGPT 进行提示工程style 学习</p>
<h2 id="trace-4"><a class="header" href="#trace-4">trace</a></h2>
<blockquote>
<p>记录各种舒服的姿势:</p>
</blockquote>
<h3 id="cli-测试姿势"><a class="header" href="#cli-测试姿势">CLI 测试姿势</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>se assert_cmd::Command;
use predicates::prelude::*;
use std::fs;

type TestResult = Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;;

#[test]
fn dies_no_args() -&gt; TestResult {
    let mut cmd = Command::cargo_bin(&quot;echor&quot;)?; 
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;USAGE&quot;));
    Ok(()) 
}

#[test]
fn hello1() -&gt; TestResult {
    let expected = fs::read_to_string(&quot;tests/expected/hello1.txt&quot;)?;
    let mut cmd = Command::cargo_bin(&quot;echor&quot;)?;
    cmd.arg(&quot;Hello there&quot;).assert().success().stdout(expected);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Q:</p>
</blockquote>
<p>以上代码中, 为什么要专门定义 TestResult 类型?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>在 Rust 中，测试函数必须返回 Result&lt;(), Box<dyn std::error::Error>&gt; 类型。这是因为测试框架需要处理测试函数中可能出现的错误，并将这些错误转换为测试结果。如果测试函数返回的是一个普通的错误类型，测试框架无法对其进行处理，因此需要使用 Result 类型。TestResult 类型只是为了更清晰地表明这是一个测试函数返回的结果类型，并没有特殊的含义。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>Result&lt;(), Box<dyn std::error::Error>&gt; 这一类型, 具体有什么要求?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>Result&lt;(), Box<dyn std::error::Error>&gt; 是 Rust 中测试函数的标准返回类型。具体要求如下：</p>
<ul>
<li>返回类型为 Result，表示测试函数可以返回成功或失败的结果。</li>
<li>() 表示测试函数不返回任何值，因为测试函数的目的是验证代码的行为是否正确，而不是生成有用的输出。</li>
<li>Box<dyn std::error::Error> 表示测试函数返回的错误类型可以是任何实现了 std::error::Error trait 的类型，而且这个类型被包装在 Box 中。这是因为测试框架需要能够处理各种可能的错误类型，包括编译错误、运行时错误等等。使用 Box<dyn std::error::Error> 可以使测试函数返回任何实现了 std::error::Error trait 的错误类型，同时又能够在测试框架中方便地处理这些错误。</li>
</ul>
<p>总之，Result&lt;(), Box<dyn std::error::Error>&gt; 表示测试函数可以返回成功或失败的结果，不返回任何值，但是可以返回任何实现了 std::error::Error trait 的错误类型。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>任何实现了 std::error::Error trait 的错误类型 一般有什么类型包含这种 trait? 能举例说明嘛?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>任何实现了 std::error::Error trait 的类型都可以作为测试函数返回的错误类型。在 Rust 中，标准库中的很多错误类型都实现了 std::error::Error trait，例如：</p>
<ul>
<li>std::io::Error：表示 I/O 操作中可能出现的错误，如文件读写错误、网络通信错误等。</li>
<li>std::num::ParseIntError：表示将字符串转换为数字时可能出现的错误，如字符串不符合数字格式等。</li>
<li>std::env::VarError：表示获取环境变量时可能出现的错误，如环境变量不存在等。</li>
<li>serde_json::Error：表示处理 JSON 数据时可能出现的错误，如 JSON 数据格式错误等。</li>
</ul>
<p>这些类型都实现了 std::error::Error trait，因此可以作为测试函数返回的错误类型。在测试函数中，如果某个操作出现了这些错误，可以将错误包装成 Box<dyn std::error::Error> 类型返回，这样测试框架就可以处理这些错误并将其视为测试失败。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>如果要为自定义新数据类型追加这种 trait 有哪些可行方案? 举例说明一下?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>如果要为自定义的新数据类型追加 std::error::Error trait，有以下几种可行的方案：</p>
<ul>
<li>实现 std::error::Error trait：在新数据类型的实现代码中手动实现 std::error::Error trait，包括实现 description 方法和 source 方法。这样就可以将新数据类型作为测试函数的错误类型返回。例如：</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;

#[derive(Debug)]
struct MyError {
    message: String,
}

impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;{}&quot;, self.message)
    }
}

impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.message
    }

    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let result = Err(MyError {
        message: &quot;An error occurred&quot;.to_owned(),
    });
    result.map_err(Box::new)?;
    Ok(())
}</code></pre></pre>
<ul>
<li>使用 thiserror crate：thiserror 是一个 Rust crate，它提供了一种更简单的方法来实现 std::error::Error trait。使用 thiserror crate 可以通过宏来自动生成错误类型的实现代码，包括实现 std::error::Error trait。例如：</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;
use thiserror::Error;

#[derive(Debug, Error)]
#[error(&quot;An error occurred: {message}&quot;)]
struct MyError {
    message: String,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let result = Err(MyError {
        message: &quot;An error occurred&quot;.to_owned(),
    });
    result.map_err(Box::new)?;
    Ok(())
}
</code></pre></pre>
<p>... 在上面的代码中，使用 thiserror crate 定义了一个 MyError 类型，通过 #[derive(Error)] 宏自动生成了实现 std::error::Error trait 的代码。此时，MyError 类型就可以作为测试函数的错误类型返回了。</p>
<p>无论使用哪种方法，一旦为新数据类型追加了 std::error::Error trait，就可以将其作为测试函数的错误类型返回了。例如，下面是使用自定义错误类型进行测试的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
struct MyError {
    message: String,
}

impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;{}&quot;, self.message)
    }
}

impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.message
    }

    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}

fn foo() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    Err(MyError {
        message: &quot;An error occurred&quot;.to_owned(),
    })
}

#[test]
fn test_foo() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let result = foo();
    assert!(result.is_err());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="crate-思路"><a class="header" href="#crate-思路">crate 思路</a></h3>
<blockquote>
<p>Q:</p>
</blockquote>
<p>如何将一个 CLI 工具项目发布为一个 crate? 要进行哪些改造? 以及要注意什么?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>要将一个 CLI 工具项目发布为一个 crate，你需要进行以下步骤：</p>
<ul>
<li>将你的 CLI 工具项目打包成一个库。在 Rust 中，库文件通常以 lib.rs 文件为入口点，并将 CLI 代码重构为函数或结构体方法。这样可以将你的代码解耦，并使其更易于测试和重用。</li>
<li>在你的项目根目录中创建一个 Cargo.toml 文件，其中包含以下信息：
<ul>
<li>包的名称、版本号和作者信息。</li>
<li>项目的描述信息。</li>
<li>项目的依赖项和其版本要求。</li>
<li>包的类型，例如库或二进制文件。</li>
<li>包的许可证类型。</li>
</ul>
</li>
<li>将你的代码上传到 crates.io。首先，你需要创建一个 crates.io 帐户。然后，你可以使用 cargo login 命令登录并上传你的代码。在上传前，确保你的代码已经完成了测试，并且包含了合适的文档和许可证信息。</li>
<li>给你的 crate 添加文档。Rust 社区非常注重代码文档，因此你需要确保你的 crate 包含了适当的文档和注释。你可以使用 Rust 内置的文档工具来生成文档，并将其上传到 crates.io。</li>
<li>更新你的项目文档和 README。在将你的 crate 发布到 crates.io 后，你需要更新你的项目文档和 README 文件，以便其他开发者可以使用你的 crate。</li>
</ul>
<p>在发布你的 crate 前，你需要注意以下几点：</p>
<ul>
<li>你需要确保你的代码质量和可靠性。这包括确保你的代码通过了单元测试和集成测试，并尽可能避免使用未经测试的依赖项。</li>
<li>你需要确保你的代码符合 Rust 社区的代码规范和最佳实践。</li>
<li>你需要确保你的 crate 包含了适当的许可证信息，并确保你有权发布你的代码。</li>
<li>你需要确保你的 crate 包含了合适的文档和注释，以便其他开发者可以轻松地使用你的代码。</li>
</ul>
<p>总之，将一个 CLI 工具项目发布为一个 crate 需要对代码进行一些改造，确保代码质量和可靠性，并且遵循 Rust 社区的最佳实践和规范。发布前，你需要确保你的代码包含了适当的文档和许可证信息，并更新你的项目文档和 README 文件。</p>
<h3 id="toml-作为配置"><a class="header" href="#toml-作为配置">.toml 作为配置</a></h3>
<blockquote>
<p>Q:</p>
</blockquote>
<p>rudt 中读写 .toml 文件, 最推荐的 create 是哪个? 如何使用?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>如果你需要在 Rust 中读写 TOML 文件，可以使用 toml crate。这个 crate 可以在 Cargo.toml 文件中添加以下依赖来使用：</p>
<pre><code class="language-toml">[dependencies]
toml = &quot;0.5.8&quot;
</code></pre>
<p>以下是一个简单的示例代码，演示如何使用 toml crate 读取一个名为 &quot;config.toml&quot; 的 TOML 文件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs;
use toml::Value;

fn main() {
    // 读取文件
    let contents = fs::read_to_string(&quot;config.toml&quot;)
        .expect(&quot;Something went wrong reading the file&quot;);

    // 解析 TOML
    let parsed_toml: Value = toml::from_str(&amp;contents).unwrap();

    // 访问值
    let title = parsed_toml[&quot;title&quot;].as_str().unwrap();
    let subtitle = parsed_toml[&quot;subtitle&quot;].as_str().unwrap();

    println!(&quot;{}: {}&quot;, title, subtitle);
}</code></pre></pre>
<p>在上面的代码中，首先使用 fs::read_to_string 函数读取 TOML 文件的内容。然后，使用 toml::from_str 函数将内容解析为 toml::Value 类型的值。接下来，可以访问解析后的 TOML 值，例如 parsed_toml[&quot;title&quot;].as_str().unwrap() 用于获取 TOML 文件中的 &quot;title&quot; 值。最后，将这些值打印到控制台。</p>
<p>如果你需要将数据写入 TOML 文件，则可以使用 toml crate 的 to_string 函数将 toml::Value 类型的值转换为 TOML 格式的字符串，然后使用 fs::write 函数将字符串写入文件。</p>
<p>以下是一个简单的示例代码，演示如何使用 toml crate 写入一个名为 &quot;config.toml&quot; 的 TOML 文件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs;
use toml::Value;

fn main() {
    // 创建一个 `toml::Value` 类型的值
    let mut toml_value = Value::new();
    toml_value[&quot;title&quot;] = &quot;My Title&quot;.into();
    toml_value[&quot;subtitle&quot;] = &quot;My Subtitle&quot;.into();

    // 将值转换为 TOML 格式的字符串
    let toml_str = toml::to_string(&amp;toml_value).unwrap();

    // 写入文件
    fs::write(&quot;config.toml&quot;, toml_str).expect(&quot;Something went wrong writing the file&quot;);
}
</code></pre></pre>
<p>在上面的代码中，首先创建一个 toml::Value 类型的值，该值包含要写入 TOML 文件的数据。然后，使用 toml::to_string 函数将该值转换为 TOML 格式的字符串。最后，使用 fs::write 函数将字符串写入文件。</p>
<h3 id="展开-bufreader"><a class="header" href="#展开-bufreader">展开 BufReader</a></h3>
<blockquote>
<p>Q:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let f = File::open(&quot;log.txt&quot;)?;
    let mut reader = BufReader::new(f);

    let mut line = String::new();
    let len = reader.read_line(&amp;mut line)?;
    println!(&quot;First line is {} bytes long&quot;, len);
    Ok(())
}</code></pre></pre>
<p>如何将这段代码修改为循环将指定文件所有行内容逐一输出?</p>
<blockquote>
<p>PS: 从 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html#examples">std::io::BufReader - Rust</a> 抄的</p>
</blockquote>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>要循环输出文件的所有行内容，您可以在一个循环中使用BufReader的read_line方法。每次迭代时，该方法会读取文件中的一行，并将其存储在给定的字符串变量中。当没有更多的行可以读取时，该方法将返回一个长度为0的结果，这是跳出循环的信号。</p>
<p>以下是修改后的代码示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let f = File::open(&quot;log.txt&quot;)?;
    let reader = BufReader::new(f);

    for line in reader.lines() {
        println!(&quot;{}&quot;, line?);
    }
    Ok(())
}</code></pre></pre>
<p>在这个例子中，我们使用了reader.lines()方法，它返回一个std::io::Lines迭代器。每次迭代时，该迭代器都会读取文件中的一行，并将其包装在一个std::io::Result<String>中返回。我们可以使用?操作符来解包这个结果，如果读取失败，它会将错误传播到main函数的调用方。</p>
<p>通过这种方式，我们可以逐行读取文件并将每一行内容输出到控制台。</p>
<blockquote>
<p>Q:
std::io::prelude 是什么库? 引用了什么进来? 用在哪儿了?</p>
</blockquote>
<blockquote>
<p>GPT:</p>
</blockquote>
<p><code>std::io::prelude</code> 是一个模块，包含了一些常见的 I/O trait 和类型的预定义导入。这些预定义导入使得开发者能够轻松地使用 Rust 标准库中的 I/O 功能，同时也减少了大量的代码重复。</p>
<p>在 Rust 代码中，通过引入std::io::prelude模块来使用预定义导入，通常会出现在处理 I/O 相关操作的代码中。这个模块包含了以下几个 trait 的预定义导入：</p>
<ul>
<li>Read: 用于读取数据的 trait。</li>
<li>BufRead: 用于读取缓冲区的 trait。</li>
<li>Write: 用于写入数据的 trait。</li>
</ul>
<p>这些 trait 都被用于在 Rust 中进行 I/O 操作，因此它们经常会被其他的 I/O 模块或库使用。例如，在上面提供的示例代码中，我们使用了std::io::prelude来导入Read trait，从而使用BufReader的read_line方法读取文件中的每一行内容。</p>
<blockquote>
<p>A: 
如何对循环中的 line 进行类似 contains 的判定呢?</p>
</blockquote>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>要对读取的每一行内容进行包含（contains）的判定，您可以在for循环内使用if语句，对每一行进行检查。以下是示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let f = File::open(&quot;log.txt&quot;)?;
    let reader = BufReader::new(f);

    for line in reader.lines() {
        let line_content = line?;
        if line_content.contains(&quot;Error&quot;) {
            println!(&quot;{}&quot;, line_content);
        }
    }
    Ok(())
}</code></pre></pre>
<p>在这个例子中，我们使用contains方法检查每一行内容是否包含字符串&quot;Error&quot;。如果是，我们将该行内容打印到控制台。否则，我们将跳过该行并继续读取文件的下一行。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>对应代码修改为:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = File::open(&amp;args.path)
        .expect(&quot;could NOT read the file&quot;);
    let reader = BufReader::new(f);

    let mut line = String::new();
    for line in reader.lines() {
            let line_content = line?;
            if line_content.contains(&quot;Error&quot;) {
                println!(&quot;{}&quot;, line_content);
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>但是报错:</p>
<pre><code>error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
  --&gt; src/main.rs:66:36
   |
24 | fn main() {
   | --------- this function should return `Result` or `Option` to accept `?`
...
66 |             let line_content = line?;
   |                                    ^ cannot use the `?` operator in a function that returns `()`
   |
   = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>应该如何解决?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>该错误是因为在main函数中，我们不能在循环中使用?操作符。?操作符只能用于返回Result或Option的函数或方法中，它会在发生错误时自动将错误返回给调用者。</p>
<p>在main函数中，我们必须手动处理错误并决定如何处理它们。在这种情况下，我们可以简单地将错误打印到控制台。以下是示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    for line in reader.lines() {
        if let Ok(line_content) = line {
            if line_content.contains(&quot;Error&quot;) {
                println!(&quot;{}&quot;, line_content);
            }
        } else {
            eprintln!(&quot;Error while reading file&quot;);
            return;
        }
    }
}</code></pre></pre>
<p>在这个例子中，我们使用if let语句检查读取每一行是否成功。如果成功，我们检查行内容是否包含字符串&quot;Error&quot;，如果是则将其打印到控制台。如果读取行时发生错误，我们将错误打印到标准错误流（stderr），并退出程序。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>看起来这里有多层 if 不是很 rusty, 有其它方案来达成相同效果嘛?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>您可以使用match语句来代替嵌套的if let语句，以避免多层嵌套和提高代码可读性。以下是使用match语句重写的示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    for line in reader.lines() {
        match line {
            Ok(line_content) =&gt; {
                if line_content.contains(&quot;Error&quot;) {
                    println!(&quot;{}&quot;, line_content);
                }
            }
            Err(_) =&gt; {
                eprintln!(&quot;Error while reading file&quot;);
                return;
            }
        }
    }
}</code></pre></pre>
<p>在这个例子中，我们使用match语句匹配line的值。如果读取行成功，我们使用Ok(line_content)分支来处理行内容，如果行内容包含字符串&quot;Error&quot;，则将其打印到控制台。如果读取行时出现错误，我们使用Err(_)分支来处理错误，并将错误打印到标准错误流（stderr），并退出程序。</p>
<p>相比使用嵌套的if let语句，match语句更加清晰和简洁。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>没错, match 看起来优雅多了, 不过, 还有其它方案嘛?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>是的，除了使用match语句，还有一种更简洁的方法来实现类似的效果。可以使用filter_map方法和std::result::Result::ok函数来过滤行并将它们转换为可选的字符串。然后，您可以使用for循环迭代这些字符串并将它们打印出来。以下是使用filter_map和std::result::Result::ok函数的示例代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    for line in reader.lines().filter_map(Result::ok).filter(|line| line.contains(&quot;Error&quot;)) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre></pre>
<p>在这个例子中，我们首先调用filter_map方法来过滤掉那些读取行时返回错误的行，并将其转换为可选的字符串。然后，我们使用filter方法来过滤掉那些不包含字符串&quot;Error&quot;的行。最后，我们使用for循环迭代这些字符串，并将它们打印到控制台。</p>
<p>相比使用match语句和嵌套的if let语句，这种方法更加简洁和优雅。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>还有更加优雅的方案嘛?</p>
<blockquote>
<p>GPT:
当然，Rust 的标准库提供了非常强大的迭代器和函数式编程工具箱，可以让代码更加简洁和优雅。</p>
</blockquote>
<p>在这个例子中，您可以使用filter方法和闭包来过滤掉不包含&quot;Error&quot;的行，然后使用map方法和unwrap函数将可选的行转换为字符串并将其打印到控制台上。这是代码的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} &lt;path_to_file&gt;&quot;, args[0]);
        return;
    }

    let f = File::open(&amp;args[1]).expect(&quot;Could not read file&quot;);
    let reader = BufReader::new(f);

    reader.lines()
          .filter(|line| line.as_ref().map(|s| s.contains(&quot;Error&quot;)).unwrap_or(false))
          .map(|line| line.unwrap())
          .for_each(|line| println!(&quot;{}&quot;, line));
}</code></pre></pre>
<p>在这个例子中，我们首先调用filter方法来过滤掉那些不包含字符串&quot;Error&quot;的行。由于lines方法返回的是一个包含Result&lt;Option<String>&gt;的迭代器，我们需要在闭包中使用as_ref方法来将Result&lt;Option<String>&gt;转换为Option&lt;&amp;String&gt;。然后，我们使用map方法和unwrap函数来将可选的行转换为字符串，并将其打印到控制台上。</p>
<p>使用这种方法，我们可以将代码进一步简化，并更加清晰地表达我们的意图。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>没错, 这样又简洁,又整齐,而且意义明确;
看起来 迭代器和函数式工具有很多, 类似 filter 和 map 的内置工具还有哪些? 分别有什么优雅的实用案例?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>Rust 的标准库提供了丰富的迭代器和函数式编程工具，包括：</p>
<ul>
<li>map：将一个迭代器中的每个元素转换为另一种类型的元素，通常用于数据类型转换和计算。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let squares: Vec&lt;i32&gt; = numbers.iter().map(|n| n * n).collect();
// squares is [1, 4, 9, 16, 25]
<span class="boring">}</span></code></pre></pre>
<ul>
<li>filter：根据某个条件过滤出迭代器中的元素，通常用于数据过滤和筛选。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let evens: Vec&lt;i32&gt; = numbers.iter().filter(|n| n % 2 == 0).collect();
// evens is [2, 4]
<span class="boring">}</span></code></pre></pre>
<ul>
<li>fold：使用某种累加器（初始值）和一个闭包来聚合迭代器中的元素，通常用于求和、平均值和字符串拼接等操作。
<ul>
<li>示例：计算一个数字向量中所有元素的和。</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let sum: i32 = numbers.iter().fold(0, |acc, n| acc + n);
// sum is 15
<span class="boring">}</span></code></pre></pre>
<ul>
<li>flat_map：将一个迭代器中的每个元素转换为另一个迭代器，然后将所有的迭代器合并为一个迭代器。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let words = vec![&quot;hello world&quot;, &quot;foo bar&quot;, &quot;baz qux&quot;];
let letters: Vec&lt;char&gt; = words.iter().flat_map(|s| s.chars()).collect();
// letters is ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', 'f', 'o', 'o', ' ', 'b', 'a', 'r', 'b', 'a', 'z', ' ', 'q', 'u', 'x']
<span class="boring">}</span></code></pre></pre>
<ul>
<li>any 和 all：检查迭代器中是否存在任意元素或所有元素都满足某个条件。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let any_odd = numbers.iter().any(|n| n % 2 == 1);
let all_even = numbers.iter().all(|n| n % 2 == 0);
// any_odd is true, all_even is false
<span class="boring">}</span></code></pre></pre>
<ul>
<li>enumerate: 枚举迭代器中的元素，并将元素索引和值组成一个元组返回。
<ul>
<li>示例：遍历一个字符串向量并打印每个元素的索引和值。</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
for (i, s) in v.iter().enumerate() {
    println!(&quot;{}: {}&quot;, i, s);
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>zip：将两个迭代器合并为一个元素对的迭代器。
<ul>
<li>示例：从两个向量中取出对应位置的元素并组成一个新的向量</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
let letters = vec!['a', 'b', 'c'];
let pairs: Vec&lt;(i32, char)&gt; = numbers.iter().zip(letters.iter()).collect();
// pairs is [(1, 'a'), (2, 'b'), (3, 'c')]

<span class="boring">}</span></code></pre></pre>
<p>当使用迭代器处理数据时，有时需要对数据进行分段处理。在这种情况下，可以使用 take 和 skip 方法。</p>
<ul>
<li>take：从一个集合中取出前几个元素。例如，从一个包含所有人的向量中取出前 10 个人。
<ul>
<li>take(n) 方法会创建一个新的迭代器，它只包含原始迭代器的前 n 个元素。例如：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let first_three = numbers.iter().take(3);
for number in first_three {
    println!(&quot;{}&quot;, number);
}
// 输出:
// 1
// 2
// 3
<span class="boring">}</span></code></pre></pre>
<ul>
<li>skip：跳过一个集合中的前几个元素。例如，从一个包含所有人的向量中跳过前 10 个人，然后返回剩余的所有人。
<ul>
<li>skip(n) 方法会创建一个新的迭代器，它跳过原始迭代器的前 n 个元素，然后迭代其余的元素。例如：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let last_two = numbers.iter().skip(3);
for number in last_two {
    println!(&quot;{}&quot;, number);
}
// 输出:
// 4
// 5

<span class="boring">}</span></code></pre></pre>
<ul>
<li>chain：将两个集合连接在一起，然后返回一个新的集合。例如，将一个包含所有男性的向量和一个包含所有女性的向量连接在一起，然后返回一个包含所有人的向量。
<ul>
<li>另一个常见的迭代器方法是 chain 方法。它接收另一个迭代器作为参数，将其添加到当前迭代器的末尾，并返回一个新的迭代器。例如：</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers1 = vec![1, 2, 3];
let numbers2 = vec![4, 5, 6];
let all_numbers = numbers1.iter().chain(numbers2.iter());
for number in all_numbers {
    println!(&quot;{}&quot;, number);
}
// 输出:
// 1
// 2
// 3
// 4
// 5
// 6

<span class="boring">}</span></code></pre></pre>
<p>在上面的示例中，我们首先创建了两个向量 numbers1 和 numbers2，然后将它们合并为一个新的迭代器 all_numbers。最后，我们遍历 all_numbers 并输出其中的所有元素。</p>
<p>这些是 Rust 中一些常见的迭代器方法和函数式工具，您可以根据自己的需要来选择使用它们。在 Rust 中，迭代器和函数式编程被广泛应用于各种场景，例如处理集合、过滤和排序数据、处理文本等等。通过使用这些工具，您可以编写更加简洁、优雅、高效和安全的代码。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>发现还有 try_fold 之类带有 try_ 的迭代器,一般是用在什么场景中的?</p>
<blockquote>
<p>GPT:</p>
</blockquote>
<p>try_fold 方法是一个带有 try_ 前缀的迭代器方法，它类似于 fold 方法，但是它允许在迭代器处理过程中发生错误，并将错误传递给调用方进行处理。try_fold 方法的使用场景通常是处理可能会失败的操作的迭代器元素序列，例如网络请求或文件 I/O 操作。</p>
<p>try_fold 方法有两个参数：一个初始累加器和一个闭包，闭包将当前累加器的值和迭代器的下一个元素作为参数，并返回一个 Result 值。如果闭包返回一个 Ok 值，则 try_fold 方法会继续迭代。如果闭包返回一个 Err 值，则 try_fold 方法会立即停止迭代并将错误传递给调用方。</p>
<p>以下是一个简单的示例，演示如何使用 try_fold 方法来计算向量中所有元素的和，其中每个元素都是 Result&lt;i32, String&gt; 类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let vec = vec![Ok(1), Ok(2), Err(&quot;failed&quot;.to_string()), Ok(3)];
    let sum = vec
        .into_iter()
        .try_fold(0, |acc, x| x.map(|n| acc + n));
    match sum {
        Ok(result) =&gt; println!(&quot;Sum is {}&quot;, result),
        Err(error) =&gt; println!(&quot;Error: {}&quot;, error),
    }
}</code></pre></pre>
<p>在上面的代码中，我们首先创建了一个向量 vec，其中包含三个 Ok 值和一个 Err 值。然后我们使用 into_iter 方法将向量转换为迭代器，使用 try_fold 方法来计算所有元素的和，其中使用 map 方法将 Ok 值映射到它们的整数值，并忽略 Err 值。最后，我们使用 match 来处理可能的错误和结果。</p>
<h2 id="refer-4"><a class="header" href="#refer-4">refer.</a></h2>
<blockquote>
<p>其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...</p>
</blockquote>
<ul>
<li>🌝🦀 <a href="https://github.com/sigoden/aichat" title="sigoden/aichat: Chat with ChatGPT-3.5 in the terminal.">sigoden/aichat: Chat with ChatGPT-3.5 in the terminal.</a>
<ul>
<li><a href="https://github.com/f/awesome-chatgpt-prompts">f/awesome-chatgpt-prompts: This repo includes ChatGPT prompt curation to use ChatGPT better.</a> ~ 提示工程师技巧...</li>
<li>...</li>
</ul>
</li>
<li>std::
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#">Iterator in std::iter - Rust</a></li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
<h2 id="logging-4"><a class="header" href="#logging-4">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230224 ZQ init.</li>
</ul>
<pre><code>          _~^~`~_
      () /  - ◶  \ \/
        '_   ⏝   _'
        &gt; '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn动静态多态初步"><a class="header" href="#dyn动静态多态初步">dyn:动/静态多态初步</a></h1>
<blockquote>
<p>学伴ChatGPT, chatting for debugging ...</p>
</blockquote>
<h2 id="background-5"><a class="header" href="#background-5">background</a></h2>
<blockquote>
<p>Rust 中文社区中的讨论...</p>
</blockquote>
<p><img src="https://ipic.zoomquiet.top/2023-02-28-%E9%A3%9E%E4%B9%A620230228-150444.jpg" alt="这种用if let就会报错，必须分开写吗" /></p>
<h2 id="goal-5"><a class="header" href="#goal-5">goal</a></h2>
<p>合理完成调试...</p>
<h2 id="trace-5"><a class="header" href="#trace-5">trace</a></h2>
<p>有同学建议:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(exists) = conn.exists::&lt;bool, _&gt;(key).await {
    unimplemented!()
}
<span class="boring">}</span></code></pre></pre>
<p>于是开始探问:</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>if let Ok(exists) = conn.exists::&lt;bool, _&gt;(key).await {
}
这句代码什么意思?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>这句代码是Rust语言的代码，用于在Redis数据库中检查指定键是否存在，并异步地返回一个结果。</p>
<p>具体来说，这段代码首先调用一个Redis连接对象（conn）上的exists方法来检查给定的key是否存在。该方法返回一个Result&lt;bool, _&gt;类型的结果，其中Ok表示检查操作成功，exists表示指定的key存在，否则返回一个错误对象（_表示任意的错误类型）。</p>
<p>然后，这段代码使用if let语法，将返回的结果绑定到一个名为exists的变量上。如果exists是Ok类型，则意味着检查操作成功，并且可以继续执行if代码块中的逻辑来处理key存在的情况。反之，如果exists是Err类型，则意味着检查操作失败，并且需要在else代码块中处理错误情况。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>一般在 else 中如如何处理错误?
如果 exists 是 Ok , 这时 那个 key 是如何进入 if 代码块进行处理的?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>在 else 中，一般会处理检查操作失败的情况，例如记录日志、返回错误信息等。具体如何处理错误，取决于代码的设计和业务需求。以下是一个简单的例子，展示了在 else 中如何记录错误信息：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(exists) = conn.exists::&lt;bool, _&gt;(key).await {
    if exists {
        // 如果 key 存在，则执行相应的逻辑
    } else {
        // 如果 key 不存在，则执行相应的逻辑
    }
} else {
    // 如果检查操作失败，则记录错误信息并返回错误
    eprintln!(&quot;Failed to check if key exists: {:?}&quot;, key);
    return Err(MyError::RedisError);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Q:</p>
</blockquote>
<p>在上面的代码中，如果检查操作成功，则根据 exists 的值分别执行相应的逻辑。如果检查操作失败，则使用 else 代码块来记录错误信息，并返回一个自定义的错误类型（MyError::RedisError）。</p>
<p>如果 exists 是 Ok，则表示检查操作成功，exists 变量将包含一个布尔值，指示给定的 key 是否存在。在这种情况下，程序将进入 if 代码块，根据 exists 的值执行相应的逻辑。例如，如果 exists 为 true，则表示 key 存在，程序将执行相应的逻辑来处理 key 存在的情况。反之，如果 exists 为 false，则表示 key 不存在，程序将执行相应的逻辑来处理 key 不存在的情况。</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>是的，你是对的。在你提供的代码片段中，key 是在之前定义的。在这种情况下，我们可以假设在这段代码之前，已经定义了一个名为 key 的变量，用于指定要检查的 Redis 键名。</p>
<p>例如，以下是一个使用 Redis 进行键值存储的简单示例，其中使用了类似于你提供的代码片段：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use redis::AsyncCommands;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let client = redis::Client::open(&quot;redis://127.0.0.1/&quot;).unwrap();
    let mut conn = client.get_async_connection().await?;

    // 定义要检查的 Redis 键名
    let key = &quot;my_key&quot;;

    // 检查指定的键是否存在
    if let Ok(exists) = conn.exists::&lt;bool, _&gt;(key).await {
        if exists {
            // 如果 key 存在，则执行相应的逻辑
            let value: String = conn.get(key).await?;
            println!(&quot;{}: {}&quot;, key, value);
        } else {
            // 如果 key 不存在，则执行相应的逻辑
            conn.set(key, &quot;Hello, Redis!&quot;).await?;
            println!(&quot;Set {} successfully&quot;, key);
        }
    } else {
        // 如果检查操作失败，则记录错误信息并返回错误
        eprintln!(&quot;Failed to check if key exists: {:?}&quot;, key);
        return Err(&quot;RedisError&quot;.into());
    }

    Ok(())
}
</code></pre></pre>
<p>在这个示例中，我们首先定义了一个名为 key 的变量，用于指定要检查的 Redis 键名。然后，我们使用 conn.exists 方法检查指定的键是否存在。如果检查操作成功，则根据检查结果的值（即变量 exists）执行相应的逻辑。如果检查操作失败，则记录错误信息并返回错误。在这个例子中，我们使用 eprintln 来记录错误信息，并使用 return Err(...) 返回一个字符串类型的错误信息。最后，我们使用 Ok(()) 返回一个表示成功的结果。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>这个函数的返回值 Result&lt;(), Box<dyn std::error::Error>&gt;
是什么含义, 应该如何理解?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>这个函数的返回值是一个 Result 类型，其中 () 表示一个空元组（也称为 unit type）。在 Rust 中，() 用于表示没有值的情况，类似于其他语言中的 void 类型。在这个函数的上下文中，() 表示函数没有返回任何有用的值，只是执行了一些操作。因此，我们可以将这个函数的返回值解读为“表示函数执行是否成功的结果，如果成功则不返回任何值，否则返回一个实现了 std::error::Error trait 的错误类型”。</p>
<p>Box<dyn std::error::Error> 是一个 trait 对象，它表示一个可以作为错误类型的任何类型，只要该类型实现了 std::error::Error trait。在 Rust 中，std::error::Error trait 是一个通用的错误处理 trait，它定义了一些方法和属性，用于处理和显示错误信息。实现 std::error::Error trait 的类型可以是任何具体的类型，例如字符串、自定义结构体、枚举等等。但是，为了方便和通用性，我们通常会将实现了 std::error::Error trait 的类型封装在一个 Box 中，以实现动态分配和回收内存的效果。</p>
<p>因此，将 Box<dyn std::error::Error> 作为函数的返回值，表示该函数可能会返回一个实现了 std::error::Error trait 的错误类型。当函数执行成功时，它将返回一个 Ok(()) 值，表示函数执行成功且没有返回任何值。当函数执行失败时，它将返回一个 Err 值，其中包含一个实现了 std::error::Error trait 的错误类型，该错误类型可以提供有关错误的更多信息，例如错误消息、错误码、堆栈跟踪等等。在实际使用中，我们通常会根据错误类型来处理错误，例如记录错误日志、返回错误码、重试操作等等。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>这里的 dyn 是什么语法?为什么要包在一个 Box 中?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>dyn 是 Rust 语言中的一个关键字，用于表示动态派发的类型。在 Rust 中，存在两种类型的多态：静态多态和动态多态。静态多态是通过泛型实现的，可以在编译时确定具体的类型，而动态多态是通过 trait 对象实现的，只有在运行时才能确定具体的类型。</p>
<p>在 Rust 中，Box 是一个智能指针类型，用于在堆上分配和管理动态分配的值。由于 trait 对象的大小和类型在编译时是不确定的，因此不能直接将 trait 对象放在栈上或者嵌入到其他类型中。为了方便和安全地使用 trait 对象，我们通常会将其封装在一个 Box 中，以实现动态分配和回收内存的效果。</p>
<p>因此，在 Result&lt;(), Box<dyn std::error::Error>&gt; 这个类型中，Box<dyn std::error::Error> 表示一个实现了 std::error::Error trait 的错误类型，它可能是任何具体的类型，例如字符串、自定义结构体、枚举等等。由于该类型是动态分配的，因此需要使用 Box 来管理其内存。最后，Result&lt;(), Box<dyn std::error::Error>&gt; 表示一个成功时不返回任何值，失败时返回一个实现了 std::error::Error trait 的错误类型的结果类型。</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>对应 dyn 的静态多态是什么, 能举个例子嘛?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>对应于 dyn 的静态多态是 Rust 中的泛型，用于在编译时确定具体的类型。在 Rust 中，泛型可以通过类型参数来表示，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: std::ops::Add&lt;Output = T&gt; + Copy,
{
    x + y
}

let x = 1;
let y = 2;
let z = add(x, y);

<span class="boring">}</span></code></pre></pre>
<p>在上面的例子中，add 函数使用了泛型类型 T，它表示任意类型。函数签名中的 where 关键字表示泛型类型 T 需要满足的一些约束，例如实现了 std::ops::Add trait，并且该 trait 的 Output 关联类型为 T，同时还需要实现 Copy trait。这些约束保证了类型 T 支持加法操作，并且可以进行值的拷贝操作。最后，add 函数返回类型为 T，表示函数的返回值类型和参数类型相同。</p>
<p>在使用泛型的时候，可以在函数调用时指定具体的类型，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
let y = 2;
let z = add::&lt;i32&gt;(x, y);
<span class="boring">}</span></code></pre></pre>
<p>在上面的例子中，add::<i32> 表示调用 add 函数，并将类型参数 T 指定为 i32 类型。由于 i32 类型实现了 std::ops::Add trait 和 Copy trait，因此满足函数签名中的约束，可以成功调用函数并返回值。</p>
<p>总之，静态多态和动态多态是 Rust 中的两种多态方式，它们分别用于在编译时和运行时确定具体的类型。在 Rust 中，泛型用于静态多态，通过类型参数在编译时确定具体的类型，而 trait 对象用于动态多态，只有在运行时才能确定具体的类型。</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>也就是说静态多态用 T 来声明, 动态多态用 dyn 声明? 上述那个 add 的示例用 dyn 来定义应该如何写?</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>不完全正确，静态多态和动态多态都可以使用泛型来实现，只不过它们使用方式和目的略有不同。具体来说，泛型主要用于静态多态，可以在编译时确定具体的类型，而 trait 对象主要用于动态多态，可以在运行时确定具体的类型。因此，泛型通常用于函数、结构体、枚举等静态类型的定义中，而 trait 对象通常用于函数参数、返回值、实现动态分发等需要动态类型的场景中。</p>
<p>对于你的问题，如果要将上面的 add 函数改写成使用 trait 对象实现的动态多态，可以将参数类型从泛型 T 改为 trait 对象 dyn std::ops::Add&lt;Output = T&gt;，如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy,
    dyn std::ops::Add&lt;Output = T&gt; + 'static,
{
    x + y
}

let x = 1;
let y = 2;
let z = add(x, y);

<span class="boring">}</span></code></pre></pre>
<p>在上面的例子中，add 函数使用了 trait 对象 dyn std::ops::Add&lt;Output = T&gt;，它表示实现了 std::ops::Add trait，并且该 trait 的 Output 关联类型为 T 的任意类型。由于 trait 对象的大小和类型在编译时是不确定的，因此需要使用 dyn 关键字来表示动态类型。同时，为了使 trait 对象能够在函数内部被存储和使用，还需要使用 'static lifetime 来保证 trait 对象的生命周期至少和整个程序的生命周期一样长。</p>
<p>值得注意的是，在使用 trait 对象时，需要将 trait 对象的实现限制在编译时已知的范围内。例如，在上面的例子中，由于 add 函数需要使用 x + y 表达式，因此要求 trait 对象 dyn std::ops::Add&lt;Output = T&gt; 的实现类型必须实现了 Copy trait，以便进行值的拷贝操作。这样一来，即使 trait 对象的实现类型是在运行时动态确定的，也能够保证它们满足 Copy trait 的要求，从而避免出现运行时错误。</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>那么 trait 对象也能完成静态多态的任务嘛? 举行说明?</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>Trait 对象主要用于实现动态多态，因为它允许在运行时根据具体类型来调用不同的方法实现。而泛型主要用于实现静态多态，因为它允许在编译时确定具体类型，并且可以根据具体类型来进行代码优化等操作。</p>
<p>虽然 trait 对象不能像泛型一样进行编译时优化，但是在某些情况下也可以完成一些静态多态的任务。例如，假设我们有一个函数 print，它可以打印不同类型的值。如果使用泛型来实现，可以定义如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print&lt;T: std::fmt::Display&gt;(value: T) {
    println!(&quot;{}&quot;, value);
}

<span class="boring">}</span></code></pre></pre>
<p>在这个例子中，我们使用了泛型来实现静态多态，函数的参数类型 T 在编译时就已经确定，因此可以在函数内部使用 std::fmt::Display trait 来打印不同类型的值。</p>
<p>但是，如果我们希望在运行时动态确定参数类型，就可以使用 trait 对象来实现。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print(value: &amp;dyn std::fmt::Display) {
    println!(&quot;{}&quot;, value);
}

let s = &quot;Hello, world!&quot;;
let n = 42;
print(&amp;s);
print(&amp;n);

<span class="boring">}</span></code></pre></pre>
<p>在这个例子中，我们使用了 trait 对象 &amp;dyn std::fmt::Display 来实现动态多态，函数的参数类型在运行时才确定。在函数内部，我们可以使用 std::fmt::Display trait 来打印不同类型的值，由于 trait 对象的大小和类型在编译时是不确定的，因此不能像泛型那样进行编译时优化，但是可以在运行时根据具体类型进行动态分发，从而完成类似于静态多态的任务。</p>
<p>总之，尽管 trait 对象和泛型都可以用于多态编程，但它们各自适用于不同的场景和任务，需要根据实际情况选择合适的方式。泛型适用于在编译时确定类型的场景，而 trait 对象适用于在运行时确定类型的场景，同时，两者也可以结合使用来实现更加灵活和高效的编程方式。</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>&lt;T: std::fmt::Display&gt; 是什么语法? 起什么作用? 如何理解? 有其它表述形式嘛?</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>&lt;T: std::fmt::Display&gt; 是一个泛型参数声明，用于在函数中定义一个泛型类型 T，该类型必须实现 std::fmt::Display trait。它的作用是让函数能够处理不同类型的参数，同时要求这些参数必须实现 Display trait。</p>
<p>这个语法可以理解为：“定义一个名为 T 的泛型类型，它必须实现 std::fmt::Display trait。”</p>
<p>另外，还有一种等效的语法，可以使用 where 关键字来声明泛型类型的约束条件，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print&lt;T&gt;(value: T)
where
    T: std::fmt::Display,
{
    println!(&quot;{}&quot;, value);
}
<span class="boring">}</span></code></pre></pre>
<p>这个语法的意思和前面的语法是等价的，它表示：“定义一个名为 T 的泛型类型，在函数体内部使用它，并要求它必须实现 std::fmt::Display trait。”</p>
<p>在 Rust 中，这两种语法是等价的，选择哪种语法主要取决于个人的编码习惯和喜好。通常来说，第一种语法适用于简单的泛型函数，而第二种语法适用于更复杂的泛型函数，因为它可以将类型约束条件单独列出来，使得函数的声明更加清晰和易读。</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>明白了, 举例说明如何兼容没有实现 std::fmt::Display trait 的对象传入后, 如何安全响应?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>如果我们需要在函数中处理可能没有实现 std::fmt::Display trait 的类型，一种常见的做法是使用 Rust 提供的 Option 或 Result 类型来表示这种情况，并在函数中进行处理。</p>
<p>例如，我们可以将 print 函数改为返回一个 Result&lt;(), Box<dyn std::error::Error>&gt; 类型的结果，这样就可以在函数中处理可能出现的错误：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn print&lt;T: std::fmt::Display&gt;(value: T) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!(&quot;{}&quot;, value);
    Ok(())
}

<span class="boring">}</span></code></pre></pre>
<p>在这个版本的 print 函数中，我们使用 Result 类型来表示函数执行的结果，并使用 Box<dyn std::error::Error> 类型来表示可能出现的错误。如果传入的参数没有实现 std::fmt::Display trait，则在执行 println! 时会抛出一个错误，这个错误会被捕获并返回一个 Err 值。</p>
<p>调用方可以根据 Result 类型的返回值来判断函数是否执行成功，如果返回了 Err 值，则说明函数执行过程中出现了错误。调用方可以选择忽略这个错误，或者将错误信息打印出来，以便于调试和排查问题。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let value = 42;
    print(value)?;
    Ok(())
}
</code></pre></pre>
<p>在这个例子中，我们将一个整数类型的值 42 传给了 print 函数，由于整数类型没有实现 std::fmt::Display trait，因此在函数中会抛出一个错误，这个错误会被捕获并返回一个 Err 值。在 main 函数中，我们使用 ? 操作符来处理这个错误，这样如果 print 函数执行失败，main 函数也会返回一个 Err 值，程序会打印出错误信息。</p>
<blockquote>
<p>PS:进一步的, 综合之前介绍,可以用 where 进行外部声明,简化函数声明:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print&lt;T&gt;(value: T) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;
where
    T: std::fmt::Display,
{
    println!(&quot;{}&quot;, value);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A:</p>
</blockquote>
<p>我是说 Result&lt;(), Box<dyn std::error::Error>&gt; 这里也太长了, 有对应简洁形式嘛?</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>在 Rust 中，可以使用 type 关键字来给某种类型起一个别名，从而在代码中使用这个别名来代替原始的类型。这样可以使得代码更加易读和易于维护。</p>
<p>对于 Result&lt;(), Box<dyn std::error::Error>&gt; 这样的类型，我们可以使用 type 关键字来为它起一个别名，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type MyResult = Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;;

<span class="boring">}</span></code></pre></pre>
<p>这个代码片段定义了一个名为 MyResult 的别名，它表示的类型和 Result&lt;(), Box<dyn std::error::Error>&gt; 是一样的。有了这个别名，我们可以在代码中使用 MyResult 来代替 Result&lt;(), Box<dyn std::error::Error>&gt;，从而使得代码更加易读。</p>
<p>例如，我们可以使用这个别名来定义 print 函数的返回类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print&lt;T: std::fmt::Display&gt;(value: T) -&gt; MyResult {
    println!(&quot;{}&quot;, value);
    Ok(())
}

<span class="boring">}</span></code></pre></pre>
<p>这个版本的 print 函数和之前的版本相比，唯一的区别就是使用了 MyResult 这个别名来代替了 Result&lt;(), Box<dyn std::error::Error>&gt;，这样可以使得函数声明更加简洁易读。</p>
<p>调用这个版本的 print 函数和之前的版本是一样的，例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() -&gt; MyResult {
    let value = 42;
    print(value)?;
    Ok(())
}
</code></pre></pre>
<h2 id="refer-5"><a class="header" href="#refer-5">refer.</a></h2>
<blockquote>
<p>其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...</p>
</blockquote>
<p><a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Generic Types, Traits, and Lifetimes - The Rust Programming Language</a></p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">Generic Data Types - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#defining-a-trait">Traits: Defining Shared Behavior - The Rust Programming Language</a></li>
</ul>
<p>...这些链接对应的是 Rust 官方文档中的《Rust 程序设计语言》一书中的相关章节，包含了静态多态和动态多态的基本概念、使用方法和示例代码等内容，非常适合初学者阅读学习。除此之外，还可以参考 Rust 官方文档中的其他部分，如《Rust 标准库 API 参考》和《Rust 风格指南》等，来深入理解 Rust 中的泛型和 trait 等概念。</p>
<pre><code>       _~~|-~_
   () /  ◕ -  \ (/
     '_   ⎵   _'
     | '-----' |

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idioms"><a class="header" href="#idioms">idioms</a></h1>
<blockquote>
<p>在 Python 称 Pythonic 的东西, 在其它语言就是 -style</p>
</blockquote>
<h2 id="background-6"><a class="header" href="#background-6">background</a></h2>
<p>如果有其它开发语言经验, 很应该第一时间可将对应习惯迁移到新语言中</p>
<h2 id="goal-6"><a class="header" href="#goal-6">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>认真收集日常常见的各种微任务,
并对比 Python 代码来理解 Rust 的...</p>
<h2 id="trace-6"><a class="header" href="#trace-6">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<h2 id="refer-6"><a class="header" href="#refer-6">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://programming-idioms.org/all-idioms">programming-idioms.org</a></li>
<li><a href="https://www.dotnetperls.com/s#rust">Dot Net Perls: Search</a></li>
<li><a href="https://rosettacode.org/wiki/Queue/Usage#Rust">Queue/Usage - Rosetta Code</a></li>
<li>...</li>
</ul>
<h2 id="logging-5"><a class="header" href="#logging-5">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>220228 ZQ init.</li>
</ul>
<pre><code>         _~-|`~_
     () /  o -  \ (/
       '_   ⏡   _'
       | '--⌄--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idiom325构造队列"><a class="header" href="#idiom325构造队列">idiom#325:构造队列</a></h1>
<p>SEE: <a href="https://programming-idioms.org/idiom/325/create-a-queue/6291/rust">Create a queue, in Rust</a></p>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<pre><code class="language-python">import queue

q = queue.Queue()
q.put(x)
q.put(y)
z = q.get()
</code></pre>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::VecDeque;

fn main() {
    let mut q = VecDeque::new();
    q.push_back(&quot;zoom&quot;);
    q.push_back(&quot;quiet&quot;);
    let z = q.pop_front(); 
    println!(&quot;1st item ~&gt; {}&quot;,z.unwrap());
}</code></pre></pre>
<h2 id="humm"><a class="header" href="#humm">Humm?</a></h2>
<ul>
<li>内置模块</li>
<li>函数名/流程/...基本一致</li>
<li>..记住就好</li>
</ul>
<pre><code>          _~-+^~_
      \) /  + =  \ \/
        '_   △   _'
        ( '--∽--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-quiz"><a class="header" href="#rust-quiz">Rust Quiz</a></h1>
<h2 id="background-7"><a class="header" href="#background-7">background</a></h2>
<p>必刷的官方练习题集</p>
<p><a href="https://dtolnay.github.io/rust-quiz/1">Rust Quiz #1</a></p>
<h2 id="goal-7"><a class="header" href="#goal-7">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>当前 36 个问题都看一遍</p>
<h2 id="trace-7"><a class="header" href="#trace-7">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<h2 id="refer-7"><a class="header" href="#refer-7">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://github.com/rust-lang/rustlings/">学习 Rust - Rust 程序设计语言</a></p>
<h2 id="logging-6"><a class="header" href="#logging-6">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230304 ZQ init.</li>
</ul>
<pre><code>        _~^-^~_
    () /  ◴ O  \ (/
      '_   ⎕   _'
      | '--~--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-quiz-1"><a class="header" href="#rust-quiz-1">Rust Quiz #1</a></h1>
<h2 id="background-8"><a class="header" href="#background-8">background</a></h2>
<p>What is the output of this Rust program?</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! m {
    ($($s:stmt)*) =&gt; {
        $(
            { stringify!($s); 1 }
        )&lt;&lt;*
    };
}

fn main() {
    print!(
        &quot;{}{}{}&quot;,
        m! { return || true },
        m! { (return) || true },
        m! { {return} || true },
    );
}</code></pre></pre>
<h2 id="trace-8"><a class="header" href="#trace-8">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>不是, 等等, 第一题就是宏展开嘛?</p>
<blockquote>
<p>Q:</p>
</blockquote>
<p>运行结果为什么是 112 ?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>代码的运行结果是112，原因是宏展开后生成的代码中有三个块表达式，每个块表达式内部包含了一个字符串字面量和数字1，然后将这个数字1左移一位，相当于乘以2，最后返回的是三个块表达式结果的和。</p>
<p>具体来说，宏 m 的作用是将传入的代码块中的每个语句转化为一个块表达式，其中每个块表达式包含了一个字符串字面量和数字1，即 { stringify!($s); 1 }。stringify!($s) 是 Rust 中的一个内置宏，用于将传入的代码转化为一个字符串字面量。</p>
<p>在 main 函数中，分别传入了三个不同的代码块：</p>
<ul>
<li>m! { return || true } 展开后生成的代码块是 { stringify!(return || true); 1 }，其中的 stringify!(return || true) 会将代码块转化为字符串 &quot;return || true&quot;，所以这个代码块的结果是 { &quot;return || true&quot;; 1 }。</li>
<li>m! { (return) || true } 展开后生成的代码块是 { stringify!((return) || true); 1 }，其中的 stringify!((return) || true) 会将代码块转化为字符串 &quot;(return) || true&quot;，所以这个代码块的结果是 { &quot;(return) || true&quot;; 1 }。</li>
<li>m! { {return} || true } 展开后生成的代码块是 { stringify!({return} || true); 1 }，其中的 stringify!({return} || true) 会将代码块转化为字符串 &quot;{return} || true&quot;，所以这个代码块的结果是 { &quot;{return} || true&quot;; 1 }。</li>
</ul>
<p>由于每个块表达式内部都有数字1，因此最终的结果是将三个块表达式的结果相加，即 1 + 2 + 4 = 7，然后将结果左移一位，相当于乘以2，即 7 &lt;&lt; 1 = 14。最后，这个结果会被传入 print! 宏中，因此输出的结果是 112。</p>
<p>对应展开后的代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// $ cargo expand 

#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
fn main() {
    {
        ::std::io::_print(
            format_args!(
                &quot;{0}{1}{2}&quot;, 
                { &quot;return (|| true);&quot;; 1 }, 
                { &quot;(return) || true;&quot;; 1 }, 
                { &quot;{ return }&quot;; 1 } &lt;&lt; { &quot;|| true;&quot;; 1 }
            ),
        );
    };
}</code></pre></pre>
<h2 id="refer-8"><a class="header" href="#refer-8">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://github.com/rust-lang/rustlings/">学习 Rust - Rust 程序设计语言</a></p>
<ul>
<li><a href="https://zjp-cn.github.io/tlborm/syntax-extensions/debugging.html">调试 - The Little Book of Rust Macros （Rust 宏小册）</a>
<ul>
<li><a href="https://github.com/dtolnay/cargo-expand">dtolnay/cargo-expand: Subcommand to show result of macro expansion</a>
<ul>
<li>虽然内核有支持, 但是, 包装一下好使用</li>
<li>cargo install cargo-expand</li>
<li>rustup component add rustfmt</li>
<li>就可随时用 $ cargo expand 来观察展开后的代码</li>
<li>等同:
<ul>
<li>$ cargo rustc --profile=check -- -Zunpretty=expanded</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021">Rust Playground</a></li>
</ul>
</li>
<li></li>
</ul>
<pre><code>      _~^*∽~_
  \/ /  ◷ ☉  \ \/
    '_   ⎵   _'
    | '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercism"><a class="header" href="#exercism">Exercism</a></h1>
<blockquote>
<p>练习主义</p>
</blockquote>
<h2 id="background-9"><a class="header" href="#background-9">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/about">About Exercism</a></p>
<p>是一个神奇的网站</p>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.30.38.jpg" alt="" /></p>
<p>一是个专注用练习题来学习各种开发语言的网站,
免费,包含越来越多的语言</p>
<h2 id="goal-8"><a class="header" href="#goal-8">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust">Rust on Exercism</a></p>
<p>至少先刷完这 103 道题目, 然后, 再开发具体的实用工具;</p>
<h2 id="trace-9"><a class="header" href="#trace-9">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.31.48.jpg" alt="rust" /></p>
<p>不过最终是乱序来的</p>
<h2 id="refer-9"><a class="header" href="#refer-9">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<p><a href="https://cheats.rs/">Rust Language Cheat Sheet</a></p>
<ul>
<li><a href="https://juejin.cn/post/7146144676532191262">16｜数据结构：Vec<T>、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？ - 掘金</a></li>
<li>...</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a16a825f50d4d34866d432c15fa3ebd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="" /></p>
<h2 id="logging-7"><a class="header" href="#logging-7">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<pre><code>           _~^*`~_
       () /  ◴ O  \ (/
         '_   ⎵   _'
         | '--+--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rs42all-your-base"><a class="header" href="#rs42all-your-base">rs42all-your-base</a></h1>
<blockquote>
<p>所有进制</p>
</blockquote>
<h2 id="background-10"><a class="header" href="#background-10">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/docs/tracks/rust">All Your Base in Rust on Exercism</a></p>
<h2 id="logging-8"><a class="header" href="#logging-8">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id="try_fold"><a class="header" href="#try_fold">try_fold()</a></h3>
<blockquote>
<p>表达能力的典范...</p>
</blockquote>
<h2 id="refer-10"><a class="header" href="#refer-10">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Positional_notation#External_links">Positional notation - Wikipedia</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html">Iterator in std::iter - Rust</a>
<ul>
<li><a href="https://qiita.com/lo48576/items/34887794c146042aebf1">Rustのイテレータの網羅的かつ大雑把な紹介 - Qiita</a></li>
<li><a href="https://zenn.dev/megeton/articles/fb6266bcb6aa1b">Ruby脳のためのRust配列系メソッドまとめ</a></li>
<li>...</li>
</ul>
</li>
<li><a href="https://rustcc.cn/article?id=2f4b3a15-7874-4c68-b9d8-5a717e9a3af0">rust新手的一个问题：fold和scan。 - Rust语言中文社区</a>
<ul>
<li><a href="https://juejin.cn/post/7067102952602746910">抛弃Rust的try...catch和null检查 - 掘金</a></li>
<li>...</li>
</ul>
</li>
</ul>
<pre><code>         _~-|^~_
     () /  ? o  \ \/
       '_   ⏝   _'
       ( '--.--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ex43allergies"><a class="header" href="#ex43allergies">ex43Allergies</a></h1>
<blockquote>
<p>过敏源</p>
</blockquote>
<h2 id="background-11"><a class="header" href="#background-11">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust/exercises/allergies">Allergies in Rust on Exercism</a></p>
<h2 id="logging-9"><a class="header" href="#logging-9">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id=""><a class="header" href="#">&amp;</a></h3>
<blockquote>
<p>现实世界的 与计算</p>
</blockquote>
<h2 id="refer-11"><a class="header" href="#refer-11">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://hltj.me/lang/2016/11/07/10m-letters.html">由“千万字母表问题”看多范式编程语言 | 灰蓝时光</a>
<ul>
<li><a href="http://www.nct9.ne.jp/m_hiroi/linux/rust14.html">Linux Programming / お気楽 Rust プログラミング超入門</a></li>
</ul>
</li>
<li>...</li>
</ul>
<pre><code>      _~~-~~_
  \) /  ◷ ☉  \ \/
    '_   ⏝   _'
    ( '-----' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<blockquote>
<p>projects ...</p>
</blockquote>
<h2 id="background-12"><a class="header" href="#background-12">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>开发语言学习, 不用来开发真实项目, 基本是表演学习行为了...</p>
<h2 id="goal-9"><a class="header" href="#goal-9">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>一组日常要用工具, 原创/再制/...</p>
<p>关键是积累一组可用作品, 打底儿.</p>
<h2 id="trace-10"><a class="header" href="#trace-10">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>MVP ~ 最小可行工程能力?</p>
<ul>
<li><input disabled="" type="checkbox"/>
工程结构
<ul>
<li><input disabled="" type="checkbox"/>
crate/library/pakage/workspace/project 划分和使用
<ul>
<li><input disabled="" type="checkbox" checked=""/>
package ~ cargo new 出来的东西</li>
<li><input disabled="" type="checkbox" checked=""/>
crate ~ src/*.rs 
<ul>
<li>二进制包
<ul>
<li><code>src/main.rs</code> </li>
<li><code>src/bin/*.rs</code> </li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
library ~ src/lib.rs</li>
<li><input disabled="" type="checkbox" checked=""/>
module ~ mod 圈定的代码块
- 绝对/相对引用路径
- self/super/crate/... ~&gt; <a href="https://rustwiki.org/zh-CN/rust-by-example/mod/split.html">super 和 self - 通过例子学 Rust 中文版</a>
- rustc 1.30+ 要求:
- 同级目录创建 mod 名同名目录
- 在其中创建子模块.rs 文件
- 此时才能在 mod 名同名 .rs 中使用 mod 来引用
- lib.rs ~ 检索更方便
- crates.rs ~ 下载最稳定</li>
<li><input disabled="" type="checkbox" checked=""/>
use 和可见性...
<ul>
<li>结构体和枚举的可见性...<a href="https://rustwiki.org/zh-CN/rust-by-example/mod/struct_visibility.html#%E5%8F%82%E8%A7%81">结构体的可见性 - 通过例子学 Rust 中文版</a></li>
<li>优先使用最细粒度(引入函数、结构体等)的引用方式，如果引起了某种麻烦(例如前面两种情况)，再使用引入模块的方式</li>
<li>不同模块同名 as 别名引用</li>
<li>use xxx::{self, yyy}; ~ 集成引用</li>
<li>use std::collections::*; ~ 只用来引入 tests</li>
<li>pub use ~ 引入后再导出(所有权无处不在...)</li>
<li>pub(in crate::a) ... 限制可见性语法
<ul>
<li>pub 意味着可见性无任何限制</li>
<li>pub(crate) 表示在当前包可见</li>
<li>pub(self) 在当前模块可见</li>
<li>pub(super) 在父模块可见</li>
<li>pub(in <path>) 表示在某个路径代表的模块中可见，其中 <code>path</code> 必须是父模块或者祖先模块</li>
<li>~&gt; <a href="https://course.rs/basic/crate-module/use.html#%E9%99%90%E5%88%B6%E5%8F%AF%E8%A7%81%E6%80%A7%E8%AF%AD%E6%B3%95">使用 use 引入模块及受限可见性 - Rust语言圣经(Rust Course)</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
workspace</li>
<li><input disabled="" type="checkbox"/>
project</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
模块切分/命名..艺术?</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://wangchujiang.com/rust-cn-document-for-docker/cargo/reference/publishing.html#%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA-crate">将 crate 发布到 Crates.io - Cargo 手册 中文版</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
基本应用
<ul>
<li><input disabled="" type="checkbox" checked=""/>
基本调试循环 ~ 配合 tracing 和 log 目录...</li>
<li><input disabled="" type="checkbox"/>
基本单元测试</li>
<li><input disabled="" type="checkbox" checked=""/>
基本编译发行 ~ cargo build</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
分布式
<ul>
<li><input disabled="" type="checkbox"/>
调试/追踪</li>
<li><input disabled="" type="checkbox"/>
CI/CD</li>
<li><input disabled="" type="checkbox"/>
...</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
核心概念/技能
<ul>
<li><input disabled="" type="checkbox"/>
内建数据类型</li>
<li><input disabled="" type="checkbox"/>
智能指针</li>
<li><input disabled="" type="checkbox"/>
所有权和借用</li>
<li><input disabled="" type="checkbox"/>
泛型</li>
<li><input disabled="" type="checkbox"/>
trait</li>
<li><input disabled="" type="checkbox"/>
生命周期</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
高级工程技巧
<ul>
<li><input disabled="" type="checkbox"/>
宏</li>
<li><input disabled="" type="checkbox"/>
GDB</li>
<li><input disabled="" type="checkbox"/>
...</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
嵌入式
<ul>
<li><input disabled="" type="checkbox"/>
基本工具箱</li>
<li><input disabled="" type="checkbox"/>
Pico</li>
<li><input disabled="" type="checkbox"/>
...</li>
</ul>
</li>
</ul>
<h2 id="refer-12"><a class="header" href="#refer-12">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://www.contributor-covenant.org/zh-cn/version/2/1/code_of_conduct/">贡献者公约/Contributor Covenant:</a></p>
<ul>
<li><a href="https://llever.com/gentle-intro/readme.zh.html">介绍 - Rust 的绅士介绍</a></li>
<li><a href="https://www.sheshbabu.com/posts/rust-module-system/">Clear explanation of Rust’s module system</a></li>
<li><a href="https://wangchujiang.com/rust-cn-document-for-docker/cargo/reference/publishing.html#%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA-crate">将 crate 发布到 Crates.io - Cargo 手册 中文版</a></li>
<li>各种值得尝试的作品类型:
<ul>
<li>SSG: <a href="https://www.youtube.com/watch?v=9uAy8skUVsc">Tutorial: Building a Blog in Rust - Static File Server - YouTube</a></li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
<h2 id="logging-10"><a class="header" href="#logging-10">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230228 ZQ ++🦀🦀🦀</li>
<li>221023 ZQ init.</li>
</ul>
<pre><code>           _~`+~~_
       () /  ♡ ◷  \ \/
         '_   V   _'
         \ '--~--' |

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践作品"><a class="header" href="#实践作品">实践作品</a></h1>
<h2 id="background-13"><a class="header" href="#background-13">background</a></h2>
<p>学习一门新语言, 最高效的姿势就是拿来使用了</p>
<h2 id="goal-10"><a class="header" href="#goal-10">goal</a></h2>
<p>将当前日常要用的各种工具, 转化为 rust 版本的...</p>
<h2 id="plan"><a class="header" href="#plan">plan</a></h2>
<p>进展图例: </p>
<ul>
<li>
<p>🌚 ~ 萌动</p>
</li>
<li>
<p>🌘 ~ 开搞</p>
</li>
<li>
<p>🌗 ~ 折腾</p>
</li>
<li>
<p>🌖 ~ 可用</p>
</li>
<li>
<p>🌝 ~ 发布</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>🌖NNera ~ 牛妞纪元</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
CLI</li>
<li><input disabled="" type="checkbox"/>
发布</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>🌝bxmr ~ BXM 输入码表维护器</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
CLI</li>
<li><input disabled="" type="checkbox" checked=""/>
发布</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>🌝 ferris ~ 吉祥物ASCII-art 生成器</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
CLI</li>
<li><input disabled="" type="checkbox" checked=""/>
crate</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>🌝<a href="dev//dev/cli_rss4mdbook.html">RSS4mdbook</a> 自制 RSS 生成器</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>🌚 yuzu ~ 柚子, 简陋的私用短址生成器</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
SUUID ~ 短 UUID 生成器; 组合标准的 UUID+Md5 就好
<ul>
<li><input disabled="" type="checkbox"/>
自制, 参考: <a href="https://github.com/skorokithakis/shortuuid/blob/master/shortuuid/main.py">shortuuid/main.py at master · skorokithakis/shortuuid</a></li>
<li><input disabled="" type="checkbox"/>
crate</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
CLI</li>
<li><input disabled="" type="checkbox"/>
发布
<ul>
<li><input disabled="" type="checkbox"/>
RESTful ... etc</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p>🌚 Yazi ~ 睚眦 git 仓库行为分析器</p>
<ul>
<li><input disabled="" type="checkbox"/>
CLI</li>
<li><input disabled="" type="checkbox"/>
发布</li>
</ul>
</li>
</ul>
<h2 id="trace-11"><a class="header" href="#trace-11">trace</a></h2>
<blockquote>
<p>追踪笔记</p>
</blockquote>
<p>掌握 rust 到什么程度就能给自己开始小工具了?</p>
<ul>
<li>目测嘦会用 RA 就可以了...呗?</li>
<li>...</li>
</ul>
<h3 id="crateio"><a class="header" href="#crateio">crate.io</a></h3>
<blockquote>
<p>cargo login 
首先偶到的问题:</p>
</blockquote>
<pre><code>$ cargo login [自己的 crate.io token]
error: crates-io is replaced with non-remote-registry source registry `tuna`;
include `--registry crates-io` to use crates.io
</code></pre>
<p>意味着你的 Rust 包管理器 Cargo 正在使用一个名为 tuna 的本地 Rust 包源，而不是默认的远程源 crates.io。</p>
<p>根据提示首次使用官方源:</p>
<pre><code>$ cargo login [自己的 crate.io token] --registry crates-io -v
    Updating crates.io index
     Running `git fetch --force --update-head-ok 'https://github.com/rust-lang/crates.io-index' '+HEAD:refs/remotes/origin/HEAD'`
       Login token for `crates-io` saved
</code></pre>
<p>追加上目标仓库 <code>--registry crates-io</code> 就可以完成了...
(大约3分钟后)</p>
<blockquote>
<p>cargo package</p>
</blockquote>
<pre><code>$ cargo package
...
   Compiling proc-macro2 v1.0.51
   Compiling quote v1.0.23
   Compiling unicode-ident v1.0.6
   Compiling libc v0.2.139
    ...
   Compiling ferris-actor v0.1.42 (/path/2/../ferris-actor/target/package/ferris-actor-0.1.42)
    Finished dev [unoptimized + debuginfo] target(s) in 20.85s
    Packaged 12 files, 40.8KiB (13.1KiB compressed)
</code></pre>
<p>不错, 自动化完成所有</p>
<blockquote>
<p>cargo publish --registry crates-io</p>
</blockquote>
<pre><code>$ cargo publish --registry crates-io
    Updating crates.io index
...
   Compiling proc-macro2 v1.0.51
   Compiling unicode-ident v1.0.6
   Compiling quote v1.0.23
   ...

</code></pre>
<p>同样, 必须追加上 <code>--registry crates-io</code> 目标仓库参数</p>
<blockquote>
<p>LICENSES</p>
</blockquote>
<pre><code>...
    Packaged 12 files, 40.9KiB (13.1KiB compressed)
   Uploading ferris-actor v0.1.42 (/Users/zoomq/Exercism/proj/ferris-actor)
error: failed to publish to registry at https://crates.io

</code></pre>
<p>无法完成发布, 原因竟然是 Caused by:</p>
<ul>
<li>the remote server responded with an error: unknown or invalid license expression; 
<ul>
<li>see http://opensource.org/licenses for options, </li>
<li>and http://spdx.org/licenses/ for their identifiers</li>
</ul>
</li>
</ul>
<p>对比其它 crate 修订 Cargo.toml 中的关键配置项目为:</p>
<blockquote>
<p>license = &quot;BSD-2-Clause&quot;</p>
</blockquote>
<p>是的, 就少了 github 自动创建时后面的一个 <code>License</code> 就通过了:</p>
<pre><code>$   cargo publish --registry crates-io
    Updating crates.io index
...
     Waiting on `ferris-actor` to propagate to crates.io index (ctrl-c to wait asynchronously)
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
    Updating crates.io index
</code></pre>
<p>完成发布;-)</p>
<h2 id="refer-13"><a class="header" href="#refer-13">refer.</a></h2>
<blockquote>
<p>各种相关参考...</p>
</blockquote>
<ul>
<li><a href="https://www.oreilly.com/library/view/command-line-rust/9781098109424/">Command-Line Rust [Book]</a>
<ul>
<li><a href="https://determinate.systems/posts/determinate-nix-installer">Introducing the Determinate Nix Installer — Determinate Systems</a> ~ 实战案例, 从 bash 迁移为 rust...</li>
</ul>
</li>
<li><a href="https://rustacean.net/">Rustacean.net: Home of Ferris the Crab</a></li>
<li>...</li>
</ul>
<h3 id="pg"><a class="header" href="#pg">+Pg</a></h3>
<p><a href="https://postgresconf.org/blog/posts/from-zero-to-postgresql-extension-in-3-hours-with-rust">From Zero to PostgreSQL extension in 3 hours with Rust - Postgres Conference</a></p>
<ul>
<li>+Tokio ~ <a href="https://shanmukhsista.com/real-world-rest-api-using-rust-axum-framework-with-request-validations-and-error-handling-75d4175cef96">How to Write a REST API Using Rust and Axum Framework | by Shanmukh Sista | Medium</a></li>
<li>
<ul>
<li>SQLx ~ <a href="https://codevoweb.com/rust-build-a-crud-api-with-sqlx-and-postgresql/">Rust - Build a CRUD API with SQLX and PostgreSQL 2023</a>
<ul>
<li><a href="https://zenn.dev/codemountains/articles/159a8a0323a56f">Axum と SQLx で Todo アプリを作る（DB は PostgreSQL）</a></li>
<li>...</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://genekuo.medium.com/creating-a-rest-api-in-rust-with-persistence-rust-rocket-and-diesel-a4117d400104">Creating a REST API in Rust with Persistence: Rust, Rocket and Diesel | by Gene Kuo | Medium</a></li>
<li>+actix ~ <a href="https://cloudmaker.dev/how-to-create-a-rest-api-in-rust/">Rust Web Development Tutorial: REST API | Cloudmaker</a></li>
<li></li>
</ul>
<h2 id="logging-11"><a class="header" href="#logging-11">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>...</li>
<li>230122 ZQ init.</li>
</ul>
<pre><code>       _~∽*^~_
   () /  ◴ =  \ \/
     '_   ⌄   _'
     ( '--#--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuicli"><a class="header" href="#tuicli">TUI:CLI</a></h1>
<h2 id="backgroung"><a class="header" href="#backgroung">backgroung</a></h2>
<p>作为一名程序猿, 终端几乎就是生存空间, 
在这这里值得折腾一切...</p>
<h2 id="goal-11"><a class="header" href="#goal-11">goal</a></h2>
<p>找到一种舒服的姿势:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
可以快速构造出各种 CLI 工具
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://qiita.com/Tadahiro_Yamamura/items/4ae32347fb4be07ea642#app%E3%81%A8parser%E3%81%AE%E3%81%A9%E3%81%A1%E3%82%89%E3%82%92%E4%BD%BF%E3%81%86%E3%81%B9%E3%81%8D%E3%81%8B">Rustで手軽にCLIツールを作れるclapを軽く紹介する - Qiita</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
可以快速构造出各种 TUI 软件 ~ 类似 POS 系统界面的...
<ul>
<li>参考作品: <a href="https://github.com/extrawurst/gitui/search?l=makefile">extrawurst/gitui: Blazing 💥 fast terminal-ui for git written in rust 🦀</a>
<ul>
<li><a href="https://github.com/ClementTsang/bottom">ClementTsang/bottom: Yet another cross-platform graphical process/system monitor.</a></li>
<li><a href="https://github.com/actuday6418/Diary">actuday6418/Diary: Encrypted memories</a></li>
<li><a href="https://github.com/TaKO8Ki/gobang">TaKO8Ki/gobang: A cross-platform TUI database management tool written in Rust</a></li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="tracing"><a class="header" href="#tracing">tracing</a></h2>
<blockquote>
<p>问题是这么来的...</p>
</blockquote>
<h2 id="refer-14"><a class="header" href="#refer-14">refer.</a></h2>
<p><a href="https://github.com/rothgar/awesome-tuis">rothgar/awesome-tuis: List of projects that provide terminal user interfaces</a></p>
<ul>
<li><a href="https://www.libhunt.com/l/rust/topic/tui">Top 23 Rust TUI Projects (Feb 2023)</a>
<ul>
<li><a href="https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/">Rust and TUI: Building a command-line interface in Rust - LogRocket Blog</a></li>
<li><a href="https://developers.facebook.com/blog/2022/">Superconsole, a Text-based User Interface (TUI) library written in Rust</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/xdxcpr/intuitive_a_crate_for_writing_tuis_declaratively/">Intuitive: A crate for writing TUIs declaratively : rust</a></li>
<li><a href="https://dev.to/protium/creating-a-text-based-ui-with-rust-420">Creating a Text-based UI with rust - DEV Community</a></li>
<li><a href="https://blog.ediri.io/how-to-build-a-trivy-plugin-in-rust">How to build a Trivy plugin in Rust 🦀</a></li>
<li>...</li>
</ul>
</li>
<li>7.4k★ <a href="https://github.com/DioxusLabs/dioxus/releases">DioxusLabs/dioxus: Friendly React-like GUI library for desktop, web, mobile, and more.</a>
<ul>
<li><a href="https://dioxus.mrxzx.info/">介绍 - Dioxus</a></li>
</ul>
</li>
<li><a href="https://github.com/gyscos/cursive">gyscos/cursive: A Text User Interface library for the Rust programming language</a></li>
<li><a href="https://github.com/redox-os/termion/watchers">redox-os/termion: Mirror of https://gitlab.redox-os.org/redox-os/termion</a> ~ 动画片专注...</li>
<li><a href="https://github.com/fdehau/tui-rs">fdehau/tui-rs: Build terminal user interfaces and dashboards using Rust</a></li>
<li>...</li>
</ul>
<pre><code>       _~^|∽~_
   \/ /  # O  \ (/
     '_   𝟂   _'
     &gt; '-----' |

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nn-纪元"><a class="header" href="#nn-纪元">NN 纪元</a></h1>
<blockquote>
<p>CLI 小作品</p>
</blockquote>
<h2 id="backgroung-1"><a class="header" href="#backgroung-1">backgroung</a></h2>
<p>作为一名程序猿总是要有一种特殊的时间点记录系统...</p>
<h2 id="goal-12"><a class="header" href="#goal-12">goal</a></h2>
<p>以女儿出生当天零时, 为类似 UNIX 时间戳的起点,
可以在各种系统中快速确定/反查:</p>
<ul>
<li>nn ~ 默认给出当天是女儿出生第几天</li>
<li>nn -e 4200 ~ 给出指定 NNera 是公历 YYYY-mm-dd</li>
<li>nn -d 230225 ~ 给出指定 yymmdd 日期是女儿出生第几天</li>
</ul>
<h2 id="trace-12"><a class="header" href="#trace-12">trace</a></h2>
<ul>
<li>最早是 每天日记时, 手工增量, 人工查询;</li>
<li>后来用 Python 写了个脚本, 但是, 环境部署是个麻烦事儿;</li>
<li>然后, 学习 Elixri 时写了个工具, 但是, 发现竟然没办法简单编译为 Linux 应用;</li>
<li>又后来, 学习 Golang 时写了个指令, 发现, 竟然超过 10M ...</li>
<li>最后用 bash 编了个 .sh 脚本反而兼容性最好</li>
<li>现在, 轮到 Rust 来重构了...</li>
</ul>
<h2 id="refer-15"><a class="header" href="#refer-15">refer.</a></h2>
<ul>
<li><a href="https://docs.rs/clap/latest/clap/index.html">clap - Rust</a>
<ul>
<li><a href="https://blog.ediri.io/lets-build-a-cli-in-rust">Let's build a CLI in Rust 🦀</a></li>
<li><a href="https://medium.com/javascript-in-plain-english/coding-wont-exist-in-5-years-this-is-why-6da748ba676c">Building a CLI from scratch with Clapv3 | by Ukpai Ugochi | Medium</a></li>
<li><a href="https://qiita.com/Tadahiro_Yamamura/items/4ae32347fb4be07ea642">Rustで手軽にCLIツールを作れるclapを軽く紹介する - Qiita</a></li>
<li><a href="https://zenn.dev/shinobuy/articles/53aed032fe5977">RustのClapクレートがメチャクチャ良かった話</a></li>
<li><a href="https://juejin.cn/post/7158808367233204261">如何用clap进行命令行解析 - 掘金</a></li>
</ul>
</li>
<li><a href="https://docs.rs/structopt/latest/structopt/trait.StructOpt.html">structopt - Rust</a>
<ul>
<li><a href="https://suibianxiedianer.github.io/rust-cli-book-zh_CN/crates/README_zh.html">解析命令行参数 - Rust 中的命令行应用</a></li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
<h2 id="logging-12"><a class="header" href="#logging-12">logging</a></h2>
<ul>
<li>...</li>
<li>230228 ZQ ...🦀</li>
<li>230225 ZQ re-re-re-init.</li>
</ul>
<pre><code>          _~^+`~_
      \/ /  + ^  \ (/
        '_   ∧   _'
        ( '-----' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ferris-actor"><a class="header" href="#ferris-actor">Ferris-Actor</a></h1>
<blockquote>
<p>Freeis ASCII-art actor and CLI animation/tools
叕在终端中起舞动的 Ferris, 这次可以随机生成一个 pose 以供 Markdown 使用</p>
</blockquote>
<p>首个 crate 发布:
<strong><a href="https://crates.io/crates/ferris-actor">ferris-actor - crates.io: Rust Package Registry</a></strong></p>
<h2 id="backgroung-2"><a class="header" href="#backgroung-2">backgroung</a></h2>
<p>作为一名程序猿, 终端几乎就是生存空间, 在这这里发生什么, 都不奇怪</p>
<h2 id="goal-13"><a class="header" href="#goal-13">goal</a></h2>
<p>完成最早在网页中看到的 ASCII-art 版本 STAR WAR MOIVE....</p>
<h3 id="installation"><a class="header" href="#installation">installation</a></h3>
<p>...TBD</p>
<h3 id="usage"><a class="header" href="#usage">usage</a></h3>
<p>...TBD</p>
<h2 id="tracing-1"><a class="header" href="#tracing-1">tracing</a></h2>
<blockquote>
<p>问题是这么来的...</p>
</blockquote>
<ul>
<li>如何打印多行?
<ul>
<li>println! 就行</li>
</ul>
</li>
<li>如何刷新多行?
<ul>
<li>print!(&quot;\x1B[{}A&quot;, frames.len()); // move the cursor up</li>
<li>问题是怎么计算每一帧的行数?
<ul>
<li>好吧, 制作终端 ASCII-art 动画原本就是有专用 crate 的</li>
<li>上: termion</li>
</ul>
</li>
</ul>
</li>
<li>如何使用多行打印模板?
<ul>
<li>format!() 中第一个参数就好</li>
<li>另外,用 indoc 可以简化定义形式</li>
</ul>
</li>
<li>如何多行打印模板从另外文件引用?
<ul>
<li>不行,必须是: 字符串字面量（string literal）,在编译时要是已知的</li>
<li>这已经不是简单的 format!() 函数了,完全是标准的模板引擎了</li>
<li>这种当然也是有专用 crate 的
<ul>
<li>上:handlebars</li>
</ul>
</li>
</ul>
</li>
<li>如何将 <code>Result&lt;std::string::String, RenderError&gt;</code> 兼容提取为 String?
<ul>
<li>map_err/unwrap_or_else/... 堆上, 总之, 不能放任何一个问题跑掉</li>
</ul>
</li>
<li>如何将 HTML 转义字符打印回原本的样子?
<ul>
<li>LOOK: <a href="https://handlebarsjs.com/guide/hooks.html">Introduction | Handlebars</a></li>
<li>原来, Handlebars 根本就是个模板语言, 人家有完备的功能语法</li>
<li>只是 <a href="https://crates.io/crates/handlebars/0.6.14">handlebars - crates.io: Rust Package Registry</a> 完成了全部支持</li>
<li>而且, 人家是将近10年的老工程了,一直在完善</li>
</ul>
</li>
<li>...</li>
</ul>
<blockquote>
<p>Cargo.toml 编译发行</p>
</blockquote>
<p>开始找到办法, 可以将 Carogo.toml 中的关键信息拿到程序代码中使用, 
比如说:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let version = env::var(&quot;CARGO_PKG_VERSION&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>可惜, 编译发行后, 使用二进制执行文件出错:</p>
<pre><code class="language-shell">cd ./target/release/ferris-actor snap
Snap a randomly Ferris ASCII-art pose as Markdown:

thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: NotPresent', src/act/snap.rs:99:49
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>毕竟没有对应环境变量了, 得使用编译前文本提取的办法来静态化;
参考: <a href="https://github.com/ogham/exa/commits/master/build.rs?author=ogham">exa/build.rs at master · ogham/exa</a></p>
<p>才发现, Rust 中使用一个静态配置, 这么复杂...</p>
<p>思路有一些:</p>
<ul>
<li>使用 build.rs 定制不同编译过程中自动生成的辅助文件:
<ul>
<li>参考: <a href="https://github.com/ogham/exa/blob/master/build.rs#enroll-beta">exa/build.rs at master · ogham/exa</a></li>
<li>比如, 区分不同的编译目标时, 在对应编译路径中动态插入一个 version.rs</li>
<li>包含从 Cargo.toml 中提取的版本信息, 并声明为静态常量:</li>
<li><code>write!(&amp;mut f, &quot;pub const VERSION: &amp;str = \&quot;{}\&quot;;\n&quot;, version).unwrap();</code></li>
<li>然后, 在想引用的文件中引用</li>
<li>... Hummm, 问题在这就象个编译宏, 每次生成的东西根本是不可见的</li>
</ul>
</li>
<li>使用 workspaces 将对应工具组的模块放到专用辅助库中...
<ul>
<li>然后, 发现这就涉及多多个 Crate 的编译, 改变了整个儿日常开发流程</li>
<li>... Hummm, 放弃</li>
</ul>
</li>
<li>使用 本地库, 在当前工程目录中再来一发 <code>cargo new utils --lib</code>
<ul>
<li>形成一个根目录中的 <code>utils</code> 文件夹/库</li>
<li>然后,在原有 Cargo.toml 中追加本地依赖, 类似:</li>
</ul>
</li>
</ul>
<pre><code class="language-toml">[dependencies.utils]
path = &quot;utils&quot;
version = &quot;0.1.0&quot;
</code></pre>
<blockquote>
<p>然后, 发现, <code>found to be present in multiple build targets:...</code> 和 workspaces 一样的毛病, Humm 放弃</p>
</blockquote>
<ul>
<li>使用普通的同级辅助模块 <code>src/act/version.rs</code> , 基于标准的 toml 模块解析 Cargo.toml 中的版本信息;
<ul>
<li>通过 <code>env::current_dir()</code> 获得当前系统绝对路径</li>
<li>使用 <code>std::path::PathBuf</code> 合理操作, 拼出 Cargo.toml 的绝对路径</li>
<li>就可以进行正常的配置文件解析和使用而已...</li>
<li>...是的, 通了.</li>
</ul>
</li>
</ul>
<p>可惜是假的:</p>
<pre><code class="language-shell">$ /opt/bin/ferris-actor snap
Snap a randomly Ferris ASCII-art pose as Markdown:

thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/act/version.rs:22:51
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>和以往一样...</p>
<ul>
<li>冷静了一下,捋一下思路:
<ul>
<li>目的: 可以从 Cargo.toml 中拿到版本信息, 然后可以自动生成当前编译的时间戳</li>
<li>然后: 其它功能代码中, 可以安全获得这个动态信息, 通过一种静态数据定量的形式</li>
<li>发现: built.rs 是种常用辅助工具, 就是介入 cargo 各种编译行为中, 事先完成对应定制</li>
<li>那么: 为了兼容开发调试和编译发行时两种状态对 <code>编译+版本</code> 信息的使用和管理</li>
<li>自然:
<ul>
<li>还是使用 version.rs</li>
<li>不过内容不是自动获得信息, 而是一个定量声明语句</li>
<li>可以在调试时先完成对应 use 和检验, 当然内容是徦的</li>
<li>在 built.rs 
<ul>
<li>中使用 cargo_metadata 支持, 动态从 Cargo.toml 中拿到版本信息</li>
<li>再基于 chrono 自由生成需要格式的时间戳</li>
<li>将 version.rs 中整个儿定量声明语句在整体拼好写回去</li>
</ul>
</li>
</ul>
</li>
<li>以上, 果然达成目标:
<ul>
<li>参考:<a href="https://github.com/zhrust/ferris-actor/blob/main/build.rs">ferris-actor/build.rs at main · zhrust/ferris-actor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<p>PS:
只是这样一来, 仓库中永远有一个内容在动态变化的文件,
导致 <code>cargo publish</code> 时总是失败, 要使用对应参数, 无视之...</p>
</blockquote>
</blockquote>
<pre><code class="language-shell">$  cargo publish --registry crates-io --allow-dirty --no-verify
</code></pre>
<h3 id="build---verbose"><a class="header" href="#build---verbose">build --verbose</a></h3>
<blockquote>
<p>cargo 真的是个全能工具箱</p>
</blockquote>
<p>经过挖掘, 才知道, 进行 build 时, 当然可以公开所有行为,
可以清晰的看到 rustc 到底在干什么, 每个步骤使用的参数...</p>
<blockquote>
<blockquote>
<p>要知道这些参数当年都是人工逐一输入的...</p>
</blockquote>
</blockquote>
<pre><code>$  cargo build --release --verbose
...

       Fresh indoc v2.0.0
     Running `/Users/zoomq/Exercism/proj/ferris-actor/target/release/build/libc-44b1e034f3f26ee4/build-script-build`
     Running `rustc --crate-name core_foundation_sys /Users/zoomq/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/core-foundation-sys-0.8.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off -C metadata=f09e1a3332d57a02 -C extra-filename=-f09e1a3332d57a02 --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --cap-lints allow -l framework=CoreFoundation`
   Compiling iana-time-zone v0.1.53
     Running `rustc --crate-name iana_time_zone --edition=2018 /Users/zoomq/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/iana-time-zone-0.1.53/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=&quot;fallback&quot;' -C metadata=2aca5692396caa43 -C extra-filename=-2aca5692396caa43 --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --extern core_foundation_sys=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libcore_foundation_sys-f09e1a3332d57a02.rmeta --cap-lints allow`
     Running `rustc --crate-name num_traits /Users/zoomq/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/num-traits-0.2.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off -C metadata=b04e009ff1e9804c -C extra-filename=-b04e009ff1e9804c --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --cap-lints allow --cfg has_i128 --cfg has_to_int_unchecked --cfg has_reverse_bits --cfg has_leading_trailing_ones --cfg has_int_assignop_ref --cfg has_div_euclid`
     Running `rustc --crate-name libc /Users/zoomq/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/libc-0.2.139/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=&quot;default&quot;' --cfg 'feature=&quot;std&quot;' -C metadata=992234b65e6ba903 -C extra-filename=-992234b65e6ba903 --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --cap-lints allow --cfg freebsd11 --cfg libc_priv_mod_use --cfg libc_union --cfg libc_const_size_of --cfg libc_align --cfg libc_int128 --cfg libc_core_cvoid --cfg libc_packedN --cfg libc_cfg_target_vendor --cfg libc_non_exhaustive --cfg libc_ptr_addr_of --cfg libc_underscore_const_names --cfg libc_const_extern_fn`
   Compiling time v0.1.45
     Running `rustc --crate-name time /Users/zoomq/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/time-0.1.45/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off -C metadata=7bfae04e9962e5d8 -C extra-filename=-7bfae04e9962e5d8 --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --extern libc=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/liblibc-992234b65e6ba903.rmeta --cap-lints allow`
     Running `rustc --crate-name num_integer /Users/zoomq/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/num-integer-0.1.45/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off -C metadata=184fc31131d60eab -C extra-filename=-184fc31131d60eab --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --extern num_traits=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libnum_traits-b04e009ff1e9804c.rmeta --cap-lints allow --cfg has_i128`
   Compiling chrono v0.4.23
     Running `rustc --crate-name chrono --edition=2018 /Users/zoomq/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/chrono-0.4.23/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature=&quot;clock&quot;' --cfg 'feature=&quot;default&quot;' --cfg 'feature=&quot;iana-time-zone&quot;' --cfg 'feature=&quot;js-sys&quot;' --cfg 'feature=&quot;oldtime&quot;' --cfg 'feature=&quot;std&quot;' --cfg 'feature=&quot;time&quot;' --cfg 'feature=&quot;wasm-bindgen&quot;' --cfg 'feature=&quot;wasmbind&quot;' --cfg 'feature=&quot;winapi&quot;' -C metadata=d3c20a3ba0fbfc72 -C extra-filename=-d3c20a3ba0fbfc72 --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --extern iana_time_zone=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libiana_time_zone-2aca5692396caa43.rmeta --extern num_integer=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libnum_integer-184fc31131d60eab.rmeta --extern num_traits=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libnum_traits-b04e009ff1e9804c.rmeta --extern time=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libtime-7bfae04e9962e5d8.rmeta --cap-lints allow`
   Compiling ferris-actor v0.2.4 (/Users/zoomq/Exercism/proj/ferris-actor)
     Running `rustc --crate-name build_script_build --edition=2021 build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off -C metadata=59b650788a6d6b7f -C extra-filename=-59b650788a6d6b7f --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/build/ferris-actor-59b650788a6d6b7f -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --extern cargo_metadata=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libcargo_metadata-86d30a0408a5a2b1.rlib --extern chrono=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libchrono-d3c20a3ba0fbfc72.rlib`
     Running `/Users/zoomq/Exercism/proj/ferris-actor/target/release/build/ferris-actor-59b650788a6d6b7f/build-script-build`
     Running `rustc --crate-name ferris_actor --edition=2021 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C metadata=a20b677d4d0c20d7 -C extra-filename=-a20b677d4d0c20d7 --out-dir /Users/zoomq/Exercism/proj/ferris-actor/target/release/deps -L dependency=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps --extern clap=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libclap-fd5df38d2b65208f.rlib --extern clia_tracing_config=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libclia_tracing_config-e0e4f4192befb03f.rlib --extern handlebars=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libhandlebars-54715fbcc7488164.rlib --extern indoc=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libindoc-1fa0458745c98152.dylib --extern log=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/liblog-c2586173bc1389d4.rlib --extern rand=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/librand-cf3e2775330e5826.rlib --extern serde_json=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libserde_json-ed5e928c653c8e39.rlib --extern termion=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libtermion-e1080b4cecde7e2b.rlib --extern toml=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libtoml-db505b4d1c897e14.rlib --extern tracing=/Users/zoomq/Exercism/proj/ferris-actor/target/release/deps/libtracing-42c6c9622152d235.rlib`
    Finished release [optimized] target(s) in 6.08s
</code></pre>
<h2 id="tod"><a class="header" href="#tod">TOD:</a></h2>
<blockquote>
<p>为毛 Rust 中想引用兄弟目录的模块就这么难呢?</p>
</blockquote>
<pre><code>foobar/
    +- Cargo.toml
    +- Cargo.lock
    +- README.md
    +- ...
    +- src/
        +- main.rs
        +- act.rs
        +- act/
        |   + ...
        |   + snap.rs
        +- misc.rs
        `- misc/
            + version.rs
</code></pre>
<p>以上结构是一个简单的 bin 工程目录,
只是, main.rs 要调用的各种函数, 分布到不同子目录中了,
问题在:</p>
<ul>
<li>src/act/snap.rs 中引用同级的其它模块, 都可以, 
<ul>
<li>嘦在 src/mod.rs 中有对应进行声明;</li>
</ul>
</li>
<li>可是 src/act/snap.rs 中想引用 <code>src/misc/version.rs</code> 中的模块/对象/函数/...
<ul>
<li>怎么折腾就是不行...?</li>
</ul>
</li>
</ul>
<p>--&gt; 参考:<a href="dev//tip/manag_growing_proj_with_crates_modules.html">Crate中合理划分目录</a></p>
<h3 id="refer-16"><a class="header" href="#refer-16">refer.</a></h3>
<ul>
<li><a href="https://rustacean.net/">Rustacean.net: Home of Ferris the Crab</a>
<ul>
<li><a href="https://jsfiddle.net/Diggsey/3pdgh52r/embedded/result/">Animated Ferris - JSFiddle</a></li>
<li><a href="https://crates.io/crates/ferris-says">ferris-says - crates.io: Rust Package Registry</a></li>
<li><a href="https://crates.io/crates/ferris-say">ferris-say - crates.io: Rust Package Registry</a>
<ul>
<li><a href="https://spaghettidev.tech/posts/creating-a-cli-with-rust/">spaghettidev 🦀 — I'm a Software engineering student and Typescript &amp; Rust developer.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://rust-cli-recommendations.sunshowers.io/index.html#locations">Introduction - Rain's Rust CLI recommendations</a>
<ul>
<li><a href="https://crates.io/crates/clap">clap - crates.io: Rust Package Registry</a>
<ul>
<li><a href="https://www.joshfinnie.com/blog/a-command-line-application-in-rust/">Building a Command-Line Application in Rust | www.joshfinnie.com</a></li>
<li><a href="https://medium.com/@MatthieuL49/data-processing-with-rust-and-apache-arrow-datafusion-a-cli-application-with-clap-73c9df229540">Data Engineering With Rust And Apache Arrow DataFusion 2/4 — A CLI Application with Clap | by Matt | Jul, 2022 | Medium | Medium</a></li>
<li><a href="https://qiita.com/Tadahiro_Yamamura/items/4ae32347fb4be07ea642#app%E3%81%A8parser%E3%81%AE%E3%81%A9%E3%81%A1%E3%82%89%E3%82%92%E4%BD%BF%E3%81%86%E3%81%B9%E3%81%8D%E3%81%8B">Rustで手軽にCLIツールを作れるclapを軽く紹介する - Qiita</a></li>
<li><a href="https://github.com/clap-rs/clap/discussions/categories/q-a">What is the way to display the author? · clap-rs/clap · Discussion #4316</a>
<ul>
<li><a href="https://epage.github.io/blog/2022/09/clap4/#polishing-help-output">clap 4.0, a Rust CLI argument parser</a></li>
</ul>
</li>
<li>..</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/reference/tokens.html#raw-string-literals">Tokens - The Rust Reference</a>
<ul>
<li>...</li>
</ul>
</li>
</ul>
<pre><code>          _~^~`~_
      \) /  ☉ ☉  \ (/
        '_   V   _'
        / '-----' |

...act by ferris-actor v0.2.2
</code></pre>
<h2 id="logging-13"><a class="header" href="#logging-13">logging</a></h2>
<ul>
<li>...</li>
<li>230301 ZQ ...🦀</li>
<li>230225 ZQ re-re-re-init.</li>
</ul>
<pre><code>           _~`|`~_
       \/ /  &gt; ◕  \ ()
         '_   𝟂   _'
         &gt; '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bxmr"><a class="header" href="#bxmr">BXMr</a></h1>
<blockquote>
<p>rIME-Squirrel 表形码维护工具</p>
</blockquote>
<h2 id="backgroung-3"><a class="header" href="#backgroung-3">backgroung</a></h2>
<p>作为一名程序猿, 总是要对输入法也要有全面控制</p>
<p>所以, 一直有折腾:<a href="https://github.com/ZoomQuiet/ZqBXM/tree/master/Rime-Squirrel">ZqBXM/Rime-Squirrel at master · ZoomQuiet/ZqBXM</a></p>
<h2 id="goal-14"><a class="header" href="#goal-14">goal</a></h2>
<p>全面使用 Rust 重构原有 Python 版本的维护指令集;</p>
<h2 id="trace-13"><a class="header" href="#trace-13">trace</a></h2>
<ul>
<li>最早是 手工维护</li>
<li>后来用 Python 写了个脚本, 但是还是要人工复制到对应目录中再重新编译码表</li>
<li>又后来, 使用 invoke 框架拓展并增强了 BXM 码表的维护内部编辑</li>
<li>现在, 轮到 Rust 来重构了...</li>
</ul>
<h3 id="feeling"><a class="header" href="#feeling">feeling</a></h3>
<blockquote>
<p>终于有感觉了...</p>
</blockquote>
<p>知道 Rust 有年头了, 但是, 和 golang 类似, 一直没有认真上手,
golang 也开发过几个实用小工具/系统, 感觉和用 Python 差不多,
还是得靠 print 以及线上人眼观察...</p>
<p>Rust 开始进入 Linux 内核了, 感觉不一样了, 足够敦实了,
而且, 以往好象所有折腾过的开发语言都是有 GC 的...</p>
<p>在完成 <a href="dev//dev/cli_ferris_art.html">Ferris艺术</a> 小工具后,
决定介入日常生活, 重制这个实用工具: <code>BXMr</code> ~ BXM 管理器;
以便替代原先 Python 版本的 -&gt; <a href="https://github.com/ZoomQuiet/ZqBXM/blob/master/Rime-Squirrel/tasks.py">tasks.py</a></p>
<p>代码的增长, 要求必须对项目目录结构进行良好的规划/控制/演变/...</p>
<p>进一步的, 在代码调试过程中, 发现, 有了 rust-analyzer 的加持,
以往的循环:</p>
<pre><code>    开发
    ^   \ 
    |    运行
    |     \
    |     观察 print()
    |    /
     调试
</code></pre>
<p>可以有质的提升, 现在可以完全信任编译器了,
现在的流程变成:</p>
<ul>
<li>思考问题</li>
<li>撰写代码, 实时根据 RA(rust-analyzer) 提示, 进行修订</li>
<li>那么嘦在 IDE 中没有警告时 
<ul>
<li>一般 cargo check 也不会有问题</li>
<li>以及 cargo check 也不会有问题</li>
<li>甚至 cargo build 也不会有问题</li>
<li>...也就意味着此时, 代码包含的所有应用/系统行为就已经是可信/可用/坚不可摧的了</li>
</ul>
</li>
<li>这种问题/目标/代码/理解/... all-in-one 的感觉太坚实了
<ul>
<li>对比以往其它语言, 即便是 IDE/编译器 都没问题</li>
<li>真正运行起来时, 照样有各种意外</li>
<li>...那种感觉就象 屎莱姆 ...软卟卟的,想怎么折腾就怎么折腾, 可就是永远固定不到一个理想的状态</li>
</ul>
</li>
<li>而 Rust 世界中,嘦编译器过了, 基本上就夯实了...</li>
<li>如果有问题, 基本上可以明确, 绝对不是代码问题
<ul>
<li>只可能是自己对问题的理解有偏差</li>
<li>以及代码表述的行为和我们的期待不同...</li>
</ul>
</li>
</ul>
<blockquote>
<p>工作量:</p>
</blockquote>
<pre><code>
༄  tokei
===============================================================================
 Language            Files        Lines         Code     Comments       Blanks
===============================================================================
 Markdown                2          218            0          152           66
 Rust                   13         1137          657          322          158
 TOML                    1           51           28           15            8
===============================================================================
 Total                  16         1406          685          489          232
===============================================================================
</code></pre>
<p>对比原有 Python 的版本:</p>
<pre><code>
༄  tokei tasks.py
===============================================================================
 Language            Files        Lines         Code     Comments       Blanks
===============================================================================
 Python                  1          248          157           22           69
===============================================================================
 Total                   1          248          157           22           69
===============================================================================
</code></pre>
<p>嗯哼? 没有主观感觉的10倍, 当然,过程中删除的不同版本,得有10倍了;</p>
<h3 id="verb"><a class="header" href="#verb">verb</a></h3>
<blockquote>
<p>纠结所在....</p>
</blockquote>
<p>原问题是这样的:</p>
<ul>
<li>输入法的码表, 只是就是一批 键码和文字 的 K/V 值对</li>
<li>在 rIME-Squirrel 中则是要求组织为一个约定的 .yaml 文件
<ul>
<li>数据结构为: &quot;{文字}\t{键码}&quot;</li>
<li>键码相同指向多个文字时, 就对应复制出新行来</li>
<li>行的前后顺序决定了输入时推荐的顺序</li>
<li>比如现有定义码表行片段:
<ul>
<li>敠    aaaa</li>
<li>叕    aaaa</li>
<li>敪    aaaa</li>
<li>娺    aaaa</li>
<li>啊啊啊啊    aaaa</li>
</ul>
</li>
<li>那么在使用 rIME 输入时自动弹出的推荐字列就应该是:</li>
</ul>
</li>
</ul>
<p><img src="https://ipic.zoomquiet.top/2023-03-05-zshot%202023-03-05%2021.16.04.jpg" alt="aaaa" /></p>
<p>难点在 <code>键/字</code> 条目行的次序是有要求的, 以后插入时要遵守:</p>
<ul>
<li>短键码在前</li>
<li>ASCII 字母顺序为先</li>
<li>长度从 1 到 4 个字符</li>
<li>不可能超过 4 个字符</li>
<li>例如:
<ul>
<li>a 在 b 之前</li>
<li>a 在 aa 之前</li>
<li>aa 在 ab 之前</li>
<li>az 在 aaa 之前</li>
<li>aaaa 在 b 之前</li>
<li>...</li>
</ul>
</li>
<li>如果对应键并没定制就不记录</li>
<li>例如:
<ul>
<li>原有定义条目记录:
<ul>
<li>btk 是不并</li>
<li>btmd 悬而未决</li>
</ul>
</li>
<li>那么, 想追加一个 <code>btl 是也乎</code> 就应该插入为:
<ul>
<li>btk 是不并</li>
<li>btl 是也乎</li>
<li>btmd 悬而未决</li>
</ul>
</li>
</ul>
</li>
<li>这里就问题就在一个原本有具体排序要求的键码序列
<ul>
<li>本身是残缺的</li>
<li>要判定某个新增键码应该在哪里插入,要顾虑的条件很多</li>
<li>以往都是人工观察插入的...还不得保证对, 那时 rIME 编译时就报错...</li>
</ul>
</li>
</ul>
<p>所以, Python 代码实现时, 用了一个反模式:</p>
<ul>
<li>先根据 BXM 的编码规则, 构造出一个严格按照键码排序的编码表</li>
<li>然后, 再根据现行使用的 BXM 定义 <code>键/字</code> 填写入这个编码表</li>
<li>那么, 进行维护时就变成一个简单的查表过程:
<ul>
<li>对原有 <code>键/字</code> 的条目, 追加同键不同字时, 追加字到对应的键后数组就好</li>
<li>对原先没有的条目, 到对应键后空白数组中追加就好</li>
<li>...</li>
<li>最后需要更新 .yaml 时,  从这个全码全序的编码表对其中有效的条目进行转换输出就好</li>
</ul>
</li>
<li>也就是说, 将原先 .yaml 中的 &quot;{文字}\t{键码}&quot; 定义记录条目文本
<ul>
<li>先变成 &quot;{&quot;键&quot;:[&quot;字0&quot;,&quot;字1&quot;,,]}&quot; 类字典/HashMap 记录</li>
<li>而且,其中的键是吻合 BXM 规则的全部顺序可能键码</li>
</ul>
</li>
</ul>
<p>对应原有 Python 代码:</p>
<pre><code class="language-python">BXMC = &quot;abcdefghijklmnopqrstuvwxyz&quot;

@task
def init2(c):
    print(f&quot;init from\n\t{ORIG};\nAIM-&gt;\t{AIMP}&quot;)
    print(f&quot;{AIMP} exists?\n\t&quot;,os.path.exists(f&quot;{AIMP}&quot;))
    _gbxm = {}

    def generate_strings(length, prefix=''):
        if length == 0:
            return
        for c in BXMC:
            key = prefix + c
            print(key)
            _gbxm[key] = []
            generate_strings(length-1, key)

    generate_strings(4)
    print(f&quot;gen. all BXM code as {len(_gbxm.keys())}&quot;)
    return None
</code></pre>
<p>对应 Rust 版本是:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//  定义在: src/inv/util.rs
pub const BXMC: &amp;str = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
pub const MBCL: usize = 4; // code len.

pub fn generate_strings(length: usize, 
            prefix: String, 
            gbxm: &amp;mut BTreeMap&lt;String, Vec&lt;String&gt;&gt;
        ) {
        if length == 0 {
            return;
        }
        for c in BXMC.chars() {
            let key = prefix.clone() + &amp;c.to_string();
            gbxm.insert(key.clone(), Vec::new());
            generate_strings(length - 1, key, gbxm);
        }
    }

pub fn init2(codelen:usize) -&gt; Option&lt;BTreeMap&lt;String, Vec&lt;String&gt;&gt;&gt; {
    let mut gbxm = BTreeMap::new();
    generate_strings(codelen, String::new(), &amp;mut gbxm);
    //println!(&quot;\n\t gen. all BXM code as {} &quot;, gbxm.len());

    Some(gbxm)
}

//  具体调用形式:
use crate::inv::util;
...
    let gbxm = util::init2(util::MBCL).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>基本上和 Python 代码 1:1 转换, 当然, 代码的可信度要高很多;</p>
<p>接下来才是问题:</p>
<ul>
<li>生成的全量键码有 475,254 个
<ul>
<li>用 toml 记录时, 有4Mb</li>
</ul>
</li>
<li>而对应 BXM 当前包含的所有键码仅 60,337 个
<ul>
<li>用 yaml 记录时, 只有 700Kb</li>
</ul>
</li>
<li>用 Python 加载/更新/回写/... IO 操作时,要3~4秒</li>
<li>而用 cargo run 进行试用时, 要10秒左右
<ul>
<li>好在 cargo build --release 之后的二进制执行文件运行时, 快到了 2~3 秒</li>
</ul>
</li>
<li>这样还是慢哪....
<ul>
<li>尝试用异步 crate 加速, 效果不明显</li>
<li>以字母表为基准切为26个文件? 太麻烦而且, 要在用户本地生成一组文件本身也是问题</li>
<li>上 SQLite 内存数据库? 相同的数据量想加载到内存中一样有耗时要等待</li>
<li>....</li>
</ul>
</li>
</ul>
<blockquote>
<p>还能怎么加速呢?</p>
</blockquote>
<ul>
<li>以现行有效 <code>键/字</code> 定义为准, 只管理不到7万行数据,比将近50万行肯定要快
<ul>
<li>但是, 这就得完成完备的插入次序判定算法</li>
<li>...当然也行, 只是没必要, 如果 BXMr 想兼容所有输入法的话, 就不能特化支持特定码表...</li>
</ul>
</li>
<li>回到问题源头:
<ul>
<li>数据文件大, 所以加载慢</li>
<li>而且没使用多核 CPU 来加速</li>
<li>...</li>
<li>也就是说, 值得折腾的是利用 Rust 的系统编程能力:
<ul>
<li>构造 <code>键/字</code> 全量码表的二进制文件形式, 大幅减少要加载的文件尺寸</li>
<li>动用异步/并发/并行/多线程/非阻塞/... 能力, 在数据加载以及处理上加速</li>
</ul>
</li>
<li>正好, 这也就能将以往看的资料中高级话题, 对应到具体问题需求上来了...</li>
</ul>
</li>
</ul>
<h3 id="env"><a class="header" href="#env">.env</a></h3>
<blockquote>
<p>如何可以缓存各种常用配置?</p>
</blockquote>
<p>和 Python 日常开发和部署使用不同, 以往:</p>
<ul>
<li>一般使用个 _settings.py 文件,作为一个全局变量桶, 收集各种在所有模块中都要用的关键配置和数据
<ul>
<li>反正一般 Python 小工具发行时, 并没有编译/打包的过程, 都是脚本和配置一起发布</li>
<li>嘦注意加载的目录关系, 就可以无视操作系统, 在 Python 运行时的帮助下加载到需要的配置</li>
</ul>
</li>
</ul>
<p>但是, 在尝试用相似的行为套在 Rust 工程中才囧rz...</p>
<ul>
<li>如果也是用 _stettings.rs 那么编译后, 位置就不知道了, 而且用户本地要现场配置的东西也不可能写回 _settings.rs 了</li>
<li>那么,使用一个外部的 .toml 配置文件呢? 进行 cargo build --release 后, 发行单一可执行二进制目标文件, 和对应内核系统配套的, 一般并没人拖一个 .toml 来到本地配置</li>
<li>尝试将客户的配置信息记录到环境变量中, 才发现, 想永远有效必须写对应 *rc 文件, 问题是现在 bash 如不是大一统, 还有其它流行 shell 版本, 对应的 *rc 文件格式和位置也是不可预见的...</li>
<li>要不, 嘦涉及到外部导入/导出的来源和发布目标文件, 要求每次指令用户自己通过附加参数给出来就好?
<ul>
<li>回想自己使用就过程, 每次无论什么指令, 都要跟上 1~2 个, 或是更多路径参数....败退...</li>
</ul>
</li>
<li>...突然想到还有个 <code>.env</code> 文件哪...算是应用系统的随身运行时环境变量,本身很简单可以视为简化版本的 .ini 文件</li>
<li>追查了一下果然有 <a href="https://crates.io/crates/dotenv/0.15.0">dotenv - crates.io: Rust Package Registry</a>
<ul>
<li>那么逻辑就简单了:</li>
<li>无论用哪个指令, 先检验固定的和执行文件同目录的 .env 文件</li>
<li>如果没有, 指引用户先用 <code>$ bxmr cfg ...</code> 指令来完成关键文件的指引</li>
<li>然后, 写入 .env 文件中, 并自动加载到环境变量里</li>
<li>这样, 嘦运行自己工具的发行版, 就可以从本身所在目录中加载到以往的关键配置, 用在具体指令响应过程中...</li>
</ul>
</li>
</ul>
<h3 id="async"><a class="header" href="#async">async</a></h3>
<blockquote>
<p>只是想加速一个文件的读取...</p>
</blockquote>
<p>-&gt; <a href="dev//tip/open_big_file_speed.html">文件加速打开</a></p>
<p>然后就发现,这事儿没那么简单, 整体上:</p>
<blockquote>
<p>需要明确的是，async函数在Rust中是一种特殊的函数类型，可以在其中使用await操作符等异步操作，而async函数的返回类型是一个实现了Future trait的类型，这个类型在编译时是不确定的，因为它表示一个异步计算的结果，需要等待执行完成才能得到具体的结果类型。因此，当你调用一个async函数时，你需要在一个async上下文中，例如在async函数中或者使用tokio等异步运行时库的Runtime来运行异步任务。</p>
</blockquote>
<p>所以, 原有的调用栈:</p>
<ul>
<li>src/main.rs -&gt; fn main() 
<ul>
<li>inv::run() -&gt; src/inv.rs 
<ul>
<li>seek::echo() -&gt; src/inv/seek.rs
<ul>
<li>util::toml2btmap() -&gt; src/inv/util.rs
<ul>
<li>file.read_to_string(&amp;mut contents).unwrap()
<ul>
<li>let mut file = File::open(tfile).unwrap()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>发现可以用 tokio 实现异步操作, 并加速文件读取?
<ul>
<li>于是-&gt; 
<ul>
<li>use tokio::fs::File as TokioFile;</li>
<li>use tokio::io::BufReader as TokioBufReader;</li>
</ul>
</li>
<li>然后-&gt; 
<ul>
<li>let file = TokioFile::open(path).await?;</li>
<li>let reader = TokioBufReader::new(file);</li>
</ul>
</li>
<li>但是, 发现不行, await? 不能编译, 因为所在函数不是 async 的, 于是连锁反应</li>
<li>pub async fn async_read_lines().await &lt;- 以便被调用
<ul>
<li>pub async fn async_toml2btmap() &lt;- 以便被调用
<ul>
<li>util::async_toml2btmap().await &lt;- src/inv/util.rs
<ul>
<li>async fn seek::echo().await &lt;- src/inv/seek.rs
<ul>
<li>async fn run() &lt;- src/inv.rs 
<ul>
<li>inv::run().await &lt;- src/main.rs
<ul>
<li>async fn main()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果不是 rust-analyzer 一路提醒, 真会蒙圈儿的...</p>
<h2 id="refer-17"><a class="header" href="#refer-17">refer.</a></h2>
<ul>
<li><a href="https://docs.rs/clap/latest/clap/_derive/_cookbook/git_derive/index.html">clap::_derive::_cookbook::git_derive - Rust</a>
<ul>
<li>简化官方示例,完成结构性探索</li>
</ul>
</li>
<li><a href="https://medium.com/javascript-in-plain-english/coding-wont-exist-in-5-years-this-is-why-6da748ba676c">Building a CLI from scratch with Clapv3 | by Ukpai Ugochi | Medium</a>
<ul>
<li>很囧的案例, 看起来很美却根本编译不过...</li>
</ul>
</li>
<li>尴尬了, 二进制发行版本的应用可没有那么简单的全局配置可以使用...
<ul>
<li><a href="https://www.thorsten-hans.com/working-with-environment-variables-in-rust/">Working with Environment Variables in Rust · Thorsten Hans' blog</a></li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
<h2 id="logging-14"><a class="header" href="#logging-14">logging</a></h2>
<ul>
<li>...</li>
<li>230301 ZQ ...🦀</li>
<li>230227 ZQ mod/clap/tracing/... 项目结构厘定</li>
<li>230225 ZQ re-re-re-init.</li>
</ul>
<pre><code>        _~^|∽~_
    \) /  ◴ ☉  \ \/
      '_   ⎵   _'
      / '--∽--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rss-for-mdbook"><a class="header" href="#rss-for-mdbook">RSS for Mdbook</a></h1>
<blockquote>
<p>是的一个应该是常用的工具...</p>
</blockquote>
<h2 id="backgroung-4"><a class="header" href="#backgroung-4">backgroung</a></h2>
<p>作为一名工程师, 使用哪种语言, 就想用这语言作一切...</p>
<p>mdbook 非常好, 吻合以往想用 Markdown 快速发布网站的所有期待:</p>
<ul>
<li>纯 .md, 不包含约定的各种奇怪的 meta head</li>
<li>根据自然目录生成</li>
<li>生成速度非常快</li>
<li>...</li>
</ul>
<h2 id="goal-15"><a class="header" href="#goal-15">goal</a></h2>
<p>虽然 RSS 有点儿过气了, 但是, 在工程师世界里还是一个标准的信息交换接口,</p>
<p>但是, <a href="https://crates.io/crates/mdbook-rss">mdbook-rss - crates.io: Rust Package Registry</a> </p>
<ul>
<li>很久没更新</li>
<li>而且也不生效</li>
<li>...</li>
</ul>
<p>那么就得自己上了...</p>
<h2 id="trace-14"><a class="header" href="#trace-14">trace</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
探索..决定方案</li>
<li><input disabled="" type="checkbox" checked=""/>
架构基本框架</li>
<li><input disabled="" type="checkbox" checked=""/>
实现核心功能</li>
<li><input disabled="" type="checkbox" checked=""/>
清查发表 crate
<ul>
<li><a href="https://crates.io/crates/rss4mdbook">rss4mdbook - crates.io: Rust Package Registry</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
试用
<ul>
<li>囧了,竟然不好支持多站点...</li>
<li>🌝 妥了 -&gt; <a href="https://github.com/zhrust/rss4mdbook/releases/tag/v0.2.42">Release RSS4mdBook v0.2.42 · zhrust/rss4mdbook</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
宣传?</li>
<li><input disabled="" type="checkbox"/>
...无尽的维护</li>
</ul>
<h2 id="refer-18"><a class="header" href="#refer-18">refer.</a></h2>
<ul>
<li><a href="https://docs.rs/clap/latest/clap/_derive/_cookbook/git_derive/index.html">clap::_derive::_cookbook::git_derive - Rust</a></li>
<li><a href="https://crates.io/crates/markdown/0.3.0">markdown - crates.io: Rust Package Registry</a></li>
<li><a href="https://crates.io/crates/mdbook/0.4.28">mdbook - crates.io: Rust Package Registry</a></li>
<li><a href="https://crates.io/crates/rss/1.10.0">rss - crates.io: Rust Package Registry</a></li>
<li>...</li>
</ul>
<h2 id="logging-15"><a class="header" href="#logging-15">logging</a></h2>
<ul>
<li>...🦀</li>
<li>230308 ZQ publish ~&gt;  <a href="https://crates.io/crates/rss4mdbook">rss4mdbook - crates.io: Rust Package Registry</a></li>
<li>230306 ZQ init.</li>
</ul>
<pre><code>        _~∽&amp;`~_
    \) /  ◕ =  \ (/
      '_   ⏝   _'
      / '--~--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yazu"><a class="header" href="#yazu">Yazu</a></h1>
<blockquote>
<p>Yet another zipper for URI
叕一个自制缩址工具/服务/Lambda/...</p>
</blockquote>
<h2 id="backgroung-5"><a class="header" href="#backgroung-5">backgroung</a></h2>
<p>作为一名程序猿, 撰写图书时总是要有缩址需求的...</p>
<p>但是, 以往所有的缩址服务都屎了...
当然得自行嗯哼出来...</p>
<h2 id="goal-16"><a class="header" href="#goal-16">goal</a></h2>
<p>全面使用 Rust 重构原有 Python 版本的工具</p>
<h2 id="trace-15"><a class="header" href="#trace-15">trace</a></h2>
<ul>
<li>最早是 手工维护</li>
<li>后来用 Python 写了个脚本, 自动转化为 Nginx 配置</li>
<li>现在, 轮到 Rust 来重构了...</li>
</ul>
<h2 id="refer-19"><a class="header" href="#refer-19">refer.</a></h2>
<ul>
<li><a href="https://docs.rs/clap/latest/clap/_derive/_cookbook/git_derive/index.html">clap::_derive::_cookbook::git_derive - Rust</a>
<ul>
<li>简化官方示例,完成结构性探索</li>
</ul>
</li>
<li>...</li>
</ul>
<h2 id="logging-16"><a class="header" href="#logging-16">logging</a></h2>
<ul>
<li>...</li>
<li>230301 ZQ ...🦀</li>
<li>230225 ZQ re-re-re-init.</li>
</ul>
<pre><code>         _~`~∽~_
     \/ /  O ◴  \ (/
       '_   v   _'
       \ '-----' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webrs"><a class="header" href="#webrs">Web.rs</a></h1>
<blockquote>
<p>必须异步化的....</p>
</blockquote>
<h2 id="background-14"><a class="header" href="#background-14">background</a></h2>
<p>作为一头程序猿, 互联网就是真实宇宙,
必须在其中是自在的...</p>
<h2 id="goal-17"><a class="header" href="#goal-17">goal</a></h2>
<p>上手用 Rust 生态中最锈的完成一个或是几个可用系统.</p>
<h2 id="trace-16"><a class="header" href="#trace-16">trace</a></h2>
<p>...TBD</p>
<h2 id="refer-20"><a class="header" href="#refer-20">refer.</a></h2>
<blockquote>
<p>关键参考
<a href="https://github.com/rust-unofficial/awesome-rust">rust-unofficial/awesome-rust: A curated list of Rust code and resources.</a></p>
</blockquote>
<ul>
<li><a href="https://www.arewewebyet.org/">Are we web yet? Yes, and it's freaking fast!</a></li>
<li>...</li>
</ul>
<pre><code>          _~`|`~_
      () /  - +  \ (/
        '_   ⩌   _'
        ( '-----' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokio"><a class="header" href="#tokio">tokio</a></h1>
<h2 id="background-15"><a class="header" href="#background-15">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<h2 id="goal-18"><a class="header" href="#goal-18">goal</a></h2>
<p>上手用 tokio 完成实用微服务的开发和检验...</p>
<h2 id="trace-17"><a class="header" href="#trace-17">trace</a></h2>
<p>TBD</p>
<h2 id="refer-21"><a class="header" href="#refer-21">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://tokio.rs/tokio/tutorial">Tutorial | Tokio - An asynchronous Rust runtime</a></p>
<ul>
<li><a href="https://tony612.github.io/tokio-internals/01_intro_async.html">介绍 - Tokio Internals</a></li>
<li><a href="https://rust-book.junmajinlong.com/ch100/01_understand_tokio_runtime.html">Rust异步编程和tokio框架 - Rust入门秘籍</a></li>
<li><a href="https://skyao.io/learning-tokio/docs.html">Tokio学习笔记 | Tokio学习笔记</a></li>
<li><a href="https://rustcc.cn/article?id=ba4f86c6-667d-4acb-89a1-e2fb0617f524">【原创】Rust tokio 如何以异步非阻塞方式运行大量任务 - Rust语言中文社区</a></li>
<li>...</li>
</ul>
<pre><code>            _~`+`~_
        () /  # ←  \ \/
          '_   ∧   _'
          ( '-----' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokio-1"><a class="header" href="#tokio-1">tokio</a></h1>
<h2 id="background-16"><a class="header" href="#background-16">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<h2 id="goal-19"><a class="header" href="#goal-19">goal</a></h2>
<p>上手用 tokio 完成实用微服务的开发和检验...</p>
<h2 id="trace-18"><a class="header" href="#trace-18">trace</a></h2>
<p>TBD</p>
<h3 id="prototype"><a class="header" href="#prototype">prototype</a></h3>
<blockquote>
<p>Q: </p>
</blockquote>
<p>在 rust 中如何构建一个简单的 graphQL 服务?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>可以使用以下步骤来构建一个简单的 GraphQL 服务：</p>
<ol>
<li>添加 juniper 和 hyper 依赖：</li>
</ol>
<p>────────────────────</p>
<pre><code>[dependencies]
juniper = &quot;0.15.2&quot;
juniper_hyper = &quot;0.16.1&quot;
hyper = &quot;0.14.3&quot;
</code></pre>
<p>────────────────────</p>
<ol start="2">
<li>定义一个 schema：</li>
</ol>
<p>────────────────────</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use juniper::{graphql_object, EmptyMutation, EmptySubscription, FieldResult, RootNode};

struct QueryRoot;

#[graphql_object]
impl QueryRoot {
    fn hello() -&gt; FieldResult&lt;String&gt; {
        Ok(&quot;Hello, world!&quot;.to_string())
    }
}

type Schema = RootNode&lt;'static, QueryRoot, EmptyMutation, EmptySubscription&gt;;

<span class="boring">}</span></code></pre></pre>
<p>在这个例子中，我们定义了一个 QueryRoot 类型，并添加了一个 hello 方法来返回一个字符串。</p>
<ol start="3">
<li>定义一个请求处理器：</li>
</ol>
<p>────────────────────</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hyper::{Body, Request, Response, Server};
use juniper_hyper::{graphiql_handler, graphql_handler};

async fn handle_request(req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;, hyper::Error&gt; {
    match (req.method(), req.uri().path()) {
        (&amp;hyper::Method::GET, &quot;/graphql&quot;) =&gt; graphiql_handler(&quot;/graphql&quot;)(req).await,
        (&amp;hyper::Method::POST, &quot;/graphql&quot;) =&gt; graphql_handler(&amp;Schema, &amp;QueryRoot, req).await,
        _ =&gt; Ok(Response::builder()
            .status(hyper::StatusCode::NOT_FOUND)
            .body(Body::empty())
            .unwrap()),
    }
}

<span class="boring">}</span></code></pre></pre>
<p>这个例子中使用了 hyper 库来处理请求。我们检查了请求的方法和路径，如果请求是 GET /graphql，我们会使用 graphiql_handler 函数返回 GraphQL IDE 页面；如果请求是 POST /graphql，我们 会使用 graphql_handler 函数来处理 GraphQL 查询。</p>
<ol start="4">
<li>启动服务器：</li>
</ol>
<p>────────────────────</p>
<pre><pre class="playground"><code class="language-rust edition2021">
#[tokio::main]
async fn main() {
    let addr = ([127, 0, 0, 1], 8080).into();
    let server = Server::bind(&amp;addr).serve(make_service_fn(|_conn| async {
        Ok::&lt;_, hyper::Error&gt;(service_fn(handle_request))
    }));

    println!(&quot;Listening on http://{}&quot;, addr);

    if let Err(e) = server.await {
        eprintln!(&quot;server error: {}&quot;, e);
    }
}
</code></pre></pre>
<p>在这个例子中，我们使用 hyper 库来创建一个服务器，并把请求处理器传给服务器。在 main 函数中启动服务器，监听在 127.0.0.1:8080 上。</p>
<ol start="5">
<li>使用 GraphQL 查询：</li>
</ol>
<p>现在你可以在 http://127.0.0.1:8080/graphql 上访问 GraphQL IDE 页面，输入以下查询：</p>
<p>────────────────────
query {
hello
}
────────────────────</p>
<p>然后点击 &quot;Play&quot; 按钮发送查询。服务器会返回以下结果：</p>
<p>────────────────────
{
&quot;data&quot;: {
&quot;hello&quot;: &quot;Hello, world!&quot;
}
}
────────────────────</p>
<p>这就是一个简单的 Rust GraphQL 服务的基本结构。你可以根据自己的需求添加更多的查询、变异和订阅。</p>
<h2 id="refer-22"><a class="header" href="#refer-22">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://tokio.rs/tokio/tutorial">Tutorial | Tokio - An asynchronous Rust runtime</a></p>
<ul>
<li><a href="https://tony612.github.io/tokio-internals/01_intro_async.html">介绍 - Tokio Internals</a></li>
<li>...</li>
</ul>
<pre><code>        _~^|^~_
    \) /  ♡ ←  \ ()
      '_   ▽   _'
      / '--∽--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-单元测试得知道的一切"><a class="header" href="#rust-单元测试得知道的一切">Rust 单元测试得知道的一切</a></h1>
<p>来自: <a href="https://www.youtube.com/watch?v=_jDKeOtOiEo&amp;t=4488s">Everything You Wanted to Know About Rust Unit Testing (and then some more) - YouTube</a></p>
<h2 id="logging-17"><a class="header" href="#logging-17">logging</a></h2>
<p>Learn how to write unit tests in Rust with this hands-on video that covers these five topics with examples and real code:</p>
<ul>
<li>The basic types of unit tests</li>
<li>The quality of the testing code</li>
<li>Testing the not-so-happy-path</li>
<li>Testing asynchronous code</li>
<li>Testing tools</li>
</ul>
<p>⏱️ Timestamps ⏱️</p>
<h3 id="000000---intro"><a class="header" href="#000000---intro">00:00:00 - Intro</a></h3>
<h3 id="000125---basic-concepts"><a class="header" href="#000125---basic-concepts">00:01:25 - Basic concepts</a></h3>
<h3 id="000443---project-creation"><a class="header" href="#000443---project-creation">00:04:43 - Project creation</a></h3>
<h3 id="000838---tests-module"><a class="header" href="#000838---tests-module">00:08:38 - Tests module</a></h3>
<h3 id="001024---rust-snippets-for-tests"><a class="header" href="#001024---rust-snippets-for-tests">00:10:24 - Rust snippets for tests</a></h3>
<h3 id="001421---first-unit-test-return-value"><a class="header" href="#001421---first-unit-test-return-value">00:14:21 - First unit test return value</a></h3>
<h3 id="002403---second-unit-test-state"><a class="header" href="#002403---second-unit-test-state">00:24:03 - Second unit test state</a></h3>
<h3 id="002846---alternative-implementation-tested"><a class="header" href="#002846---alternative-implementation-tested">00:28:46 - Alternative implementation tested</a></h3>
<h3 id="003244---third-unit-test-interaction"><a class="header" href="#003244---third-unit-test-interaction">00:32:44 - Third unit test interaction</a></h3>
<h3 id="004650---recommended-implementation"><a class="header" href="#004650---recommended-implementation">00:46:50 - Recommended implementation</a></h3>
<h3 id="004909---test-code-quality"><a class="header" href="#004909---test-code-quality">00:49:09 - Test code quality</a></h3>
<h3 id="004934---use-constants-for-literals"><a class="header" href="#004934---use-constants-for-literals">00:49:34 - Use constants for literals</a></h3>
<h3 id="005418---reduce-repetition-with-setup-and-teardown"><a class="header" href="#005418---reduce-repetition-with-setup-and-teardown">00:54:18 - Reduce repetition with setup and teardown</a></h3>
<h3 id="010857---share-code-among-test-modules"><a class="header" href="#010857---share-code-among-test-modules">01:08:57 - Share code among test modules</a></h3>
<h3 id="011305---why-testing-the-not-so-happy-path"><a class="header" href="#011305---why-testing-the-not-so-happy-path">01:13:05 - Why testing the not so happy path</a></h3>
<h3 id="011332---test-panics"><a class="header" href="#011332---test-panics">01:13:32 - Test panics</a></h3>
<h3 id="011803---use-ignore-and-test-results"><a class="header" href="#011803---use-ignore-and-test-results">01:18:03 - Use ignore and test results</a></h3>
<h3 id="012802---bubble-up-errors-in-tests"><a class="header" href="#012802---bubble-up-errors-in-tests">01:28:02 - Bubble up errors in tests</a></h3>
<h3 id="013034---asynchronous-code-in-rust"><a class="header" href="#013034---asynchronous-code-in-rust">01:30:34 - Asynchronous code in Rust</a></h3>
<h3 id="013101---async-tests"><a class="header" href="#013101---async-tests">01:31:01 - Async tests</a></h3>
<h3 id="013819---beyond-cargo-test"><a class="header" href="#013819---beyond-cargo-test">01:38:19 - Beyond cargo test</a></h3>
<h3 id="013846---rustdoc-and-doc-tests"><a class="header" href="#013846---rustdoc-and-doc-tests">01:38:46 - rustdoc and doc-tests</a></h3>
<h3 id="014800---show-test-output"><a class="header" href="#014800---show-test-output">01:48:00 - Show test output</a></h3>
<h3 id="014933---selecting-tests"><a class="header" href="#014933---selecting-tests">01:49:33 - Selecting tests</a></h3>
<h3 id="015555---test-coverage"><a class="header" href="#015555---test-coverage">01:55:55 - Test coverage</a></h3>
<h3 id="020108---nextest"><a class="header" href="#020108---nextest">02:01:08 - Nextest</a></h3>
<h3 id="020554---outro"><a class="header" href="#020554---outro">02:05:54 - Outro</a></h3>
<h2 id="refer-23"><a class="header" href="#refer-23">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://github.com/mongodb-developer/unit-testing-rust">mongodb-developer/unit-testing-rust: This repository contains the code used in MongoDB's video &quot;Intro to Unit Testing in Rust.&quot;</a></p>
<ul>
<li>联系原著/Jorge:
<ul>
<li>Twitter: https://twitter.com/jdortiz</li>
<li>Mastodon: https://fosstodon.org/@jdortiz</li>
<li>LinkedIn: https://www.linkedin.com/in/jorgeortiz/</li>
</ul>
</li>
<li>以及: 
<ul>
<li><a href="https://www.freecodecamp.org/news/unit-testing-in-rust/">What is Unit Testing? How to Perform Unit Tests in Rust</a></li>
</ul>
</li>
</ul>
<pre><code>            _~`&amp;∽~_
        () /  o →  \ \/
          '_   △   _'
          &gt; '--#--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codelldb"><a class="header" href="#codelldb">CodeLLDB</a></h1>
<blockquote>
<p>VSCode 中的调试重武...</p>
</blockquote>
<h2 id="backgroung-6"><a class="header" href="#backgroung-6">backgroung</a></h2>
<p>作为一名工程师, 总是想对运行时应用进行无限层次的探察哪...</p>
<h2 id="goal-20"><a class="header" href="#goal-20">goal</a></h2>
<p>CodeLLDB 或是 GDB/LLDB CLI 指令, 基本使用...</p>
<p>足以辅助探查,理解关键语法的真实行为.</p>
<h2 id="trace-19"><a class="header" href="#trace-19">trace</a></h2>
<ul>
<li>最早是 手工维护</li>
<li>后来用 Python 写了个脚本, 自动转化为 Nginx 配置</li>
<li>现在, 轮到 Rust 来重构了...</li>
</ul>
<h2 id="refer-24"><a class="header" href="#refer-24">refer.</a></h2>
<p><a href="https://llvm.org/">The LLVM Compiler Infrastructure Project</a></p>
<ul>
<li><a href="https://lldb.llvm.org/">LLDB Homepage — The LLDB Debugger</a>
<ul>
<li><a href="https://lldb.llvm.org/use/tutorial.html#id1">Tutorial — The LLDB Debugger</a></li>
<li><a href="https://lldb.llvm.org/use/map.html#id1">GDB to LLDB command map — The LLDB Debugger</a></li>
<li><a href="https://lldb.llvm.org/use/symbols.html">Symbols on macOS — The LLDB Debugger</a></li>
<li>...</li>
</ul>
</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB - Visual Studio Marketplace</a>
<ul>
<li><a href="https://lldb.llvm.org/use/tutorial.html">Tutorial — The LLDB Debugger</a></li>
<li><a href="https://code.visualstudio.com/docs/editor/debugging">Debugging in Visual Studio Code</a></li>
<li><a href="https://github.com/vadimcn/vscode-lldb/wiki/Troubleshooting">Troubleshooting · vadimcn/vscode-lldb Wiki</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">vadimcn/vscode-lldb · Discussions · GitHub</a></li>
<li>...</li>
</ul>
</li>
<li><a href="https://dev.to/rogertorres/debugging-rust-with-vs-code-11dj">Debugging Rust with VS Code - DEV Community</a></li>
<li><a href="https://blog.logrocket.com/how-debug-rust-vs-code/">How to debug Rust with VS Code - LogRocket Blog</a></li>
<li><a href="https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/">How to Debug Rust with Visual Studio Code</a></li>
<li><a href="https://chopschips.net/blog/2020/03/03/rust-lldb-workaround/">VSCodeでRustのテストコードをデバッグできない問題 | 割り箸ポテチ</a></li>
<li>...</li>
</ul>
<h2 id="logging-18"><a class="header" href="#logging-18">logging</a></h2>
<ul>
<li>...</li>
<li>...🦀</li>
<li>230307 ZQ init.</li>
</ul>
<pre><code>       _~∽*^~_
   () /  o ◶  \ (/
     '_   ⌄   _'
     ( '--#--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gui"><a class="header" href="#gui">GUI</a></h1>
<blockquote>
<p>图形用户界面..现在应该都可以 web/WASM 化了</p>
</blockquote>
<h2 id="backgroung-7"><a class="header" href="#backgroung-7">backgroung</a></h2>
<p>作为一名程序猿, 终端几乎就是生存空间, 
可惜用户总是看看 blingbling 的桌面哪...</p>
<h2 id="goal-21"><a class="header" href="#goal-21">goal</a></h2>
<p>找到一种舒服的姿势:</p>
<ul>
<li><input disabled="" type="checkbox"/>
可以快速构造出各种桌面工具</li>
<li><input disabled="" type="checkbox"/>
可以快速构造跨平台桌面工具</li>
<li><input disabled="" type="checkbox"/>
可以快速构造出能上各种应用市场的桌面工具
<ul>
<li><input disabled="" type="checkbox"/>
macOS app store 为先?</li>
</ul>
</li>
</ul>
<h2 id="tracing-2"><a class="header" href="#tracing-2">tracing</a></h2>
<blockquote>
<p>问题是这么来的...</p>
</blockquote>
<h2 id="refer-25"><a class="header" href="#refer-25">refer.</a></h2>
<p><a href="https://github.com/rust-unofficial/awesome-rust">rust-unofficial/awesome-rust: A curated list of Rust code and resources.</a></p>
<ul>
<li><a href="https://blog.logrocket.com/state-of-rust-gui-libraries/">The state of Rust GUI libraries - LogRocket Blog</a></li>
<li><a href="https://www.areweguiyet.com/">Are we GUI yet?</a>
<ul>
<li><a href="https://www.arewewebyet.org/">Are we web yet? Yes, and it's freaking fast!</a></li>
<li><a href="https://www.arewelearningyet.com/">Are we learning yet?</a></li>
<li><a href="https://arewegameyet.rs/">Are we game yet?</a></li>
</ul>
</li>
<li><a href="https://lib.rs/crates/winit">GUI — list of Rust libraries/crates // Lib.rs</a></li>
<li><a href="https://www.libhunt.com/l/rust/topic/gui">Top 23 Rust GUI Projects (Mar 2023)</a>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/sj54h0/what_are_the_best_gui_libraries_for_a_potentially/">What are the best GUI libraries for a potentially “serious”/large project? : rust</a></li>
<li>...</li>
</ul>
</li>
<li>直觉上值得尝试的:
<ul>
<li>26.6k★ <a href="https://github.com/yewstack/yew/releases">yewstack/yew: Rust / Wasm framework for building client web apps</a></li>
<li>18.3k★ <a href="https://github.com/iced-rs/iced/watchers">iced-rs/iced: A cross-platform GUI library for Rust, inspired by Elm</a></li>
<li>13.8k★ <a href="https://github.com/emilk/egui">emilk/egui: egui: an easy-to-use immediate mode GUI in Rust that runs on both web and native</a></li>
<li>7.4k★ <a href="https://github.com/DioxusLabs/dioxus/releases">DioxusLabs/dioxus: Friendly React-like GUI library for desktop, web, mobile, and more.</a> ~ 嗯哼? 包含 TUI 的支持...</li>
<li>1.1k★ <a href="https://github.com/fltk-rs/fltk-rs">fltk-rs/fltk-rs: Rust bindings for the FLTK GUI library.</a>
<ul>
<li><a href="https://fltk.flatig.vip/Home.html">开始 - fltk book</a></li>
</ul>
</li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
<pre><code>            _~^~`~_
        \) /  ? -  \ (/
          '_   ⎵   _'
          \ '-----' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入式开发"><a class="header" href="#嵌入式开发">嵌入式开发</a></h1>
<h2 id="background-17"><a class="header" href="#background-17">background</a></h2>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust">rust-embedded/awesome-embedded-rust: Curated list of resources for Embedded and Low-level development in the Rust programming language</a></p>
<h2 id="goal-22"><a class="header" href="#goal-22">goal</a></h2>
<p>和 microPython 对比一下开发体验...</p>
<h2 id="trace-20"><a class="header" href="#trace-20">trace</a></h2>
<p>TBD</p>
<h2 id="refer-26"><a class="header" href="#refer-26">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li>...</li>
</ul>
<pre><code>            _~-*`~_
        \) /  = *  \ \/
          '_   ⎵   _'
          / '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-pico"><a class="header" href="#raspberry-pi-pico">Raspberry Pi Pico</a></h1>
<blockquote>
<p>最便宜的开发板了...</p>
</blockquote>
<h2 id="background-18"><a class="header" href="#background-18">background</a></h2>
<p>Why not?</p>
<h2 id="goal-23"><a class="header" href="#goal-23">goal</a></h2>
<p>和 microPython 对比一下开发体验...</p>
<h2 id="trace-21"><a class="header" href="#trace-21">trace</a></h2>
<p>TBD</p>
<h2 id="refer-27"><a class="header" href="#refer-27">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://www.youtube.com/watch?v=JhajoAyP8e4&amp;list=PLc7W4b0WHTAV6EYRVayb9c9dEsq-NeXAt&amp;pp=iAQB">Raspberry Pi Pico - YouTube</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=Yi0WRF5WPFw&amp;list=PLc7W4b0WHTAV6EYRVayb9c9dEsq-NeXAt&amp;index=10">Rust Runs on Everything, Including the Raspberry Pi Pico | Adventures in Embedded Rust Programming - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=zSWkrpu8KBA">Don't Worry, C and Rust Can FINALLY Coexist (Here's How) | Embedded Rust and C on the RP2040 Pi Pico - YouTube</a>
<ul>
<li><a href="https://github.com/lowlevellearning/rp2040-blink/commit/0448080d39785592e857d699269c9cc8f13f669f">lowlevellearning/rp2040-blink</a></li>
</ul>
</li>
</ul>
</li>
<li>起点:<a href="https://github.com/rust-embedded/cortex-m-quickstart">rust-embedded/cortex-m-quickstart: Template to develop bare metal applications for Cortex-M microcontrollers</a></li>
<li>基础:<a href="https://github.com/rp-rs/rp-hal">rp-rs/rp-hal: A Rust Embedded-HAL for the rp series microcontrollers</a>
<ul>
<li><a href="https://github.com/rp-rs/rp2040-project-template/releases">rp-rs/rp2040-project-template: A basic rp2040-hal project with blinky and rtt logging example code. With this you can quickly get started on a new rp2040 project</a></li>
</ul>
</li>
<li><a href="https://picockpit.com/raspberry-pi/zh/2020/11/">关于Raspberry Pi Pico的一切 - PiCockpit | 监控和控制你的Raspberry Pi：最多可以免费使用5个Pis!</a></li>
<li>demo:
<ul>
<li><a href="https://tutoduino.fr/en/tutorials/programing-in-rust-the-xiao-rp2040-board/">Programing in Rust the XIAO RP2040 board</a></li>
<li><a href="https://dev.to/jeikabu/early-raspberry-pi-pico-and-rust-4c2a">Early Raspberry Pi Pico and Rust - DEV Community</a></li>
<li><a href="https://qiita.com/Toshiaki0315/items/e6b4ba01623eaa5273a8#%E5%8F%82%E8%80%83%E3%82%B5%E3%82%A4%E3%83%88">RaspberryPi PICO用のRust環境構築 - Qiita</a></li>
<li><a href="https://picockpit.com/raspberry-pi/zh/2020/11/">关于Raspberry Pi Pico的一切 - PiCockpit | 监控和控制你的Raspberry Pi：最多可以免费使用5个Pis!</a></li>
<li></li>
</ul>
</li>
<li>...</li>
</ul>
<pre><code>        _~`|`~_
    \/ /  = ◶  \ ()
      '_   𝟂   _'
      \ '--⌄--' |

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h1>
<blockquote>
<p>主要是懒...</p>
</blockquote>
<h2 id="background-19"><a class="header" href="#background-19">background</a></h2>
<p>日常环境:</p>
<pre><code>  neofetch
                    'c.          zoomq@ZQ160626rMBP
                 ,xNMM.          ------------------
               .OMMMMo           OS: macOS Big Sur 10.16 22D68 arm64
               OMMM0,            Host: MacBookPro18,4
     .;loddo:' loolloddol;.      Kernel: 22.3.0
   cKMMMMMMMMMMNWMMMMMMMMMM0:    Uptime: 5 days, 5 hours, 39 mins
 .KMMMMMMMMMMMMMMMMMMMMMMMWd.    Packages: 330 (brew)
 XMMMMMMMMMMMMMMMMMMMMMMMX.      Shell: bash 5.1.16
;MMMMMMMMMMMMMMMMMMMMMMMM:       Resolution: 2048x1280, 3200x1800
:MMMMMMMMMMMMMMMMMMMMMMMM:       DE: Aqua
.MMMMMMMMMMMMMMMMMMMMMMMMX.      WM: Spectacle
 kMMMMMMMMMMMMMMMMMMMMMMMMWd.    Terminal: iTerm2
 .XMMMMMMMMMMMMMMMMMMMMMMMMMMk   Terminal Font: FiraCode-Regular 18 (normal) / SarasaMonoSCNerd-regular 18 (non-ascii)
  .XMMMMMMMMMMMMMMMMMMMMMMMMK.   CPU: Apple M1 Max
    kMMMMMMMMMMMMMMMMMMMMMMd     GPU: Apple M1 Max
     ;KMMMMMMMWXXWMMMMMMMk.      Memory: 11065MiB / 65536MiB
       .cooc,.    .,coo:.
</code></pre>
<p>虽然有 linux 的 home server, 不过, 
一个小工具,能在本地编译出来发布二进制执行文件多好?</p>
<h2 id="goal-24"><a class="header" href="#goal-24">goal</a></h2>
<p>从本地同时可以 cargo build 出来两个主要场景的成品:</p>
<ul>
<li>macOS arm64 </li>
<li>Ubuntu 18.04.6 LTS (GNU/Linux 4.15.0-175-generic x86_64) 类似 LTS 目标环境</li>
</ul>
<h2 id="trace-22"><a class="header" href="#trace-22">trace</a></h2>
<p>没办法简单的成功, 还是用真机或是对应专用编译 Docker 来完成吧...</p>
<h3 id="abrew"><a class="header" href="#abrew">abrew</a></h3>
<blockquote>
<p>arm 版本 brew</p>
</blockquote>
<pre><code>$ abrew install FiloSottile/musl-cross/musl-cross
</code></pre>
<p>引发一系列手工安装:</p>
<ul>
<li>abrew install --build-from-source gnu-sed</li>
<li>abrew install --build-from-source lzip</li>
<li>abrew install --build-from-source make</li>
<li>...</li>
</ul>
<p><img src="https://ipic.zoomquiet.top/2023-02-26-zshot%202023-02-26%2015.22.58.jpg" alt="" /></p>
<pre><code>...
==&gt; /opt/homebrew/opt/make/bin/gmake install TARGET=x86_64-linux-musl
🍺  /opt/homebrew/Cellar/musl-cross/0.9.9_1: 1,851 files, 215.8MB, built in 5 minutes 35 seconds
==&gt; Running `brew cleanup musl-cross`...
Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.
Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).
</code></pre>
<p>对应 Cargo.toml 中追加:</p>
<pre><code>...
[target.x86_64-unknown-linux-musl]
linker = &quot;/opt/homebrew/Cellar/musl-cross/0.9.9_1/bin/x86_64-linux-musl-gcc&quot;

</code></pre>
<p>尝试编译:</p>
<pre><code>$ cargo build --target x86_64-unknown-linux-musl
</code></pre>
<p>然后:</p>
<pre><code>...
Some errors have detailed explanations: E0405, E0408, E0412, E0416, E0425, E0433, E0463, E0531.
error: could not compile `regex-syntax` due to 990 previous errors
</code></pre>
<p>折腾出 900+ 错误...败退...</p>
<h3 id="github-action"><a class="header" href="#github-action">GitHub-action</a></h3>
<blockquote>
<p>能免费用起来的, 先用起来...</p>
</blockquote>
<p>..TBD</p>
<h2 id="refer-28"><a class="header" href="#refer-28">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://kerkour.com/rust-cross-compilation">Cross-compilation in Rust</a></p>
<ul>
<li>M1 macOS host:
<ul>
<li><a href="https://stackoverflow.com/questions/68139162/how-can-i-cross-compile-rust-code-into-intel-assembly-on-an-arm-m1-apple-silicon">macos - How can I cross compile Rust code into Intel assembly on an ARM M1 Apple Silicon Mac? - Stack Overflow</a></li>
<li><a href="https://www.reddit.com/topics/a-1/">M1 Users - How are you Cross Compiling? : rust</a></li>
<li><a href="https://levelup.gitconnected.com/bash-vs-python-for-modern-shell-scripting-c1d3d79c3622?source=read_next_recirc---two_column_layout_sidebar------3---------------------95f4769b_05fc_410f_a439_5b8e347b5325-------">Cross-compiling Rust From Mac to Linux | by Merlin Fuchs | Better Programming</a></li>
<li><a href="https://manuel.bernhardt.io/posts/2022-11-04-rust-development-for-the-raspberry-pi-on-apple-silicon/">Rust Development for the Raspberry Pi on Apple Silicon - Manuel Bernhardt</a></li>
<li>...</li>
</ul>
</li>
<li>arm Linux host:
<ul>
<li><a href="https://burgers.io/cross-compile-rust-from-arm-to-x86-64">Cross-compiling Rust from ARM to x86-64 | Bryan Burgers</a></li>
<li>...</li>
</ul>
</li>
<li><a href="https://www.docker.com/blog/cross-compiling-rust-code-for-multiple-architectures/">Cross Compiling Rust Code for Multiple Architectures | Docker</a></li>
</ul>
<h2 id="logging-19"><a class="header" href="#logging-19">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230226 ZQ init.</li>
</ul>
<pre><code>          _~∽|-~_
      \) /  ◷ O  \ \/
        '_   ⎕   _'
        \ '--.--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20年来作为软件工程师学到的20件事"><a class="header" href="#20年来作为软件工程师学到的20件事">20年来作为软件工程师学到的20件事</a></h1>
<p>原文: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/">20 Things I've Learned in my 20 Years as a Software Engineer - Simple Thread</a></p>
<h2 id="注意请先阅读此内容"><a class="header" href="#注意请先阅读此内容">注意:请先阅读此内容</a></h2>
<p>即将展现的是一篇包含大量建议的 blog ;
向前人学习对成功至关重要,但是,我们常常忘记另外一个重要警告:
几乎所有的建议都是上下文相关的, 但是,很少对上下文提供细节;</p>
<p>&quot;你需要收取更多费用!&quot; 这经营了20年的公司说, 多年以来收费&quot;太低&quot;,无法赢得客户并取得成功;</p>
<p>&quot;你需要将一切构建为微服务!&quot; 该公司表示, 构建了一个快速的整体,获得了数千客户,然后,在开始遇到问题时, 全面转向了微服务;</p>
<p>如果不了解上下文, 建议就毫无意义,甚至更糟糕,有害;
如果那些人早点听从他们自己的建议,他们自己可能会因此受苦;
对于任何建议很难逃脱这个陷阱;
我们可能是我们经历的终点,但是,我们却是通过现在的镜头来观察;</p>
<p>因此,为了让你了解一下这些建议的来源,特此说明:
我在职业生涯的前半段担当软件工程师,为各种小型企业和初创公司工作,
然后,我进入咨询行业并在许多非常太的企业工作;
最后, 我开创了 <code>Simple Thread</code>,
我们从一个2人团队成长为一个25人的团队;
10年前, 我们主要和中小型企业合作,现在我们和大型和小型企业合作;</p>
<p>我的所有建议来自于:</p>
<ul>
<li>几乎总是在小而精干的团队中,我们必须用很少的资源作很多事情</li>
<li>重视工作软件而不是特定工具</li>
<li>一直在开始新项目,同时还要维护一些系统</li>
<li>重视工程师的生产力,超过其它大多数考虑因素</li>
<li>...</li>
</ul>
<p>我过去20年的经历塑造了对软件的偏见,
并使我形成了一些信念;
我试图将这些信念压缩为一个易于使用的列表,
希望你能发现她们的价值;</p>
<h2 id="建议清单"><a class="header" href="#建议清单">建议清单:</a></h2>
<h3 id="1-我仍然懂的不是太多"><a class="header" href="#1-我仍然懂的不是太多">1. 我仍然懂的不是太多</a></h3>
<p>&quot;你怎么不知道 BGP ?&quot;</p>
<p>&quot;你从来没听说过 Rust?&quot;</p>
<p>我们大多数人都被人这么说过,
而且可能听的太频繁了;
我们中许多人喜欢软件的原因就是因为我们是终身学习者, 在软件领域,
无论你从哪个方向看, 都有广阔的知识前景向各个方向发展,
而且每天都在扩展;
这意味着即便你在职业生涯中度过数十年,
但是, 和同样在看似相似的角色中度过数十年的人相比,
仍然存在巨大的知识差距;
越早意识到这点, 就能越早开始摆脱 &quot;顶替者综合症&quot; ,
转而乐于向他人学习和教导他人;</p>
<h3 id="2-软件最难的部分是构建正确的东西"><a class="header" href="#2-软件最难的部分是构建正确的东西">2. 软件最难的部分是构建正确的东西</a></h3>
<p>我知道在这点上算陈词滥调,
但是, 大多数软件工程师并不相信的原因是, 他们认为这在贬低他们的工作;
我个人认为这是无稽之谈；
相反,这突出了我们必须工作的环境本身复杂性和不合理性,
这故居了我们的挑战;
你可以设计出世界上技术上最令人印象深刻的东西,
然后, 却无人愿意使用;
这种事儿一直在发生;
设计软件主要是一种倾听活动,
我们经常不得不成为竕软件工程师, 部分通灵师, 以及部分人类学家;
投资在这个设计过程, 无论是通过专门的 UX 团队, 还是通过简单的自我教育,
都将带来巨大的回报;
因为, 你如何计算构建错误软件的真正成本?
这不仅仅是损失工程时间...</p>
<h3 id="3-最好的软件工程师像设计师一样思考"><a class="header" href="#3-最好的软件工程师像设计师一样思考">3. 最好的软件工程师像设计师一样思考</a></h3>
<p>伟大的软件工程师会思考他们代码的用户体验;
他们可能不会用各种术语来考虑,
而是考虑应该是外部API/编程API/用户界面/协议还是其它任何界面;
伟大的工程师会考虑谁将使用, 为什么要使用,如何使用,
以及这些对用户来说什么是最重要的;
牢记用户的需求, 确认是良好用户体验的核心;</p>
<h3 id="4-最好的代码是没有代码或是你不必维护的"><a class="header" href="#4-最好的代码是没有代码或是你不必维护的">4. 最好的代码是没有代码,或是你不必维护的</a></h3>
<p>我只想说: &quot;码农只能编码&quot;;
你问任何行业的人如何解决问题, 
他们都会在他们擅长的领域犯错误;
叫只是人性;
大多数软件工程师总是会在编写代码时出错,
尤其是当非技术解决方案不明朗时;
你不必维护的代码也是如此;
当很多轮子已经存在时,
工程团队很容易想要重新发明轮子;
这是一种平衡行为, 
有很多理由让你自己再来一遍,
但是, 要提防这种 &quot;没在此现实&quot;(“Not Invented Here”) 综合症;</p>
<h3 id="5-软件是达到目的的手段"><a class="header" href="#5-软件是达到目的的手段">5. 软件是达到目的的手段</a></h3>
<p>任何软件工程师的主要工作是交付价值;</p>
<p>很少有软件开发者理解这一点, 将其内化的就更少了;
真正将其内化后, 能导致解决问题的不同方式,
以及观察工具的不同方式;
如果真真的相信软件是从属于结果的,
你就会准备好找到真正&quot;适合的工具&quot;,
有时可能根本不是软件;</p>
<h3 id="6-有时你必须停止磨锯直接开始砍屎"><a class="header" href="#6-有时你必须停止磨锯直接开始砍屎">6. 有时你必须停止磨锯,直接开始砍屎</a></h3>
<p>有些人倾向于跳入问题, 并立即开始编写代码;
其它人往往想要研究和陷入硬件分析进而瘫痪;
在这些情况中,为自己设定一个截止日期,
然后, 开始探索解决方案;
当你开始解决问题时,你很快能学习到更多,
这也将引导你迭代到更好的解决方案;</p>
<h3 id="7-如果你不能很好的理解所有可能性-就无法设计出好的系统"><a class="header" href="#7-如果你不能很好的理解所有可能性-就无法设计出好的系统">7. 如果你不能很好的理解所有可能性, 就无法设计出好的系统</a></h3>
<p>这是我一直在努力解决的问题,
因为, 我的职责使我在软件工程的日常工作中越来越远;
峎上开发者生态是一项巨大的工作,
但是,了解什么是可能的至关重要;
如果你不了解给定生态中有什么是可能的,以及什么是可用的,
那么你将发现除了最简单的问题之外,
不可能设计出一个合理的解决方案来解决所有问题;
总而言之, 要警惕那些很长时间没有编写任何代码的架构专家;</p>
<h3 id="8-每个的了了的都很糟粕克服丫的"><a class="header" href="#8-每个的了了的都很糟粕克服丫的">8. 每个的了了的都很糟粕,克服丫的</a></h3>
<p>Bjarne Stroustrup 有句名言:
&quot;只有两种语言: 人们抱怨的语言, 和没人使用的语言&quot;;</p>
<p>这也可以拓展到大型系统;
没有&quot;正确&quot;的架构, 你永远无法偿还所有技术债务,
你永远无法设计出完美的界面,
你的测试总是太慢;
这不是永不让事情变得更好的借口,
而是一种给你观点的方式;
少担心优雅和完美;
相反, 努力持续改进并创建一个你的团队喜欢在其中工作,
并可以持续创造价值的宜人系统;</p>
<h3 id="9-无人问足为什么"><a class="header" href="#9-无人问足为什么">9. 无人问足&quot;为什么&quot;</a></h3>
<p>抓住任何机会质疑&quot;作事方式&quot;的假设和方法;
有新人加入嘛?
注意他们在哪里感到困惑以及他们在问什么问题;
有没有无意义新功能请求?
确保你了解目标以及是什么推动了对这一功能的渴望;
如果你没有得到明确的答案,
请继续问为什么, 直到你明白为止;</p>
<h3 id="10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员"><a class="header" href="#10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员">10. 我们应该更专注于避免0.1x 程序员,而不是寻找 10x 程序员</a></h3>
<p>10倍速程序员是一个愚蠢的神话;
某人可以在1天里生产出另外一位有能力/勤奋/有类似经验的程序员需要在2周以内生产代码的想法是愚蠢的;
我见过程序员编写10倍的代码,
然后, 你必须修复它10倍以上的次数;
某珍爱可以成为10倍程序员的唯一方法,
是将他们和 0.1 倍速程序员进行比较;
有人浪费时间, 不寻求反馈, 不测试代码,
不考虑边缘情况等等...</p>
<p>我们应该关心让 0.1 倍速程序员远离我们的团队,
而不是寻找神话般的 10 倍速程序员;</p>
<h3 id="11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见"><a class="header" href="#11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见">11. 高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见</a></h3>
<p>没有什么比对他们的工具或是如何构建软件没有有意见的高级工程师更让我担心的事儿了;</p>
<p>我宁愿有人给有强烈的反对意见, 也不愿他们完全没有意见;
如果你正在使用你的工具,而且你还没有更多喜欢或是讨厌的情绪,
那么, 你需要更多体验;
你需要探索其它语言/库/范例;
没有什么比积极寻找其它人如何使用和你不同的工具和技术来完成任务更快提高技能的方法了;</p>
<h3 id="12-人们并不是真想创新"><a class="header" href="#12-人们并不是真想创新">12. 人们并不是真想创新</a></h3>
<p>人们经常谈论创新,
但是, 他们通常寻找的是廉价的胜利和新奇;
如果你在真正的创新, 并想改变人们作事的方式,
那么大多数情况下都会收到负面反馈;
如果你相信自己在作的事儿,
并知道确实会改善事情,
那么为自己的长期战斗作好准备;</p>
<h3 id="13-数据是你系统中最重要的部分"><a class="header" href="#13-数据是你系统中最重要的部分">13. 数据是你系统中最重要的部分</a></h3>
<p>我见过很多系统, 其中希望数据完备性是系统主要机制;
在这种系统中,
任何在黄金路径之外发生的事情,都会心产生部分脏数据;
将来处理这些数据将是一场噩梦;
请记住, 你的数据可能会比你的代码要长寿;
花精力保持数据秩序和清洁,从长远看会有好的回报;</p>
<h3 id="14-寻找技术鲨鱼"><a class="header" href="#14-寻找技术鲨鱼">14. 寻找技术鲨鱼</a></h3>
<p>仍然存在的旧技术是鲨鱼而不是恐龙;
他们解决问题能力如此之强,以至在技术世界不断发生的快速变化中幸存下来;
不要和这些技术打赌,
只有在有充分理由的情况下才负担它们;
这些工具不会华而不实,
也不会令人兴奋,
得是不是, 它们能在没有很多不眠之夜的情况下完成工作;</p>
<h3 id="15-还要把谦逊误认为无知"><a class="header" href="#15-还要把谦逊误认为无知">15. 还要把谦逊误认为无知</a></h3>
<p>有很多软件工程师除非被直接问到,
否则不会发表意见;
永远不要认为仅仅因为有人没有将意见扔到你面前,
他们就没有什么可以补充的;
有时, 最吵闹的人是我们最不想听的;
和周围人交谈, 寻求他们的反馈和建议;
你会庆幸你这么作了;</p>
<h3 id="16-软件工程师应该定期写作"><a class="header" href="#16-软件工程师应该定期写作">16. 软件工程师应该定期写作</a></h3>
<p>软件工程师应该定期写 blog/日记/文档,
通常作需要他们保持书面沟通技巧的事儿;
写作可以帮助你思考问题,
并帮助你能更有效的和团队以及未来的自己沟通;
良好的书面沟通是任何软件工程师都必须掌握的最重要技能之一;</p>
<h3 id="17-尽可能保持流程简洁"><a class="header" href="#17-尽可能保持流程简洁">17. 尽可能保持流程简洁</a></h3>
<p>现在每个人想想变得敏捷,
但是,&quot;敏捷&quot;就是以小块的方法构建事物/学习/然后迭代;
如果有人试图在其中塞入更多东西,
那么,他们可能只是在卖东西;
这并不是说人们不需要问责或是帮助以便用这种方式协作,
但是, 你有多少次听到你最喜欢的科技公司或是大型开源项目成员有吹嘘他们的 Scrum 流程有多NB?
保持精益过程,
直到你知道你需要更多;
相信你的团队,他们能交付成果;</p>
<h3 id="18-软件工程师和所有人一样需要有主人翁精神"><a class="header" href="#18-软件工程师和所有人一样需要有主人翁精神">18. 软件工程师和所有人一样,需要有主人翁精神</a></h3>
<p>如果你将某人从他们的工作成果小分离出来,
他们就会更彡关心他们的工作;
我认为这几乎是必然的;
这是跨职能团队作的如此出色,
以及 DevOps 变得如此流行的主要原因;
这不仅仅是关于交接和效率低下,
而是关于从头到尾拥有整个过程, 并且是直接的负责交付价值;
让一群充满激情的人完全拥有设计/构建和交付软件(或任何东西)的权利,
惊人的事情就会发生;</p>
<p>(译注: 当然, 得是有意义的事务, 为领导一些幻想去努力很难有什么主人翁精神能触发)</p>
<h3 id="19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值"><a class="header" href="#19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值">19. 面试对于告诉某人将成为团队成员有多赞,几乎毫无价值</a></h3>
<p>面试最好花在了解某人是谁,
以及他们对特定专业领域的兴趣程度上;
试图推测他们将成为多么优秀的团队成员是徒劳的;
相信我,
一个人有多聪明或是多博学也不能很好的证明他们将成为一名优秀的团队成员;
没有人会在面试中告诉你他们不可靠/爱辱骂/自负或是从不准时参加会议;
人们可能会声称他们对这些事情有&quot;信号&quot;...
&quot;如果他们在第一面试时询问请假,那么他们永远不会去请假!&quot;
但是, 这些都是废话;
如果你使用这种信号, 只是在猜测并拒绝优秀的候选人;</p>
<h3 id="20-始终努力构建一个更小的系统"><a class="header" href="#20-始终努力构建一个更小的系统">20. 始终努力构建一个更小的系统</a></h3>
<p>有很多力量促使你预先构建更大的系统;
预算分配, 无法测定应该精减哪些功能,
希望提供系统的&quot;最佳版本&quot;;
所有,这些事情都非常有力的推动我们构建更多;
你应该阻止这个;
你在构建一个系统时学到了很多东西,
你最终将迭代到一个比你最初设计的系统更好的版本;
令人惊讶的必须,
这对太多数人来说是难以接受的;</p>
<h2 id="你的故事呢"><a class="header" href="#你的故事呢">你的故事呢?</a></h2>
<p>这是全部了, 20年的软件生涯提炼出来的的20条精辟断言;</p>
<p>如果有什么能引发你的共鸣,
我很很听听;
我也很想知道你在职业生源中积累的智慧并愿意分享出来;
请在评论中留言吧;</p>
<h2 id="refer-29"><a class="header" href="#refer-29">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p>很有人不同意所有观点: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/#comment-142472">January 25, 2023 at 7:25 pm</a></p>
<h3 id="hard-disagree-with-most-of-the-20-items"><a class="header" href="#hard-disagree-with-most-of-the-20-items">Hard disagree with most of the 20 items.</a></h3>
<ol>
<li>
<p>Writing software is difficult, tedious and needs real work. No silver bullet libraries, no methodology, no framework, no IOT, no amount of unit tests will get the work done faster.</p>
</li>
<li>
<p>Developers collect tools, libraries and pet technologies and make projects go over their time and budget by doing it.</p>
</li>
<li>
<p>Code should encapsulate algorithms and not be structured other wise. Code should follow the business logic and be readable and match business requirements easily.</p>
</li>
<li>
<p>Forgetting history keeps the productivity and industry down. Microsoft re-discovering the same old technology which existed on 1960s mainframes for the 7th time just to sell products, trademark buzzwords, training, certification and everything is an anchor around the modern developer’s neck. Think file transfer -&gt; X12 -&gt; serial communication -&gt; raw socket packets -&gt; corba -&gt; xml soap -&gt; xml http -&gt; Rest JSON http -&gt; gRpc as a 50 year journey of rediscovering the same thing repeatedly, each not really that much better than the older technologies, wrapping mounds of interlarded crud on top of fragile, hard to program libraries and the square peg in a round hole mismatch.</p>
</li>
<li>
<p>Refusing to hold W3C and large tech companies accountable for not fixing web HTTP, HTML, CSS and JavaScript for 25+ years.
– How can I create a control which has HTML, CSS, JS which has encapsulated CSS, encapsulated HTML, encapsulated JS without a 10,000 file framework?
– How to match HTML DOM elements with JS without using quoted magic strings? Quoted magic strings were proven anti-productivity and anti-quality in the 1960s
– How to have a UI without the everything is a call back and function pointer? Function pointers with modern wrappings are just as bad as the 1060s computed jump to function tables</p>
</li>
<li>
<p>Forgetting that tech is a business with a 7 year hype cycle, with the new thing being embryonically hyped for 2 years by cutting edge bloggers, then 2 years by sales marketing of companies, then 3 years of disappointment for companies trying to implement it. Followed by, abandonment when the ROI does not work out. Resume driven development, just for business persons.
And yes, there’s a new hype every 2 years to waste time and money on</p>
</li>
<li>
<p>Not holding tech companies accountable when they release major products, .net core, which have less than a 5 year full support lifecycle. Long term support .net is under 3 years.
That is a forced upgrade every 3 years for every .net system just to pass the IT auditors at a large company</p>
</li>
<li>
<p>Devaluing your own worth and work as a developer by telling everyone that the proposed product/task is easy. Software dev is hard work, less than 1 of a 1000 people can even do it poorly.
I would not go to a brain surgeon that told everyone that what he does is easy.</p>
</li>
<li>
<p>Forgetting that software development is a hard, tedious, isolated job where people desiring lots of human interaction will rapidly leave the field by their own choice and lots of people not getting into the field by their own choice.</p>
</li>
<li>
<p>Not telling people that you as a developer have to say “No, it’s too expensive” or “No, it’s too risky” as a regular part of your job. Persons not developing software treating you poorly with career ending consequences just because you won’t accept the death march cross to bear of impossible requirements of an impossibly short deadline</p>
</li>
<li>
<p>Not helping your fellow developers out. Speak well of your co-developers, team, and industry. Don’t downplay the difficulty, complexity or contribution of software.</p>
</li>
<li>
<p>Not calling people out when they think that more data, metrics for everything will automatically solve problems. Ask for a business case, ask for the questions they want to answer (in written form), get the business case and questions they want to answer from the requestor, make sure they are approved before committing to a tight deadline</p>
</li>
<li>
<p>Not damaging the next developer on your project – too many technologies, framework of the month, just another nuget package, one more class, have another 3 patterns, data on disk, data in database structure and consistency is not important and, yes, this system will never receive/send upstream/downstream data</p>
</li>
<li>
<p>Accepting code without parameter checking, error handling or in-line comment documentation (<em>cough</em> vendor’s happy path ‘doc’ page or <em>cough</em> signature only documentation with no example code or error handling.)</p>
</li>
<li>
<p>Misguided acceptance that best practices are best and not just a short nicely sized blog entry. Best practices, in many cases, do not scale for large 1,000,000+ line of code systems and make maintenance harder.</p>
</li>
<li>
<p>Not challenging the ‘more technology is better’ approach</p>
</li>
</ol>
<h2 id="logging-20"><a class="header" href="#logging-20">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230201 ZQ init.</li>
</ul>
<pre><code>            _~∽&amp;`~_
        \) /  ◷ ◴  \ \/
          '_   V   _'
          \ '--.--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="希望一早知道的关键概念"><a class="header" href="#希望一早知道的关键概念">希望一早知道的关键概念</a></h1>
<p>原文: <a href="https://rauljordan.com/rust-concepts-i-wish-i-learned-earlier/">rauljordan::blog</a></p>
<h2 id="快译"><a class="header" href="#快译">快译</a></h2>
<p>过去一个月里, 我被 Rust 语言彻底迷住了,
因为,她在编写内存安全的现代程序方面具有独特的优势.
多年以来, 有几种语言已经成为工程师编写弹性后端软件的首选语言.
潮流已经从 JAVA/C++ 转向 Go 和 Rust,
她们结合了数十年编程语言理论来构建我们这个时代最需要的工具.</p>
<p>Rust 的地位不言则明.
作为最受一欢迎的语言, 连续7年度在著名 <code>stack overflow</code> 调查中排名第一!
最近还作为 Linux 内核的一部分发布 -- 这是除 C 之外任何语言之前都无法作到的壮举.
对我而言, 这门语言令人兴奋的地方在于,
她在软件构建艺术方面提供了一些真正新颖的东西.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;
use std::{collections::VecDeque, sync::Condvar, sync::Mutex};

fn main() {
    let queue = Mutex::new(VecDeque::new());

    thread::scope(|s| {
        let t = s.spawn(|| loop {
            let item = queue.lock().unwrap().pop_front();
            if let Some(item) = item {
                dbg!(item);
            } else {
                thread::park();
            }
        });

        for i in 0.. {
            queue.lock().unwrap().push_back(i);
            t.thread().unpark();
            thread::sleep(Duration::from_secs(1));
        }
    })
}</code></pre></pre>
<p>Rust 在整个系统编程中获得了令人难以置信的使用, 
也因难以学习而闻名. 尽管如此, 还是有很多优秀的 Rust 内容可以满足初学者和高级程序员的需求.
然而, 他们中太多人专注解释语言的核心机制和所有权概念, 而不是构建应用程序.</p>
<p>作为一名编写高并发程序并专注在系统编程的 Go 开发者, 
我在学习如何使用 Rust 构建真实程序的过程中遇到了很多障碍. 
也就是交织, 如果我将当前正在从事的工作移植到 Rust 中, 那么所有这些教程的效果如何呢?</p>
<p>此篇文章旨在介绍我进入 Rust 兔子洞的经历, 
以及我希望一些学习资源可以更好阐述的内容. 
对个人而言, 我无法通过简单的观看 youtube 视频来学习一门新语言, 
而是必须通过为自己寻找解决方案,犯错以及对过程感受谦卑来积累．</p>
<h3 id="关于参考"><a class="header" href="#关于参考">关于参考</a></h3>
<p>Rust 中有两种引用, 共享引用(也称为 <code>借用</code>)和可变引用(也称为<code>独占引用</code>).
通常这些被视为变量 x 上的 &amp;x 以及 &amp;mut x . 
一旦我开始将后者称为&quot;独家参考&quot;, 这两白间的区别就更有意义了.</p>
<p>Rust 的参考模型相当简单. 借款人可以根据需要拥有对某对象的尽可能多的共享引用, 
但是, 一次只能有一个独占引用. 
否则, 你可能会有很多调用者同时尝试对同一个值进行修改的囧境;
如果很多借用者也可以持有独占袭用, 
你将面临未定义行为风险, 
而安全的 Rust 则不允许这么折腾.</p>
<p>在学习 Rust 时, 都用 &amp;mut 独家参考可以节省很多时间:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo {
    x: u64,
}

impl Foo {
    /// Any type that borrows an instance of Foo can
    /// call this method, as it only requires a reference to Foo.
    pub fn total(&amp;self) -&gt; u64 {
        self.x
    }
    /// Only exclusive references to instances of Foo
    /// can call this method, as it requires Foo to be mutable.
    pub fn increase(&amp;mut self) {
        self.x += 1;
    }
}

let foo = Foo { x: 10 };
println!(&quot;{}&quot;, foo.total()) // WORKS.
foo.increase() // ERROR: Foo not declared as mut
<span class="boring">}</span></code></pre></pre>
<h3 id="双向引用是可以的"><a class="header" href="#双向引用是可以的">双向引用是可以的</a></h3>
<blockquote>
<p>Bidirectional references are possible</p>
</blockquote>
<p>在其它具有垃圾收集功能的语言中, 很容易定义图形数据结构或其它包含对某些子项引用的类型, 
并且这些引用可以包含对其父项的引用;
在 Rust 中, 如果不完全理解借用规则, 这是很难作到的;
但是, 仍然可以使用标准库提供的正法.</p>
<p>假设我们有一个名为 Node 的结构, 
包含一组对子节点的引用, 以及一个对父节点的引用; 
通常, Rust 会抱怨, 但是, 我们可以通过将父引用包装在称为 <code>弱指针</code> 的东西中来满足借用检查器的要求;
这种类型告诉 Rust 一个节点消失, 或者其子节点消失, 不应该意味着父节点也应该被删除;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::{Rc, Weak};

struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这为我们提供了构建双向引用的便利原语; 
然而, 我很快发现在 Rust 中构建图形数据真的很难, 
除非你真的知道自己在作什么, 考虑到一个人需要围绕有效建模数据来作大量的 <code>book-keeping</code> 工作以满足编译器.</p>
<p>(是也乎: 编译器作为 Rust 生态中最大的 BOSS 必须优先满足.)</p>
<h3 id="实施-deref-令代码更清晰"><a class="header" href="#实施-deref-令代码更清晰">实施 Deref 令代码更清晰</a></h3>
<blockquote>
<p>Implement Deref to make your code cleaner</p>
</blockquote>
<p>有时我们希望将包装器类型视之为其包含的内容;
对于常见的数据结构(比如 vec),智能指针(例如 Box) 甚至引用计数类型(类似 Rc 和 Arc) 都是如此;
标准库包含称为 Deref 和 DerefMut 的特征, 
她们将报时你告诉 Rust 应该如何取消引用一个类型;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Deref, DerefMut};

struct Example&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Deref for Example&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.value
    }
}

impl&lt;T&gt; DerefMut for Example&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.value
    }
}

let mut x = Example { value: 'a' };
*x = 'b';
assert_eq!('b', x.value);
<span class="boring">}</span></code></pre></pre>
<p>上述示例代码中, 我们可以将 <code>*x</code> 视为其基础值 <code>&quot;a&quot;</code>, 
甚至可以改变它, 因为, 我们定义了应该如何在借用或可变引用中取消引用的规则;
这很强大, 也是你无需担心在 Box 等智能指针中包装类型的原因;</p>
<p>值被装箱的事实是一个实现细节, 可以通过这些特征抽象出来;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    value: u64,
}
let mut foo = Box::new(Foo { value: 10 });

// Box implements DerefMut, so this will work fine!
*foo = Foo { value: 20 };
// Dot methods will work on foo because Box implements Deref.
// We do not have to worry about the implementation
// detail that Foo is boxed.
assert_eq!(20, foo.value);
<span class="boring">}</span></code></pre></pre>
<h3 id="小心实现-deref-类型方法"><a class="header" href="#小心实现-deref-类型方法">小心实现 Deref 类型方法</a></h3>
<blockquote>
<p>Be careful with methods on types that implement Deref</p>
</blockquote>
<p>有没有想过, 为什么像 <code>Arc::clone</code> 这类方法的存在, 
而我们只能对 Arc 值执行 <code>.clone()</code>?
原因和类型如何实现 Deref 有关, 
这是开发者应该警惕的事儿;</p>
<p>考虑以下示例, 我们正在尝试从标准库中实现我们自己版本的
多生产者/单一消费者(mpsc)通道:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex, Condvar};

pub struct Sender&lt;T&gt; {
    inner: Arc&lt;Inner&lt;T&gt;&gt;,
}

impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;mut self, t: T) {
        ...
    }
}

impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // ERROR: Does not know whether to clone Arc or inner!
            inner: self.inner.clone(),
        }
    }
}

struct Inner&lt;T&gt; {
    ...
}

impl&lt;T: Clone&gt; Clone for Inner&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>上述示例中, 我们有一个要在其上实现 Clone 特征的 Sender 类型;
该结构有一个名为 inner 的字段, 其类型为 <code>Arc&lt;Inner&lt;T&gt;&gt;</code> ;
回想一下 Arc 已经实现了 Clone 和 Deref ;
最重要的是, 我们的 Inner 还现实了 Clone ;
对于上面的代码, Rust 并不知道我们是要克隆 Arc 还是实际的内部值,
所以, 上面代码会失败;
在这种情况下, 我们可以使用 Arc 从 sync 包中提供的实际方法;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // Now Rust knows to use the Clone method of Arc instead of the
            // clone method of inner itself.
            inner: Arc::clone(&amp;self.inner),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="理解何时以及何时不用内部可变性"><a class="header" href="#理解何时以及何时不用内部可变性">理解何时以及何时不用内部可变性</a></h3>
<blockquote>
<p>Understand when and when not to use interior mutability</p>
</blockquote>
<p>有时, 你需要在代码中使用 Rc 或是 Arc 等结构, 
又或者实现包装一些数据结构, 然后, 又想要改变被包装的数据;
很快, 编译器就会告诉你, 内部可变性是不允许的, 乍看起来这很棘手;
然而, 有一些方法允许 Rust 中的内部可变性, 
甚至是由标准库提供的;</p>
<p>最简单的一种是 Cell, 她为你提供数据的内可变性;
也就是说, 嘦数据复制成本低, 
你就可以在 Rc 中改变数据;
你可以通过将数据包装在 <code>Rc&lt;Cell&lt;T&gt;&gt;</code> 中来实现这一点;
她提供了 get 和 set 方法,
甚至不需要被 mut , 因为, 她们是在底层复制数据的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// impl&lt;T: Copy&gt; Cell&lt;T&gt;
pub fn get(&amp;self) -&gt; T

// impl&lt;T&gt; Cell&lt;T&gt;
pub fn set(&amp;self, val: T)
<span class="boring">}</span></code></pre></pre>
<p>其它类型, 比如 RefCell 有助于将某些借用检查移至运行时, 并跳过一些编译器的严格过滤;
然而, 这是有风险的, 因为, 如果没有完成借用检查, 就可能在运行时触发 panic ;
将编译器当成朋友, 你会获得回报;
通过跳过编译器检查, 或是将她们推迟到运行时, 
等于告诉编译器&quot;相信我 --- 我作的都是正确的&quot;;</p>
<p>而 std::cell 包甚至通过一个很有帮助的消息警告我们:</p>
<pre><code>
更常见的继承可变性, 其中必须具有唯一访问权限才能改变值,
这一语言元素是令 Rust 能强力推理指针别名, 静态防止崩溃错误的关键;
因此, 继续可变性是首选, 内部可变性是最后的手段;
由于 Cell 类型可以在不允许突变的地方启用突变, 
因此, 在某些情况中, 内部可变性也许是合适的, 甚至必须使用, 例如:

- 在不可变事物的&quot;内部&quot;引入可变性
- 逻辑不可变方法的实现细节
- 克隆的变异实现

</code></pre>
<h3 id="get-和-get-mut-方法是一回事儿"><a class="header" href="#get-和-get-mut-方法是一回事儿">get 和 get mut 方法是一回事儿</a></h3>
<blockquote>
<p>Get and get mut methods are a thing</p>
</blockquote>
<p>很多类型, 包含 vec 都实现了 get 与 get_mut 方法,
让你可以借用和改变结构中的元素
(前者只有在你有一个对集会的可变引用时才可能);
我花了一段时间, 才知道这些选项可用于许多数据结构,
她们通过更轻松的编写干净的代码, 帮助我的生活更轻松!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut [0, 1, 2];

if let Some(elem) = x.get_mut(1) {
    *elem = 42;
}
assert_eq!(x, &amp;[0, 42, 2]);
<span class="boring">}</span></code></pre></pre>
<h3 id="拥抱不安全但合理的代码"><a class="header" href="#拥抱不安全但合理的代码">拥抱不安全但合理的代码</a></h3>
<blockquote>
<p>Embrace unsafe but sound code</p>
</blockquote>
<p>作为一名 Go 开发者, &quot;unsafe&quot; 包总是感觉很不靠谱,
而且我很少接触;
然而, Rust 中 “unsafe” 的概念是完全不同的;
事实上, 很多标准库都使用 <code>“unsafe”</code> 来取得巨大成功!</p>
<p>这怎么可能? 尽管 Rust 使未定义的行为成为不可能,
但是, 这不适用于标记为 “unsafe” 的代码块;
相反, 编写 “unsafe” Rust 的开发者嘦保证其使用合理,
即可获得所有好处;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Example taken from the Rustonomicon
fn item_at_index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt; arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>嘦你能证明你的 API 是可靠的,
就接受 unsafe, 但是, 要避免逈你的消费者暴露 unsafe 函数,
除非是真正有保证的;
出于这个原因, 在 Rust 中,对你的包内部进行严格控制,
可以证明 unsafe 代码块是合理的了;</p>
<p>通常在性能绝对重要的情况下, 才使用 unsafe,
或者当你知道使用 unsafe 代码块是解决问题的简单方法,
并且可以证明代码的可靠性时;</p>
<p>(<code>是也乎:</code></p>
<p>安全和可靠分离, 那么, 什么是可靠呢?</p>
<p>)</p>
<h3 id="尽可能用-impl-类型作为参数而不是通用约束"><a class="header" href="#尽可能用-impl-类型作为参数而不是通用约束">尽可能用 impl 类型作为参数而不是通用约束</a></h3>
<p>这点来自 Golang, 我认为特征可以一直简单的作为函数参数来提供;
比如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Meower {
    fn meow(&amp;self);
}

struct Cat {}

impl Meower for Cat {
    fn meow(&amp;self) {
        println!(&quot;meow&quot;);
    }
}

// ERROR: Meower cannot be used as it does not have
// a size at compile time!
fn do_the_meow(meower: Meower) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>...但是,上述代码失败了,
因为, trait 对象在编译时没有 Rust 完成工作需要的内存尺寸;
我们可以通过添加 <code>&amp;dyn Meower</code> 来告诉编译器这是动态调整大小来绕过,
但是, 很快我了解到这不是 <code>rusty</code>/锈范儿 解决方案;
相反,开发者倾向于衖受特征约束的通用参数,
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow&lt;M: Meower&gt;(meower: M) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>...现在能通过编译了;
然而,随着函数越来越复杂, 如果我们还包括其它通用参数,
就可能会有一个非常难以阅读的函数声明;
在此示例中,如果我们只想用一次 meow,
那么, 实际上并不需要动用泛型;
我们甚至于并不关心 meow 的结果,
所以, 可以改写为这样:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow(meower: &amp;impl Meower) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>这样告诉编译器:&quot;我只想要实现 Meow 的东西&quot;;
当然,这正是我们需要的,
并且,首先不需要函数的通用返回类型时,
此模式会更加清晰;</p>
<h3 id="用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有"><a class="header" href="#用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有">用 iter() 过程中想借用时, iter mut() 用以独占 refs,而 into iter() 支持拥有</a></h3>
<p>很多教程立即跳转到使用下面的 into_iter 方法来迭代 vectors/向量:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let items = vec![1, 2, 3, 4, 5];
for item in items.into_iter() {
    println!(&quot;{}&quot;, item);
}
<span class="boring">}</span></code></pre></pre>
<p>然而,当我们刚刚开始在结构中使用这个迭代器方法时,
很多初学者(包括作者自己)都碰壁了,例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: Vec&lt;u32&gt;,
}

impl Foo {
    fn all_zeros(&amp;self) -&gt; bool {
        // ERROR: Cannot move out of self.bar!
        self.bar.into_iter().all(|x| x == 0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>并立即提示:</p>
<pre><code>    error[E0507]: cannot move out of `self.bar` which is behind a shared reference
       --&gt; src/main.rs:9:9
        |
    9   |         self.bar.into_iter().all(|x| x == 0)
        |         ^^^^^^^^ ----------- `self.bar` moved due to this method call
        |         |
        |         move occurs because `self.bar` has
        |         type `Vec&lt;u32&gt;`, which does not implement the `Copy` trait

</code></pre>
<p>作为菜鸟尝试了很多办法后, 才意识到 <code>.into_ter()</code> 取得了集合的所有权,
这不是我的目标所需要的;
相反, 在迭代器上还有另外两种有用的方法, 真希望当时能早点知道丫们;</p>
<p>第一个是 <code>.iter()</code> ,借用集合, 让你断言关于其值的东西,但是, 不拥有或是改变她们;
再有就是 <code>iter_mut()</code> 帮助你改变集合内部值,嘦你是唯一的exclusive reference/独占参考;</p>
<p>总之, 当你只需要借用时用 <code>.iter()</code>,
当你想要获得所有权时用 <code>.into_iter()</code>,
当你需要改变迭代对象的元素时用 <code>.iter_mut()</code>;</p>
<h3 id="phantom-数据不仅仅用以处理指向类型的原始指针"><a class="header" href="#phantom-数据不仅仅用以处理指向类型的原始指针">Phantom 数据不仅仅用以处理指向类型的原始指针</a></h3>
<p>当你第一次遇到 Phantom data/幻数据时,
一定感觉很奇怪,但是, 很快就会成为一种告诉编译器&quot;拥有&quot;某个值的好方式,
尽管只有一个指向她的原始指针;
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Foo&lt;'a, T: 'a&gt; {
    bar: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这儿告诉编译器 Foo 拥有 T,
尽管只有一个指向她的原始指针;
这对于需要处理原始指针和使用 unsafe Rust 的应用程序很有帮助;</p>
<p>但是, 也可以是一种告诉编译器你的类型还没实现 Send 或是 Sync 特征的方法!
你可以使用 PhantomData 包装以下类型,并在你的结构中使用她们,
来作为一种方式告诉编译器你的结构即不是 Send 也不是 Sync;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type PhantomUnsync = PhantomData&lt;Cell&lt;()&gt;&gt;;
pub type PhantomUnsend = PhantomData&lt;MutexGuard&lt;'static, ()&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="用-rayon-实现并行增量"><a class="header" href="#用-rayon-实现并行增量">用 rayon 实现并行增量</a></h3>
<p>有时, 你希望在遍历集会时并行化工作,
但是, 在处理线程和确保类型可以安全的跨线程发送时却碰壁了;
有时, 如果额外的样板文件令你的代码几乎不可读,那就已经不值得了;</p>
<p>相反, 有一个名为 Rayon 很赞的包, 已经提供了以无缝方式并行化计算的上好工具;
例如,假设我们有一个计算数组平方和的函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>由于乘法和加法的性质, 上述代码绝对可以并行化,
Rayon 通过让我们自动访问数组等集会的&quot;并行迭代器&quot;,
使并行化变得微不足道;
这是几乎零样板的代码;
而且也完全不影响可读性:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Importing rayon prelude is what gives us access to .par_iter on arrays.
use rayon::prelude::*;

fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    // We can use par_iter on our array to let rayon
    // handle the parallelization and reconciliation of
    // results at the end.
    input.par_iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>工程中如果自己要构造各种内部库,
也值得给出这种使用界面,
和以往使用内置库的代码完全兼容,
只是在关键节点处替换为自己魔改/加强过的...
)</p>
<h3 id="开发-rust-库时理解-拓展特征-的概念"><a class="header" href="#开发-rust-库时理解-拓展特征-的概念">开发 Rust 库时理解 拓展特征 的概念</a></h3>
<p>那么 Rayon 是如何以如此干净的方式完成上述工作的呢?
答案在于&quot;拓展特征&quot;,
这些特征可以定义为对其它特征的拓展,
例如 Iterator;
也就是说,我们可以逈通常实现 Itertor 特征的项追加其它有用的函数,
但是, 她们只有在特性范畴以内时才可用,
比如通过将其导入文件中;</p>
<p>这种方式非常好,因为,这些特征只有在你在项目中导入拓展特征时才可用,
并提供了一种使用干净的 API 拓展通用集合和类型的好方法,
开发者可以像使用普通 API 一样轻松的使用这些 API;
由于 Rayon 的拓展特征,
使用并行迭代器就像在 Rust 中使用普通迭代器一样简单;</p>
<p>事实上,这有一个信息量很大的演讲,解释了如何使用 拓展特征 来开发一个在迭代器上提供进度条的库;</p>
<p>(<code>是也乎</code>:</p>
<p><a href="https://www.youtube.com/watch?v=bnnacleqg6k">&quot;Type-Driven API Design in Rust&quot; by Will Crichton - YouTube</a></p>
<p>配套看看 Rayon 官方对自己实现原理的嗯哼: <a href="https://github.com/rayon-rs/rayon/tree/master/src/iter/plumbing">rayon/src/iter/plumbing at master · rayon-rs/rayon</a>
以及专门的解析文章: <a href="https://developers.redhat.com/articles/2023/01/30/run-app-under-openshift-service-mesh">How Rust supports Rayon's data parallelism | Red Hat Developer</a></p>
<p>大约可以感受到 Rust 世界的任性了...
)</p>
<h3 id="拥抱-option-和-result-类型的一元性"><a class="header" href="#拥抱-option-和-result-类型的一元性">拥抱 Option 和 Result 类型的一元性</a></h3>
<p>使用 Option 和 Result 之后,
人们会很快看到<code>.unwrap()</code> 将值从她们移出,
如果 Option 和 Result 是共享引用(比如 struct)的一部分,
就将导致失败;
然而,有时我们想要的只是断言 Option 匹配内部的值或获取对其内部的引用;
有很多方法可以作到这点,
但是, 还有一种方式能不用离开 Option 领域:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_five(x: Option&lt;i32&gt;) -&gt; bool {
    // Contains can just check if the Option has what we want.
    x.contains(&amp;5)
}
<span class="boring">}</span></code></pre></pre>
<p>另一个示例是我们想要用 None 值替换 Option 内数据,
也就是和某些结构交互时;
我们可以用指令式编程的方式来编写,
并按照以下方式详细完成:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    data: Option&lt;T&gt;,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    // Takes the value of data and leaves None in its place.
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.data.is_none() {
            return None;
        }
        let value = self.data.unwrap();
        self.data = None;
        value
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然而, Option 有一些非常酷的属性,
因为, 她们的基本性质是定义了有用的方法,
可以让我们的生源更加轻松;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Takes the value of data and leaves None in its place.
fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.data.take()
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 中的 Option 以函数式编程语言中相同的范例为模型,
属于更广泛的数据类型类别, 称为 Monad;
不用深入理解 Monad 是什么, 而嘦将其视为数据的包装器,
我们可以在不需要从中取出东西的情况下对其进行操作;
比如, 想象一个将两个 Option 内部值相加并返回一个 Option 的函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if x.is_none() || y.is_none() {
        return None;
    }
    return Some(x.unwrap() + y.unwrap());
}
<span class="boring">}</span></code></pre></pre>
<p>上述代码看起来有点点笨拙,因为,需要执行 none 检验,
而且我们必须从两个 Option 中提取值并从中构建一个新 Option 就很囧;
然而, 由于 Option 的特殊属性,
我们可以作的更好!
这是我们可以获得的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    x.zip(y).map(|(a, b)| a+b)
}
<span class="boring">}</span></code></pre></pre>
<p>可以对 option 使用 zip 和 map ,
就像我们可以处理数组和向量一样;
此属性也存在于 Result 类型中,
甚至存在于诸如 <code>Future</code> 类型之类事物中;
如果你对为什么这么作感到好奇,
请继续挖掘 Monad 的更多信息 -&gt; <a href="https://stackoverflow.com/questions/2704652/monad-in-plain-english-for-the-oop-programmer-with-no-fp-background">functional programming - Monad in plain English? (For the OOP programmer with no FP background) - Stack Overflow</a></p>
<p>接受 Option 和 Result 类型的一元性质,
不要到处使用 unwrap 和 if x.is_none() {} else ;
本身就包含了很多有用的方法,
你可以在标准库中阅读这些方法;</p>
<p>(<code>是也乎:</code></p>
<p>所以, 标准库的通读是一个基本功了,
不过, 相比 Python 等其它语言的官方文档,
docs.rs 实在太麻了点儿,还要习惯一下;</p>
<p>)</p>
<h3 id="了解-drop-应该如何针对不同数据结构实现"><a class="header" href="#了解-drop-应该如何针对不同数据结构实现">了解 Drop 应该如何针对不同数据结构实现</a></h3>
<p>标准库将 Drop 特性描述为:</p>
<p>当不再需要某个值时, Rust 将对该值运行&quot;析构函数&quot;;
不再需要某个值最常见方式是超出作用域;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>在 Rust 中编写数据结构时, Drop 是至关重要的;
人们必须有一种合理的方法来处理一旦不再需要内存时如何丢弃(安全的);
使用引用计数类型可以报时你克服这些障碍,
但是, 这并不总是足够的;
例如,编写自定义链表或是编写使用通道的结构时,通常要实现自定义版本的 Drop;
当你看到标准库实际如何执行时,
实现 Drop 比并看起来容易的多:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// That's it!
fn drop&lt;T&gt;(t: T) {}
<span class="boring">}</span></code></pre></pre>
<p>巧妙利用失去作用域时销毁的规则,
<code>std::mem::drop</code> 有一个空函数体!</p>
<p>这是一个技巧, 你可以在自己的自定义 Drop 实现中使用,
嘦你涵盖所有基类?即可;</p>
<h3 id="真的对借用检查员很气-那就用不可变数据结构"><a class="header" href="#真的对借用检查员很气-那就用不可变数据结构">真的对借用检查员很气? 那就用不可变数据结构</a></h3>
<p>函数式程序员喜欢说全局的/可变的状态是万恶之源,
如果可以避免,那毛还要使用呢?
多亏了 Rust 的函数式结构,
我们才能构建从一开始就不可能突变的结构结构!
当你需要编写类似在 Haskell/OCaml 或其它语言中看到的纯粹函数式代码时,
这尤其有用;</p>
<p>通过链接列表综合教程中的示例,
我们可以看到如何构建一个不可变列表,其中节点有引用计数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }
    ...
<span class="boring">}</span></code></pre></pre>
<p>这就很赞,因为,其行为类似于函数式数据结构,
在函数式数据结构中,
人们不会通过追加前缀来修改列表,
而是通过以新元素作为其头部和现有列表作为尾部来构建列表完成新构建;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    [head] ++ tail
<span class="boring">}</span></code></pre></pre>
<p>请注意,上述方法都不需要 mut, 因为,我们的数据结构是不可变的!
这在内存上也是非常高效的,因为,该结构是引用计数的,
这意味着如果此数据结构上有多个调用者,
我们不会浪费不必要的资源来复制节点的底层内存;</p>
<p>Rust 中的纯函数代码很简洁,
但是,多数时候,需要尾递归来了把用我快这种方式实现的高性能代码；
而且，要小心，毕竟 Rust 编译器不保证尾调用优化；
值得进一步挖掘更多信息 -&gt; <a href="https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust">When is tail recursion guaranteed in Rust? - Stack Overflow</a></p>
<p>(<code>是也乎:</code></p>
<p>这就尴尬了, 只是个看起来很美的思路,
毕竟 Rust 不是纯函数语言,
递归并不是第一公民;</p>
<p>所以, 这种场景中,还是老实和 借用管理员 好好商量吧...</p>
<p>)</p>
<h3 id="traits-篮有助减少重复"><a class="header" href="#traits-篮有助减少重复">traits 篮有助减少重复</a></h3>
<p>有时,可能希望通过很多不同的特征来约束泛型参数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T: Copy + Clone + Ord + Bar + Baz + Nyan&gt; {
    vals: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>但是,一旦你开始编写 impl 语句,
或是当你有多个通用参数时,
这很快就会失控;
相反你可溶性定义一个整体特征, 使代码更加 DRY;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Fooer: Copy + Clone + Ord + Bar + Baz + Nyan {}

struct Foo&lt;F: Fooer&gt; {
    vals: Vec&lt;F&gt;,
}

impl&lt;F: Fooer&gt; Foo&lt;F&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<p>traits 篮可以帮助减少重复，
但是，不要让其变得过大；
在很多情况中，
让一个类型需要如此多的约束可能会产生坏味道,
因为,你创建的抽象太大了;
相反,如果你发现约束无缘无故的变得太大,
请传入具体类型;
然而,某些应用和远又可能受益于 blanket traits/特征篮,
例如旨在提供尽可能通用的 API 库;</p>
<h3 id="match-语句本质上很灵活和结构化的"><a class="header" href="#match-语句本质上很灵活和结构化的">Match 语句本质上很灵活和结构化的</a></h3>
<p>例如,可以将值作为元组组合在一起并执行以下操作,而不是嵌套匹配语句:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player_outcome(player: &amp;Move, opp: &amp;Move) -&gt; Outcome {
    use Move::*;
    use Outcome::*;
    match (player, opp) {
        // Rock moves.
        (Rock, Rock) =&gt; Draw,
        (Rock, Paper) =&gt; Lose,
        (Rock, Scissors) =&gt; Win,
        // Paper moves.
        (Paper, Rock) =&gt; Win,
        (Paper, Paper) =&gt; Draw,
        (Paper, Scissors) =&gt; Lose,
        // Scissor moves.
        (Scissors, Rock) =&gt; Lose,
        (Scissors, Paper) =&gt; Win,
        (Scissors, Scissors) =&gt; Draw,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个示例足以说明为什么模型匹配比指令式语言中的 switch 语句更强大,
而且, 在劳模内部值方面可以作的更多.</p>
<h3 id="如果匹配对象是有限且已知的嫑使用-_--子句"><a class="header" href="#如果匹配对象是有限且已知的嫑使用-_--子句">如果匹配对象是有限且已知的,嫑使用 _ =&gt; 子句</a></h3>
<p>例如,我们有个枚举:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
    Nyan,
    Zab,
    Azb,
    Bza,
}
<span class="boring">}</span></code></pre></pre>
<p>在编写 match 语句时,如果可能的话, 应该匹配枚举的所有类型,而不是求助于 catch-all 子句:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match f {
    Bar =&gt; { ... },
    Baz =&gt; { ... },
    Nyan =&gt; { ... },
    Zab =&gt; { ... },
    Azb =&gt; { ... },
    Bza =&gt; { ... },
}
<span class="boring">}</span></code></pre></pre>
<p>这对代码维护非常有帮助,因为,如果枚举的原始编写者逈其追加更多变体,
如果我们忘记在匹配语句中处理新变体, 功能将无法编译;</p>
<h3 id="match-保护条款也很强大"><a class="header" href="#match-保护条款也很强大">Match 保护条款也很强大</a></h3>
<p>当你有未知或是可能无限数量的匹配项时(例如数字范围),
匹配守卫就很棒;
然而, 如果你的范围不能被守卫完全包含时,
将迫使你使用一个包罗万象的 <code>_ =&gt;</code>,
这在编写可维护代码时可能就是一个缺点;</p>
<p>Rust 书中典型示例如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Temperature {
    Celsius(i32),
    Fahrenheit(i32),
}

fn main() {
    let temperature = Temperature::Celsius(35);
    match temperature {
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        Temperature::Celsius(t) =&gt; println!(&quot;{}C is below 30 Celsius&quot;, t),
        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
    }
}</code></pre></pre>
<h3 id="需要搞乱原始汇编嘛-有一个宏"><a class="header" href="#需要搞乱原始汇编嘛-有一个宏">需要搞乱原始汇编嘛? 有一个宏!</a></h3>
<p>core asm 提供了一个闳, 可以让你在 Rust 中编写内联汇编语句,
这在折腾一些花哨的事情时很有帮助,
比如直接拦截 CPU 的堆栈,
或是想要实现高级优化;</p>
<p>这是一个示例,我们使用内联汇编通过简单的将堆栈指针移动到用来欺骗处理器的堆栈来执行我们的函数!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::arch::asm;

const MAX_DEPTH: isize = 48;
const STACK_SIZE: usize = 1024 * 1024 * 2;

#[derive(Debug, Default)]
#[repr(C)]
struct StackContext {
    rsp: u64,
}

fn nyan() -&gt; ! {
    println!(&quot;nyan nyan nyan&quot;);
    loop {}
}

pub fn move_to_nyan() {
    let mut ctx = StackContext::default();
    let mut stack = vec![0u8; MAX as usize];
    unsafe {
        let stack_bottom = stack.as_mut_ptr().offset(MAX_DEPTH);
        let aligned = (stack_bottom as usize &amp; !15) as *mut u8;
        std::ptr::write(aligned.offset(-16) as *mut u64, nyan as u64);
        ctx.rsp = aligned.offset(-16) as u64;
        switch_stack_to_fn(&amp;mut ctx);
    }
}

unsafe fn switch_stack_to_fn(new: *const StackContext) {
    asm!(
        &quot;mov rsp, [{0} + 0x00]&quot;,
        &quot;ret&quot;,
        in(reg) new,
    )
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>所以说, 无法嵌入内联 汇编代码 的语言, 都不算系统语言?</p>
<p>等等, Python 好象也可以哪...
)</p>
<h3 id="使用-criterion-对代码及其吞吐量进行基准测试"><a class="header" href="#使用-criterion-对代码及其吞吐量进行基准测试">使用 Criterion 对代码及其吞吐量进行基准测试</a></h3>
<p>用来对 Rust 代码进行基准测试的 Criterion 是一项了不起的工程作品;
能帮助你使用图形/回归分析和其它奇怪的工具来访问令人敬畏的基准测试功能;
甚至可以用来衡量函数的不同维度,例如时间和吞吐量;
又比如, 我们可以看到在不同的直方图中,使用标准库的迭代器方法构造/获取和收集原始字节的速度有多快;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter;

use criterion::BenchmarkId;
use criterion::Criterion;
use criterion::Throughput;
use criterion::{criterion_group, criterion_main};

fn from_elem(c: &amp;mut Criterion) {
    static KB: usize = 1024;

    let mut group = c.benchmark_group(&quot;from_elem&quot;);
    for size in [KB, 2 * KB, 4 * KB, 8 * KB, 16 * KB].iter() {
        group.throughput(Throughput::Bytes(*size as u64));
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &amp;size| {
            b.iter(|| iter::repeat(0u8).take(size).collect::&lt;Vec&lt;_&gt;&gt;());
        });
    }
    group.finish();
}

criterion_group!(benches, from_elem);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<p>将以下条目追加到项目的 Cargo,toml 文件中,
就可以用 cargo bench 运行了:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.3&quot;

[[bench]]
name = &quot;BENCH_NAME&quot;
harness = false
</code></pre>
<p>criterion 不仅可以向你展示非常棒的图表和描述性信息,
而且,还能记住基准测试运行的先前结果,
告诉你性能回归状态;
在这种情况中,我在运行基准测试的同时, 还能用计算机作很多其它事儿,
所以, 也能自然的通报从上次测量后退化了多少;
总之,非常的COOL!</p>
<pre><code>    Found 11 outliers among 100 measurements (11.00%)
      2 (2.00%) low mild
      4 (4.00%) high mild
      5 (5.00%) high severe
    from_elem/8192          time:   [79.816 ns 79.866 ns 79.913 ns]
                            thrpt:  [95.471 GiB/s 95.528 GiB/s 95.587 GiB/s]
                     change:
                            time:   [+7.3168% +7.9223% +8.4362%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-7.7799% -7.3407% -6.8180%]
                            Performance has regressed.
    Found 3 outliers among 100 measurements (3.00%)
      2 (2.00%) high mild
      1 (1.00%) high severe
    from_elem/16384         time:   [107.22 ns 107.28 ns 107.34 ns]
                            thrpt:  [142.15 GiB/s 142.23 GiB/s 142.31 GiB/s]
                     change:
                            time:   [+3.1408% +3.4311% +3.7094%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-3.5767% -3.3173% -3.0451%]
                            Performance has regressed.
</code></pre>
<h3 id="通过阅读标准库来理解关键概念"><a class="header" href="#通过阅读标准库来理解关键概念">通过阅读标准库来理解关键概念!</a></h3>
<p>我喜欢徜徉在标准库中,尤其是 std::rc, std::iter, and std::collections;
以下是我自己从中学习到的一些很赞的技巧:</p>
<ul>
<li>vec 是如何切实实现的</li>
<li>通过 std::cell 和 std::rc 中的不同方法, 实现内部可变性的方式</li>
<li>如何在 std::sync 中实现通道</li>
<li>std::sync::Arc 的魔力</li>
<li>了解 Rust 作者对开发对应库时,如何作出设计决策的详尽解释</li>
</ul>
<p>有希望这篇文章能为进入 Rust 并遇到一些障碍的人们提供可用信息;
期待更多 Rust 内容能推出,
尤其是关键更高级主题的...</p>
<h3 id="shoutout"><a class="header" href="#shoutout">Shoutout</a></h3>
<p>感谢 Offchain Labs 同事 Rachel 和 Lee Bousfield 对这门语言的广泛了解;
他们的一些技巧启发了这篇文章;</p>
<h2 id="refer-30"><a class="header" href="#refer-30">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/">Rust Bug Minimization Patterns - The {pnk}f(eli)x Blog</a></li>
<li><a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></li>
<li><a href="https://github.com/sger/RustBooks#advanced-books">sger/RustBooks: List of Rust books</a>
<ul>
<li><a href="https://veykril.github.io/tlborm/decl-macros/macros2.html">Macros 2.0 - The Little Book of Rust Macros</a></li>
<li>...</li>
</ul>
</li>
</ul>
<h2 id="logging-21"><a class="header" href="#logging-21">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230120 ZQ init.</li>
</ul>
<pre><code>          _~-|-~_
      \) /  o -  \ (/
        '_   ⏡   _'
        &gt; '--~--' |

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="btm"><a class="header" href="#btm">btm</a></h1>
<p><a href="https://crates.io/crates/bottom">bottom - crates.io: Rust Package Registry</a></p>
<h2 id="backgroung-8"><a class="header" href="#backgroung-8">backgroung</a></h2>
<p>作为一名工程师, 总是得时刻关注系统状况的...</p>
<h2 id="goal-25"><a class="header" href="#goal-25">goal</a></h2>
<p>用好用对好工具</p>
<h2 id="trace-23"><a class="header" href="#trace-23">trace</a></h2>
<h3 id="layout"><a class="header" href="#layout">layout</a></h3>
<blockquote>
<p>没想到这么简单...</p>
</blockquote>
<p>如果在 linux 中, 那么配置: 
<code>~/.config/bottom/bottom.toml</code></p>
<p>如果追加声明:</p>
<pre><code class="language-toml">[[row]]
  [[row.child]]
  type=&quot;cpu&quot;
[[row]]
    ratio=3
    [[row.child]]
      ratio=4
      type=&quot;proc&quot;
    [[row.child]]
      ratio=3
      [[row.child.child]]
        ratio=2
        type=&quot;mem&quot;
      [[row.child.child]]
        ratio=2
        type=&quot;net&quot;
      [[row.child.child]]
        ratio=1
        type=&quot;disk&quot;
</code></pre>
<p>保存后, 再次调用 <code>btm</code> 则是这样的排版:</p>
<p><img src="https://ipic.zoomquiet.top/2023-03-06-zshot%202023-03-06%2011.15.40.jpg" alt="btm" /></p>
<p>对应解释很简洁:</p>
<ul>
<li>第1行
<ul>
<li>第1子行</li>
<li>CPU 版块</li>
</ul>
</li>
<li>第2行
<ul>
<li>和第1行是 1:3 比例</li>
<li>第1列
<ul>
<li>和第2列/右列比例为 4:3</li>
<li>进程版块</li>
</ul>
</li>
<li>第2列
<ul>
<li>和第1列/左列比例为 3:4</li>
<li>第1行
<ul>
<li>和其它子行比例为 2:2:1</li>
<li>内存版块</li>
</ul>
</li>
<li>第2行
<ul>
<li>和其它子行比例为 2:2:1</li>
<li>网络版块</li>
</ul>
</li>
<li>第3行
<ul>
<li>和其它子行比例为 2:2:1</li>
<li>硬盘版块</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因为一般都是虚拟机, 温度什么的根本没有, 所以, 值得定制并优化位置, 以便第一时间关注到,
相比 <a href="https://nmon.sourceforge.net/pmwiki.php">nmon for Linux | Main / HomePage</a> 只能选择信息版块,无法定制具体排版来, btm 要自在的多;</p>
<h2 id="refer-31"><a class="header" href="#refer-31">refer.</a></h2>
<p><a href="https://clementtsang.github.io/bottom/nightly/#contribution">Home - bottom</a></p>
<ul>
<li><a href="https://clementtsang.github.io/bottom/nightly/usage/widgets/battery/">General Usage - bottom</a></li>
<li><a href="https://clementtsang.github.io/bottom/nightly/configuration/config-file/data-filtering/">Layout - bottom</a></li>
<li>...</li>
</ul>
<pre><code>        _~`&amp;-~_
    \/ /  - ◕  \ \/
      '_   ⎵   _'
      \ '--.--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧"><a class="header" href="#技巧">技巧</a></h1>
<blockquote>
<p>tips...重要也不重要</p>
</blockquote>
<h2 id="background-20"><a class="header" href="#background-20">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>刚刚开始感觉哪儿哪儿都要有技巧, 其实不一定...</p>
<h2 id="goal-26"><a class="header" href="#goal-26">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>将一头合格 Rustaceans 值得记忆的基本技巧,
收集到 42% 左右...</p>
<h2 id="trace-24"><a class="header" href="#trace-24">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>???</p>
<h2 id="refer-32"><a class="header" href="#refer-32">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://rust-lang.github.io/rfcs/introduction.html#when-you-need-to-follow-this-process">Introduction - The Rust RFC Book</a></p>
<ul>
<li><a href="https://evanhahn.com/the-lone-developer-problem/">The lone developer problem</a>
<ul>
<li>...小心<code>孤独开发者综合症</code>...</li>
</ul>
</li>
<li>...</li>
</ul>
<h3 id="gpts"><a class="header" href="#gpts">GPTs</a></h3>
<blockquote>
<p>通用任务</p>
</blockquote>
<ul>
<li>ChatGPT 相关
<ul>
<li>ChatGPT for StackOverflow (https://stackoverflow.gg/) 查看 ChatGPT 对 StackOverflow 上每个问题的回复，甚至是未回答的问题</li>
<li>ChatGPT Detector (https://huggingface.co/spaces/Hello-SimpleAI/chatgpt-detector-single) 判断文本是否是AI生成</li>
</ul>
</li>
<li>poe (https://quorablog.quora.com/Poe-1) quora出品的对话式AI工具</li>
<li>tweetmonk (https://tweetmonk.com/) AI帮你打理社交网络</li>
</ul>
<blockquote>
<p>开发任务</p>
</blockquote>
<ul>
<li>README 生成器 (https://readme.rustc.cloud/zh) 用AI生成完整的GitHub readme</li>
</ul>
<blockquote>
<p>设计任务</p>
</blockquote>
<ul>
<li>图像:
<ul>
<li>Galileo AI (https://www.usegalileo.ai/) 用AI设计生成UI设计</li>
<li>animeai (https://animeai.app/) AI生成漫画风格图片</li>
<li>autodraw (https://www.autodraw.com/) AI辅助绘画</li>
<li>latentlabs (https://www.latentlabs.art/) 根据文本生成 360 度全景图</li>
<li>playgroudai (https://playgroundai.com/) 获取AI绘图提示词，帮助你编辑图片</li>
<li>stockimg (https://stockimg.ai/) AI设计图标</li>
</ul>
</li>
<li>声音:
<ul>
<li>image-to-sound-fx (https://huggingface.co/spaces/fffiloni/image-to-sound-fx) 图片转换为相对应的声音内容</li>
<li>MetaVoice Studio (https://studio.themetavoice.xyz/) AI声音编辑平台</li>
</ul>
</li>
<li>视频:
<ul>
<li>invideo (https://invideo.io/ai/) 根据文本生成视频</li>
<li>murf (https://murf.ai/) AI生成真人演讲视频</li>
<li>tosummary (https://tosummary.com/) 利用AI提取书籍、YouTube视频摘要</li>
</ul>
</li>
</ul>
<blockquote>
<p>办公任务</p>
</blockquote>
<ul>
<li>文档:
<ul>
<li>周报生成器 (https://weeklyreport.avemaria.fun/zh) 简单描述工作内容，帮你生成完整周报</li>
<li>email-helper (https://email-helper.vercel.app/) AI帮你写邮件</li>
<li>campbell (https://review.gobudapest.io/) AI生成评语</li>
<li>penlope (https://penelopeai.com/) AI辅助markdown编辑器</li>
</ul>
</li>
<li>大纲:
<ul>
<li>bearly (https://bearly.ai/) AI帮助你阅读、创作，撰写，提高你的工作效率</li>
<li>humata (https://app.humata.ai/signin) 利用AI来分析论文内容</li>
</ul>
</li>
<li>docuchat (https://www.docuchat.io/) 上传文档，AI回答对应的问题</li>
</ul>
<h2 id="logging-22"><a class="header" href="#logging-22">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<pre><code>         _~~+∽~_
     \/ /  ← ◴  \ ()
       '_   ⏡   _'
       \ '--⌄--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="awesomers"><a class="header" href="#awesomers">Awesome.rs</a></h1>
<blockquote>
<p>Rust 世界中最锈的那批好东西</p>
</blockquote>
<h2 id="background-21"><a class="header" href="#background-21">background</a></h2>
<p>无论进入哪个技术栈, 都面临一个问题:</p>
<blockquote>
<p>如何象老手那样, 快速完成任务?</p>
</blockquote>
<h2 id="goal-27"><a class="header" href="#goal-27">goal</a></h2>
<ul>
<li>收集/整理/体验/积累/...</li>
<li>各种常见领域中, 最舒服的 crate  组合</li>
<li>...</li>
</ul>
<h2 id="refer-33"><a class="header" href="#refer-33">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://github.com/JohnBSmith/moss">Awesome Rank for rust-unofficial/awesome-rust</a></li>
<li><a href="https://github.com/rust-unofficial/awesome-rust">rust-unofficial/awesome-rust: A curated list of Rust code and resources.</a></li>
<li><a href="http://zsiciarz.github.io/24daysofrust/index.html">Introduction | 24 days of Rust</a></li>
<li><a href="https://wangchujiang.com/rust-cn-document-for-docker/rust-cookbook/intro.html">总览 - Rust Cookbook 中文版 - A Rust Cookbook</a></li>
<li>...</li>
</ul>
<h2 id="logging-23"><a class="header" href="#logging-23">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230301 ZQ init.</li>
</ul>
<pre><code>      _~`+∽~_
  \/ /  * ◴  \ ()
    '_   ⩌   _'
    / '--.--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handlebars"><a class="header" href="#handlebars">Handlebars</a></h1>
<blockquote>
<p>Minimal templating on steroids</p>
</blockquote>
<h2 id="background-22"><a class="header" href="#background-22">background</a></h2>
<p>想完成一个简单的终端动画 crate 时发现 (<a href="tip/./dev/cli_ferris_art.html">Ferris艺术</a>)</p>
<h2 id="goal-28"><a class="header" href="#goal-28">goal</a></h2>
<p>20% 最常用可支持 80% 场景用核心知识点</p>
<h2 id="notes"><a class="header" href="#notes">notes</a></h2>
<h2 id="refer-34"><a class="header" href="#refer-34">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://doc.rust-lang.org/std/fmt/index.html">std::fmt - Rust</a></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.format_args.html">format_args in std - Rust</a></li>
<li><a href="https://casualhacks.net/blog/2022-06-24/reinventing-rust-fmt/">Reinventing Rust formatting syntax</a></li>
<li>...</li>
</ul>
<p><a href="https://crates.io/crates/handlebars">handlebars - crates.io: Rust Package Registry</a></p>
<ul>
<li><a href="https://docs.rs/handlebars/4.3.6/handlebars/index.html">handlebars - Rust</a>
<ul>
<li><a href="https://github.com/sunng87/handlebars-rust#readme">sunng87/handlebars-rust: Rust templating with Handlebars</a></li>
<li><a href="https://handlebarsjs.com/">Handlebars</a></li>
<li><a href="https://handlebarsjs.com/zh/guide/">介绍 | Handlebars</a></li>
</ul>
</li>
<li><a href="https://crates.io/crates/tinytemplate">tinytemplate - crates.io: Rust Package Registry</a></li>
<li>...</li>
</ul>
<h2 id="logging-24"><a class="header" href="#logging-24">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230301 ZQ init.</li>
</ul>
<pre><code>      _~`+~~_
  \) /  &gt; *  \ (/
    '_   ♢   _'
    &gt; '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing-3"><a class="header" href="#tracing-3">tracing</a></h1>
<blockquote>
<p>一步到位日志工具?</p>
</blockquote>
<h2 id="background-23"><a class="header" href="#background-23">background</a></h2>
<p>无论哪种级别的开发,
一个日志工具是必要的,
否则,发生点儿什么事儿, 一点儿数据/配置/...的残影都没有那是真一点儿办法也没有...</p>
<h2 id="goal-29"><a class="header" href="#goal-29">goal</a></h2>
<ul>
<li>Rust 原生</li>
<li>成熟</li>
<li>支持多种格式/配置/定制/...</li>
<li>文档完备, 安装流畅, 没有急转弯....</li>
</ul>
<h2 id="trace-25"><a class="header" href="#trace-25">trace</a></h2>
<h3 id="install"><a class="header" href="#install">install</a></h3>
<p>Cargo.toml 中追加:</p>
<pre><code>[dependencies]
log = &quot;0.4&quot;
tracing = &quot;0.1&quot;
clia-tracing-config = &quot;0.2&quot;
</code></pre>
<blockquote>
<p>$ cargo check </p>
</blockquote>
<p>自动安装对应 crate</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() -&gt; Result&lt;()&gt;{

    let _guard = clia_tracing_config::build()
        .filter_level(&quot;debug&quot;)//fatal,error,warn,info,debug
        .with_ansi(true)
        .to_stdout(false)
        .directory(&quot;./log&quot;)
        .file_name(&quot;debug.log&quot;)
        .rolling(&quot;daily&quot;)
        .init();

/// ...

    Ok(())

}</code></pre></pre>
<p>在需要的场景中定义个 <code>_guard</code> 就完成了所有关键配置,
这是由 <code>clia-tracing-config</code> 实现的,</p>
<p>现在, 就可以在开发过程中使用</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>log::debug!(&quot;{}&quot;, foobar);
log::info!(&quot;{}&quot;, foobar);
log::warn!(&quot;{}&quot;, foobar);
log::error!(&quot;{}&quot;, foobar);
<span class="boring">}</span></code></pre></pre>
<p>进行日志输出, 而且每天自动活动, 但是, 有自动 link ,
可以使用 <code>tail -f </code> 一直追踪观察;</p>
<pre><code>项目/
    +- Cargo.toml
    +- README.md
    +- src/
    |   +- main.rs
    +- tests/
    |   +- cli.rs
    +- log/
    |   +- debug.log -&gt; debug.log.2023-02-25
    |   +- ...
    |   +- debug.log.2023-02-23
    |   `- debug.log.2023-02-25
    ...
</code></pre>
<h2 id="refer-35"><a class="header" href="#refer-35">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://awesomerank.github.io/lists/rust-unofficial/awesome-rust.html#cryptocurrencies">Awesome Rank for rust-unofficial/awesome-rust</a>
<ul>
<li><a href="https://github.com/rust-unofficial/awesome-rust">rust-unofficial/awesome-rust: A curated list of Rust code and resources.</a></li>
<li>先从社区知道 logging 模块的大约范畴</li>
</ul>
</li>
<li><a href="https://blog.logrocket.com/comparing-logging-tracing-rust/">Comparing logging and tracing in Rust - LogRocket Blog</a>
<ul>
<li><a href="https://privaterookie.github.io/posts/2020-02-03-log4rs-Rust-log%E5%BA%93.html">log4rs-Rust-log库 - 夜雨秋灯录</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10252834">在 Rust 中使用 log： log / slog / tracing - iT 邦幫忙</a></li>
<li>再从对比中定位目标</li>
</ul>
</li>
<li><a href="https://choosealicense.com/licenses/mit">tracing - crates.io: Rust Package Registry</a>
<ul>
<li><a href="https://course.rs/logs/tracing.html">使用 tracing 记录日志 - Rust语言圣经(Rust Course)</a></li>
<li><a href="https://crates.io/crates/clia-tracing-config">clia-tracing-config - crates.io: Rust Package Registry</a></li>
</ul>
</li>
<li>...</li>
</ul>
<pre><code>           _~∽~^~_
       \) /  ◶ →  \ (/
         '_   ⏡   _'
         &gt; '--#--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing-4"><a class="header" href="#tracing-4">tracing</a></h1>
<blockquote>
<p>一步到位日志工具?</p>
</blockquote>
<h2 id="background-24"><a class="header" href="#background-24">background</a></h2>
<p>一个 5M 左右的 toml 用 rust 加载时竟然比 Python 还要慢</p>
<h2 id="goal-30"><a class="header" href="#goal-30">goal</a></h2>
<ul>
<li>Rust 原生</li>
<li>合理加速</li>
<li>通用...</li>
</ul>
<h2 id="trace-26"><a class="header" href="#trace-26">trace</a></h2>
<blockquote>
<p>Q: </p>
</blockquote>
<p>rust 中 File::open() 打开一个大的文本文件时很慢,
有什么加速的办法?</p>
<blockquote>
<p>A:</p>
</blockquote>
<p>在 Rust 中，File::open() 用于打开文件并返回 std::fs::File 类型的对象。如果打开的文件非常大，打开过程可能会很慢，因为系统需要从硬盘中读取大量的数据。</p>
<p>以下是一些加速打开大型文本文件的方法：</p>
<ol>
<li>使用 BufReader
Rust 中的 BufReader 可以将文件读取到内存缓冲区中，并按需将其读取到程序中。使用 BufReader 可以加快读取速度。</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">use std::io::{BufReader, BufRead};
use std::fs::File;

fn main() {
    let file = File::open(&quot;file.txt&quot;).unwrap();
    let reader = BufReader::new(file);

    for line in reader.lines() {
        println!(&quot;{}&quot;, line.unwrap());
    }
}
</code></pre></pre>
<ol>
<li>使用异步 I/O
Rust 中的异步 I/O 可以使程序在读取文件时不会被阻塞。异步 I/O 可以使用 tokio 库实现。</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::fs::File;
use tokio::io::{self, AsyncBufReadExt};

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let file = File::open(&quot;file.txt&quot;).await?;
    let reader = io::BufReader::new(file);

    let mut lines = reader.lines();

    while let Some(line) = lines.next_line().await? {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre></pre>
<ol>
<li>使用多线程
使用多线程可以加速文件的读取和处理，特别是在处理大量数据时。可以使用 Rust 中的 rayon 库实现并行处理。</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;
use std::io::{BufRead, BufReader};
use rayon::prelude::*;

fn main() {
    let file = File::open(&quot;file.txt&quot;).unwrap();
    let reader = BufReader::new(file);
    let lines = reader.lines().collect::&lt;Result&lt;Vec&lt;String&gt;, _&gt;&gt;().unwrap();

    let result = lines.par_iter().map(|line| {
        // 处理每一行
        line.to_uppercase()
    }).collect::&lt;Vec&lt;String&gt;&gt;();

    // 处理结果
    println!(&quot;{:?}&quot;, result);
}
</code></pre></pre>
<h2 id="refer-36"><a class="header" href="#refer-36">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/io/struct.BufReader.html#examples">BufReader in std::io - Rust</a></li>
<li><a href="https://crates.io/crates/tokio">tokio - crates.io: Rust Package Registry</a></li>
<li><a href="https://crates.io/crates/rayon">rayon - crates.io: Rust Package Registry</a></li>
<li>...</li>
</ul>
<pre><code>        _~^~-~_
    () /  = →  \ ()
      '_   𝟂   _'
      / '--+--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bmp最小bug模式"><a class="header" href="#bmp最小bug模式">BMP:最小bug模式</a></h1>
<p>原文: <a href="http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/">Rust Bug Minimization Patterns - The {pnk}f(eli)x Blog</a></p>
<blockquote>
<p>Update 19 November 2019: fixed miscellaneous typos and a bug in the invariance example pointed out by readers both privately and on reddit thread. I also added a section near the beginning to draw attention to techniques that are somewhat Rust-specific and may not be broadly known.</p>
</blockquote>
<blockquote>
<p>快译:</p>
</blockquote>
<p>Hey there again!</p>
<p>I have been pretty busy with Rust compiler tasks, so no there has not been a blog post for a few months. But now, here we are!</p>
<p>While I was working some particularly nasty bugs recently, I put a lot of effort into bug minimization: the process of taking a large test case and finding ways to remove code from the test while preserving the test’s ability to expose the same bug.</p>
<p>As I worked, I realized that I was following a somewhat mechanical process. I was using regular patterns for code transformation. At some point, I said “you know, I’m not sure if everyone is aware of these patterns. I only remember some of them while I am in the middle of a bug minimization session.”</p>
<p>Since the Rust compiler team always wants to help newcomers learn ways they can contribute to the project, I realized this could be the ideal subject for a blog post.</p>
<p>And, to try to keep things concrete, I’m going to try to drive the presentation by showing an actual bug being minimized. (Or rather, I’m going to recreate the minimization that I already did. So if it seems like I am rather conveniently picking transformations that always seem to work: You’re right! I’m cheating and not telling you about all the false paths I went down during my first minimization odyssey on this bug.</p>
<h2 id="the-rust-specifics"><a class="header" href="#the-rust-specifics">The Rust specifics</a></h2>
<p>Oh, and one other thing: A lot of the ideas here are applicable to many languages, and so its possible readers have already heard about them or discovered them independently.</p>
<p>However, a few of the techniques leverage features that are not universal to languages outside of Rust.</p>
<p>Specifically:</p>
<ul>
<li>“cfgmenting” makes use of Rust’s attribute system to remove items in a lightway fashion.</li>
<li>“loopification” makes use of the fact that the Rust allows the divergent expression loop { } to be assigned any type.</li>
<li>“loopification” via pretty-printer leverages the compiler’s (unstable) ability to inject loop { } for all function bodies.</li>
<li>Bisecting the module tree makes use of Rust’s support for a mix of inline and out-of-line modules to allow one to quickly swap code in and out.</li>
</ul>
<p>So, without further ado: here is the odyssey of my minimization of rust-lang/rust#65774</p>
<hr />
<h2 id="philosophical-meandering"><a class="header" href="#philosophical-meandering">Philosophical meandering</a></h2>
<h3 id="what-does-minimal-mean-anyway"><a class="header" href="#what-does-minimal-mean-anyway">What does “minimal” mean anyway?</a></h3>
<p>The objective of a “minimal” test case could mean minimize lines of code; or the number of characters. It is also good to minimize the number of source files: one file, cut-and-pastable into play.rust-lang.org, is especially desirable.</p>
<blockquote>
<p>One could even argue that the number of nodes in the abstract syntax tree is a better metric to use than text-oriented metrics when minimizing.</p>
</blockquote>
<p>Minimizing the source test in this way can yield a good candidate for a regression test to add to the compiler test suite when the bug is (hopefully) eventually fixed.</p>
<p>But those syntactic metrics of minimality overlook something: My own end goal when minimizing the code for a bug is a better understanding of the bug: a better understanding for myself, and for other developers who are reading the test case.</p>
<blockquote>
<p>I am writing this post from the viewpoint of a rustc developer. So I may have a slightly skewed view on what is useful or minimal.And for such understanding, there are other metrics to keep in mind:</p>
</blockquote>
<ul>
<li>Minimize the amount of time the compiler runs before it hits the bug.</li>
</ul>
<p>Minimizing the compiler’s execution time before failure serves two purposes:</p>
<ol>
<li>It makes every future run of this test faster, which can accelerate your pace of minimization.</li>
<li>When the rustc developers themselves examine the behavior of the compiler on the test, they will be grateful to have a shorter execution trace of the compiler to analyze.</li>
</ol>
<p>(Such time reduction often occurs anyway when you remove lines of code and/or dependencies; I just want to point out that it has value in its own right.)</p>
<blockquote>
<p>As a concrete example of how reducing imports may help expose a bug’s root cause: some people will have a bug that occurs with some combination of #[derive(Debug)] and a call to format! or write, and the test showing the problem may be only a few lines long. But it hides a lot of complexity behind those uses of derive, macros, and std::io trait machinery; a longer test that defines its own trait, a local impl of that trait, and a small function illustrating the same bug, may make the bug more immediately apparent to a rustc developer.</p>
</blockquote>
<ul>
<li>Minimize dependencies: reduce the number of language features in use and the number of imports your test uses from other crates (including the std library!).</li>
</ul>
<p>This can help expose the essential cause of the bug, potentially making it immediately apparent what is occurring.</p>
<ul>
<li>Minimize your jumping around in the source code.</li>
</ul>
<p>If you can fit all the code needed to recreate the bug onto your monitor screen at once, by any means necessary, that is a serious accomplishment. Less time spent scrolling through a file or switching editor windows is more time you can spend thinking about the bug itself.</p>
<p>To be clear: Often a minimum amount of code needed for understanding does correlate with a minimum amount of code needed for reproduction. (This explains why using lines-of-code or the size of the syntax tree as a metric can be useful when reporting a bug.)</p>
<p>The over-arching goal in minification is to remove all distractions: to reduce the problematic input (in this case, Rust source code) to its essence: a minimal amount necessary to understand the problem.</p>
<h3 id="why-not-build-it-up-from-scratch"><a class="header" href="#why-not-build-it-up-from-scratch">Why not build it up from scratch?</a></h3>
<p>Its worth pointing out that at some point, maybe even at the outset, you may have a sufficiently rich understanding of the bug that you can go straight to building up a minimal example from scratch. And that’s great , go for it!</p>
<p>However, this post is dedicated to the problem of what you can do when you haven’t hit that level of understanding. When you’re looking at a set of files that make up over 90,000 lines of code, you want a set of semi-mechanical techniques to take that test input and strip it down to its essence.</p>
<p>To be honest, the most effective methodology is going to use a blend of build-up and tear-down. As you are tearing down the 90,000 lines of code, there should be a voice in the back of your head asking “can we now try what we’ve learned to try to build up a minimal example?”</p>
<hr />
<h2 id="assumptions-and-conventions"><a class="header" href="#assumptions-and-conventions">Assumptions and Conventions</a></h2>
<blockquote>
<p>Some of the techniques may also be applicable to cases where the compiler is accepting code that it should be rejecting; but I am little wary of advertising these tools for use in that context, which is why you’re reading this in the margin and not the main text.</p>
</blockquote>
<p>The tests I am talking about minimizing in this post are cases where the compiler itself fails in some way: an ICE, a link failure, or rejecting code that it should be accepting. Bugs that are witnessed by actually running the generated code are, for the most part, not covered by the patterns here. In particular: many of the patterns presented here rely on making semantic changes to the input: changing values, or replacing complex expressions with something trivial like loop { }.</p>
<p>I named each transformation, usually with absurd made-up words like “unusedification”. They are all in explicit quotation marks to try to make it clear that I am speaking nonsense, deliberately.</p>
<blockquote>
<p>I had originally planned to structure this post so that all transformations for a given theme would be present together, so that you’d see all the transformations for that theme at once. But as I wrote, it became clear over the course of actually doing a reduction, then we often bounce around between transformations, and it usually does not end up being nicely grouped with all transformations for one theme colocated in time. So rather than using that hierarchical presentation, I am instead just going to try to mention the grouping by marking each as transformation being part of a “theme”.Several of the transformations serve similar goals, like “delete the unnecessary”. I have attempted to categorize the different tranformations according to what purpose they serve in the minimization process. Over the course of documenting these transformations, I identified the following themes:</p>
</blockquote>
<ul>
<li>Simplify Workflow: Make your own life easier.
<ul>
<li>Enable Incremental Steps</li>
</ul>
</li>
<li>Delete the Unnecessary: Remove items not related to bug!</li>
<li>Identify the Unnecessary: Eliminate accidental necessity.</li>
<li>Trivialize Content: Turn complex expressions to trivial ones.</li>
<li>Eliminate Coupling: Break links between items.</li>
</ul>
<h2 id="notes-on-notation"><a class="header" href="#notes-on-notation">Notes on Notation</a></h2>
<p>In this post, I follow typical notation by using ... as a placeholder for (possibly relevant) code that will be kept approximately the same (modulo mechanical updates like alpha-renaming) by a transformation. However, I also use the non-standard notation of ---- for irrelevant code that removed via a transformation. This is meant to draw attention to the distinct kinds of code, so that you can more easily tell which code is being removed by a particular transformation.</p>
<p>Sometimes I will show an explicit regexp that I am feeding to a tool to do the transformation, but usually I will stick to informal patterns with the aforementioned ... and ---- placeholders.</p>
<p>When a given item or expression can appear within the context of a middle of a sequence (e.g. consider { ... THING ... }), I often use the standard shorthand of just writing { THING ... } or { ... THING }, to simplify the textual presentation and focus attention on the transformation itself.</p>
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="record-your-steps"><a class="header" href="#record-your-steps">Record your steps</a></h2>
<p>Before you do any reduction, move the test case into its own local git repository (or whatever versioning tool you prefer: SVN, RCS, etc). Being able to backtrack through previous reduction steps is an incredibly important option when doing this kind of of work.</p>
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="continuously-test-the-test"><a class="header" href="#continuously-test-the-test">Continuously test the test.</a></h2>
<p>Finally: A crucial part of reduction is to continuously double-check that the bug still reproduces after every reduction step. I’ll show the command line invocation on occasion, but not every command line build invocation (the output is usually the same on every run, so it would just clog up the flow of the presentation here). But even though I don’t show every invocation, you can believe that I was doing the runs. (And in the cases where I tried to skip doing a run, I usually regretted it and had to backtrace my steps to the state before an attempted reduction.)</p>
<p>Make it easy to do your runs. Use your IDE. I use emacs, so I make a M-x compile invocation that runs the compiler with the right arguments, and then you can hit g in the <em>compilation</em> buffer to re-run the compile.</p>
<hr />
<h2 id="the-test-case"><a class="header" href="#the-test-case">The test case</a></h2>
<p>As I mentioned at the start: The presentation here will be driven by referencing a concrete test case that I reduced recently: we have been given a crate graph, and we can observe a bug when we build as follows:</p>
<pre><code>
% ( cd tock/boards/arty-e21/ &amp;&amp; \
    RUSTFLAGS=&quot;-C link-arg=-Tlayout.ld&quot; \
    cargo build --target riscv32imac-unknown-none-elf )
   Compiling tock-registers v0.4.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-register-interface)
   Compiling tock-cells v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-cells)
   Compiling tock_rt0 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-rt0)
   Compiling enum_primitive v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/enum_primitive)
   Compiling kernel v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/kernel)
   Compiling riscv-csr v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/riscv-csr)
   Compiling rv32i v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/arch/rv32i)
   Compiling capsules v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/capsules)
   Compiling sifive v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/sifive)
   Compiling arty_e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/arty_e21)
   Compiling components v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/boards/components)
   Compiling arty-e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/boards/arty-e21)
error: internal compiler error: src/librustc/traits/codegen/mod.rs:127: Encountered errors `[FulfillmentError(Obligation(predicate=Binder(TraitPredicate(&lt;() as core::fmt::Display&gt;)), depth=1),Unimplemented)]` resolving bounds after type-checking
</code></pre>
<p>In reality the command line was a little more complicated:</p>
<pre><code class="language-shell">
% ( cd tock/boards/arty-e21/ &amp;&amp; \
    RUSTFLAGS=&quot;-C link-arg=-Tlayout.ld -C linker=rust-lld -C linker-flavor=ld.lld -C relocation-model=dynamic-no-pic -C link-arg=-zmax-page-size=512&quot; \
    cargo build --target riscv32imac-unknown-none-elf   )
...
error: internal compiler error: src/librustc/traits/codegen/mod.rs:127: Encountered errors `[FulfillmentError(Obligation(predicate=Binder(TraitPredicate(&lt;() as core::fmt::Display&gt;)), depth=1),Unimplemented)]` resolving bounds after type-checking
</code></pre>
<blockquote>
<p>An eagle-eyed reader might look at that ICE message and immediately consider grepping the source code, such as uses of the trait bound core::fmt::Display. A fine idea, but intuitive jumping to an answer is not what I’m focusing on here.</p>
</blockquote>
<p>but for the purposes of the experiments presented in this blog post I will use the simplified invocation. (The difference only matters once we hit cases where the bug goes away.)</p>
<p>Remember that 90,000 lines of code number that I mentioned a few paragraphs ago? It didn’t come out of nowhere:</p>
<pre><code class="language-shell">% find tock/ -name *.rs | xargs wc
...
   91958  317229 3150451 total

</code></pre>
<p>So this is an excellent example of an input that we really want to reduce down to something smaller.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="tactic-reduce-the-driving-code-first"><a class="header" href="#tactic-reduce-the-driving-code-first">Tactic: Reduce the driving code first</a></h2>
<p>We have many input files, and they make up a crate graph with at least 13 crates in it.</p>
<p>We know from our command line invocation that it is the build of boards/arty-e21 that is exposing the ICE. It would be good to remove unnecessary crates from the crate graph for boards/arty-e21. But to do that most effectively, we need to first discard as many imports as possible from boards/arty-e21, and then work our way backwards through the dependency chain.</p>
<p>So, will start by reducing the boards/arty-e21 crate to the minimum necessary to reproduce the bug.</p>
<p>This single crate is a much easier thing to work with:</p>
<pre><code class="language-shell">% find tock/boards/arty-e21/ -name '*.rs' | xargs wc
       4       6     124 tock/boards/arty-e21//build.rs
      27      68     565 tock/boards/arty-e21//src/timer_test.rs
      40     101     959 tock/boards/arty-e21//src/io.rs
     279     667    9135 tock/boards/arty-e21//src/main.rs
     350     842   10783 total

</code></pre>
<p>However, we still want to reduce it as much as we can: Every import we can remove from arty-e21 represents swaths of code that we might be able to remove in the rest of the crate graph.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h2 id="technique-mod-inlining"><a class="header" href="#technique-mod-inlining">Technique: “mod-inlining”</a></h2>
<p>This technique may surprise some: I like to reduce the number of files involved early in the game, if I can. An easy way to do this is to replace the out-of-line mod foo; item with its inline counterpart: mod foo { ... }. Here the out-of-line module file content has been cut-and-pasted into an inline mod item.</p>
<p>Strictly speaking, moving from mod foo; to mod foo { ... }does not reduce the input: You still have all the same content that you started with, the compiler has to do the same amount of work, et cetera.</p>
<p>However, I still prefer to do it, because I find that it helps with later reduction steps if I can do my transformations on a single file.</p>
<p>There two techniques I use for “mod-inlining”:</p>
<ol>
<li>Manually cut-and-paste: take each instance of mod foo; in the root file, and find that module’s contents. Then replace the ; with { and }, and finally paste the contents in between the curly brackets you just added. You don’t even have to re-indent it if you don’t want to.</li>
</ol>
<blockquote>
<p>Its not like this is Python!</p>
</blockquote>
<p>For a small module tree, such as we find in boards/arty-e21, manually cut-and-pasting is entirely reasonable. But if you have a large module tree, with many directories and files, it can become tedious and error-prone.</p>
<ol start="2">
<li>Alternative: use rustc to expand the module-tree. You can add --verbose to the cargo build invocation to see the actual rustc command line invocation cargo is using, and then you can add -Z unstable-options --pretty=expanded to that rustc invocation, piping the output to a new rust source</li>
</ol>
<blockquote>
<p>Warning: this will not only expand the module tree: it will also expand all the macro invocations, including #[derive] attributes. This can be a bit overwhelming. (I am continually tempted to add a new unstable --pretty variant that just expands the module tree but does not expand the macros otherwise.)</p>
</blockquote>
<p>I will show a concrete example of using rustc in this way later in the blog post. But for now I will just manually cut-and-paste the contents of boards/arty-e21/src/timer_test.rs and boards/arty-e21/src/io.rs into main.rs</p>
<p>After doing the inline, make sure the bug reproduces.</p>
<p>It is up to you whether you want to delete the out-of-line module files. Today, Rust does not treat their presence as some sort of conflict with the inline definition. You will see later in the post cases where keeping them around on the file-system can be useful. But for the case of boards/arty-e21, I will go ahead and delete them.</p>
<blockquote>
<p>Checking for unused out-of-line module files might be a nice lint for someone to add to rustc.</p>
</blockquote>
<pre><code class="language-shell">% find tock/boards/arty-e21/ -name *.rs | xargs wc
       4       6     124 tock/boards/arty-e21//build.rs
     348     840   10665 tock/boards/arty-e21//src/main.rs
     352     846   10789 total

</code></pre>
<p>As expected, this didn’t reduce the line count. But it did make it so we can work with a single file at the leaf. That simplifies my own workflow.</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="tactic-decommentification"><a class="header" href="#tactic-decommentification">Tactic: “Decommentification”</a></h2>
<p>This may be obvious, but it is a step that I often forget to do at the outset of test reduction, even though it is easy and pays off handsomely.</p>
<p>Comments in code are typically there to explain or justify some detail of the implementation. When diagnosing compiler bugs, the purpose of the original code is usually not relevant. You are better off increasing the number of lines of actual code that you can fit on your screen at once.</p>
<p>In short, the transformation looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>^        //...$

<span class="boring">}</span></code></pre></pre>
<p>to <empty-string></p>
<p>In this case, I have used ^ and $ as markers for the beginning and end of lines (just like in regexps).</p>
<p>Or, as an Emacs M-x query-replace-regexp input: ^ <em>//.</em>^J* (and empty string as replacement text).</p>
<blockquote>
<p>The ^J there is a carriage-return inserted via M-x quoted-insert (aka C-q) in Emacs.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Why I use M-x query-replace-regexp: it previews the matches, I verify a few by eye, and then hit ! to do all the remaining replacements.</p>
</blockquote>
</blockquote>
<p>Another related transformation: get rid of the other blank lines that are not preceded by comments. I leave that regexp as an exercise for the reader.</p>
<p>In the case of boards/arty-e21, this got rid of 53 lines of comments (and blank lines succeeding them):</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
     295     575    8551 tock/boards/arty-e21/src/main.rs

</code></pre>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h2 id="tactic-body-loopification"><a class="header" href="#tactic-body-loopification">Tactic: “Body Loopification”</a></h2>
<blockquote>
<p>see also: “none-defaulting”“Loopification” </p>
</blockquote>
<p>removes the body of a given function or method item, replacing it with loop { }.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(...) -&gt; ReturnType { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(...) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>You might choose to use alternatives like unimplemented!(). I personally like loop { } because its something you almost never see in other people’s code, so its easy to search for and be pretty certain that it was introduced as part of reduction. Also loop { } relies on less machinery from the core library than unimplemented! does.</p>
</blockquote>
<p>The use of loop { } is deliberate: since loop { } is known by the compiler to diverge, it can be assigned any type at all. So this transformation can be performed blindly.</p>
<ul>
<li>Note that this does not work for const fn; the compiler currently rejects const fn foo() { loop { } } as invaild syntax.</li>
<li>Also, it generally will not work for impl Trait in return position: the compiler needs a concrete type to assign to the impl Trait, and loop { } will not suffice for that unless you ascribed it a non-! type in some manner.</li>
</ul>
<p>When it comes to replacing a function body with loop { }, you may be able to get help from your IDE. In my own case, I have often used Emacs M-x kill-sexp to delete the { ---- } block in fn foo { ---- }</p>
<blockquote>
<p>More specifically, I have used Emacs to define a keyboard macro (via C-x () that: 1. searches for the next occurrence of fn, 2. searches forward from there for the first {, which often (but not always) corresponds to the start of the function’s body, 3. runs M-x kill-sexp to delete the { ---- } and 4. types in { loop { } }, replacing the method body. This is incredibly satisfying to watch in action.</p>
</blockquote>
<p>If you want to take a risk, you can ask rustc to do the replacement of fn bodies with loop { } for you as part of pretty-printing via the -Z unpretty=everybody_loops flag. I’ll speak more on that later.</p>
<p>Once the body has been removed, you can optionally replace all of the formal parameters with _:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: A, b: B, ...) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: A, _: B, ...) -&gt; ReturnType { loop { } }
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>These explicit marks can be useful as hints for future reduction steps; see “genertrification”)</p>
</blockquote>
<p>This is essentially a special case of “unusedification”; we do not delete the parameters outright yet (see “param-elimination” for that), but we mark them as completely useless by writing them as _: ParamType.</p>
<p>In the case of board/argy-e21/main.rs, there was one const fn, and you cannot “loopify” that. For the other fn’s, I was able to replace all but the last fn body with loop { }. (Replacing the last one made the bug go away.)</p>
<ul>
<li>In practice, the ICE diangostic often gives me some hint about which fn is the problem, and therefore I can blindly replace the other fn bodies with loop { }.</li>
<li>But even without such a hint, once can often bisect over the set of fn’s to try to identify a maximal subset that can have their bodies replaced with loop { }. We will talk more about how to do such bisection later.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>% wc tock/boards/arty-e21/src/main.rs
     262     523    7584 tock/boards/arty-e21/src/main.rs

<span class="boring">}</span></code></pre></pre>
<p>(Okay, only removing 33 lines of code might not be very impressive. The technique will pay off more as we move further along.)</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h2 id="tactic-expr-elimination"><a class="header" href="#tactic-expr-elimination">Tactic: “Expr-elimination”</a></h2>
<p>Even if you were not able to replace a whole fn body with loop { }, you can usually simplify the fn bodies that remain now.</p>
<blockquote>
<p>themes: Trivialize Content, Identify the Unnecessary</p>
</blockquote>
<h3 id="technique-suffix-bisection"><a class="header" href="#technique-suffix-bisection">Technique: Suffix-bisection</a></h3>
<p>In this case, I recommend a form of bisection where you first comment out the bottom half of the original fn-body, and see if the problem reproduces.</p>
<ul>
<li>Why comment out the latter half? Well, if you comment out the top half, you’re almost certainly going to comment out let-bindings that the bottom half relies on. The top half very rarely relies on items in the bottom half.</li>
<li>If the fn in question has a return type, then you can usually use a loop { } as a tail-expression at the end of the fn-body to satisfy the return-type; a natural variant of “loopification”.</li>
</ul>
<p>If it does reproduce without the bottom half, then you can delete that half, and recursively process the top half.</p>
<p>If it doesn’t reproduce, then the bug relies on something in the bottom half. If you’re lucky, it only relies on stuff in the latter half, and you can try deleting the top half now. But even if you’re “unlucky” and the bottom half relies on stuff in the top half, you leave the top half in place (at least for now) and recursively process the bottom half, narrowing the code until you can identify a single statement whose presence or absence is the line between triggering the ICE or not.</p>
<p>If the fn is too large for fit on one screen, then I use M-x forward-sexp to identify the start and end of the fn-body. Then I jump to a line in the middle, and search around for the start of a statment in the body, and then comment out everything from that statement forward in /* ... */</p>
<p>In the case of boards/arty-e21/src/main.rs, this meant commenting out from line 191 through 263.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
    let gpio_pins = static_init!(
    ...

    board_kernel.kernel_loop(&amp;artye21, chip, None, &amp;main_loop_cap);
*/

<span class="boring">}</span></code></pre></pre>
<p>And, “darn”: It didn’t work. The bug disappeared. But: This is okay! We still have learned something: Something in the latter half is causing the bug. So bisect that latter half (again, favoring commenting out second halves).</p>
<p>Eventually, by recursively processing the suffix statements, we identify that the bug does not reproduce with this code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    ...
/*
    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;_sapps as *const u8,
        &amp;mut APP_MEMORY,
        &amp;mut PROCESSES,
        FAULT_RESPONSE,
        &amp;process_mgmt_cap,
    );

    board_kernel.kernel_loop(&amp;artye21, chip, None, &amp;main_loop_cap);
*/
}

<span class="boring">}</span></code></pre></pre>
<p>but does reproduce with this code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    ...
    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;_sapps as *const u8,
        &amp;mut APP_MEMORY,
        &amp;mut PROCESSES,
        FAULT_RESPONSE,
        &amp;process_mgmt_cap,
    );

/*
    board_kernel.kernel_loop(&amp;artye21, chip, None, &amp;main_loop_cap);
*/
}

<span class="boring">}</span></code></pre></pre>
<p>So, now we have identified a function call to load_processes that seems to be intimately related to the bug.</p>
<p>Unfortunately, load_processes is an item defined in an external crate. (We will deal with that eventually.)</p>
<p>Now that we’ve identified this function call to load_processes as part of the cause of the bug, the new goal is to simplify the earlier part of the function to the bare minimum necessary to support this function call.</p>
<blockquote>
<p>In all of these cases, if an otherwise unused statement or expression influences the type-inference for the body, you may need to keep it around, or some variant of it.</p>
</blockquote>
<ul>
<li>Get rid of all non-binding statements. (We should not need any side-effecting computations to reproduce the bug.)</li>
<li>Initialize things to their default values (see “Defaultification” below).</li>
<li>Eliminate unused lets (see “Unusedification” below).</li>
</ul>
<p>After applying those steps repeatedly, and further “decommentification”, we are left with this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn reset_handler() {
    let chip = static_init!(arty_e21::chip::ArtyExx, arty_e21::chip::ArtyExx::new());
    let process_mgmt_cap = create_capability!(capabilities::ProcessManagementCapability);
    let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&amp;PROCESSES));

    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;0u8 as *const u8,
        &amp;mut [0; 8192], // APP_MEMORY,
        &amp;mut PROCESSES,
        kernel::procs::FaultResponse::Panic,
        &amp;process_mgmt_cap,
    );

}

<span class="boring">}</span></code></pre></pre>
<p>Just checking: the bug still reproduces, and we now have:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
     111     289    2807 tock/boards/arty-e21/src/main.rs

</code></pre>
<p>Its not 100% minimized yet, but its about as far as we can go in changes to fn reset_handler without making changes to crates upstream in dependency graph.</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="tactic-unusedification"><a class="header" href="#tactic-unusedification">Tactic: “Unusedification”</a></h2>
<p>Another way to remove distractions: remove them.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>non_pub_locally_unused_item(----) { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to <empty-string></p>
<p>At this point, after our initial round of “loopification”, we should have a lot of unused stuff: variables, struct fields, imports, etc. And even better, the compiler is probably already telling you about all of them!</p>
<p>In the specific case of arty-e21, I am currently seeing 25 warnings: 13 unused import warnings, 4 unused variable warnings, 2 static item is never used warnings, 1 constant item is never used warning, and 5 field is never used warnings.</p>
<p>If you’re doing the compilation runs in your IDE, then you should be able to just jump to each unused item and remove it in some way.</p>
<ul>
<li>In the case of fn parameters, you can replace it with _ as previously discussed.</li>
<li>ADT contents (struct and enum fields) may require more subtlety; see “ADT-reduction” below. For now, you can prefix their names with _.</li>
<li>Warning: Items with attributes like #[no_mangle] or #[link_section] may also want special treatment: you may be able to remove them without causing the bug to go away, but once the bug does go away, their absence may cause a confusing linker error.</li>
</ul>
<p>Make sure to check periodically that the bug still reproduces (Sometimes supposedly unused things still matter)!</p>
<p>This got boards/arty-e21 down to 95 lines:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>% wc tock/boards/arty-e21/src/main.rs
      95     254    2382 tock/boards/arty-e21/src/main.rs
<span class="boring">}</span></code></pre></pre>
<p>Again, not so impressive yet. But as with optimizations, sometimes the effect of these techniques only becomes apparent when they are combined together.</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="technique-cfgments"><a class="header" href="#technique-cfgments">Technique: “Cfgments”</a></h2>
<p>As a note: As a test run, you can easilly preview the effects of “unusedification” and “demodulification” (discussed below) transformations without actually deleting code. (After all, you may quickly discover that you need to put it back.) One classic approach for this is a comment block:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
non_pub_locally_unused_item(----) { ---- }
*/

<span class="boring">}</span></code></pre></pre>
<p>But it not always easy to toggle such comments on and off, since you need add and remove the /* and matching */ each time you want to toggle it. Some IDEs help with this, but I still prefer to use more local changed if I can.</p>
<p>A less used option that is more specific to Rust (and that I use all the time), is to use a #[cfg] attribute to temporarily remove the code:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unused_or_little_used_item { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not_now)]
unused_or_little_used_item { ---- }

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>No, I do not know how to pronounce “cfgment”; I have only typed it, never uttered it. Iä! Sheol-Nugganoth!I call this “cfgmenting” out code (as opposed to “commenting out code”).</p>
</blockquote>
<p>Whether or not you choose to use comments, “cfgments”, or just delete code outright is up to you, (though I do recommend you eventually delete the lines in question, as discussed in “decommentification”).</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="tactic-demodulification"><a class="header" href="#tactic-demodulification">Tactic: “Demodulification”</a></h2>
<p>In addition to “unusedifying” each identified unused item, you might try this: You may also be lucky enough to be able to just remove whole modules from this crate at this point. If the compiler is telling you that a lot of the items in a given module are unused, maybe you can get rid of the whole module. Go ahead and try it!</p>
<p>There can be a bit of guesswork involved here. For various reasons the compiler’s lints do not identify some definitions as unused even though it may seem obvious that they are not used.</p>
<ul>
<li>This can be a consequence of the impls in the source; see “Deimplification” below.</li>
<li>Also some cases are only identified after doing “depublification” of the contents of such modules, which is also discussed below.</li>
</ul>
<p>In the case of boards/arty-e21 I was able to identify mod timer_test as entirely unsed.</p>
<p>After “cfgmenting” it out and further “decommentification”, we have this:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
      73     191    1967 tock/boards/arty-e21/src/main.rs
</code></pre>
<p>(For now we have to keep the mod io { ... }; it defines a panic-handler, and we won’t be able to get rid of that until we do more reduction elsewhere.)</p>
<hr />
<blockquote>
<p>theme: Delete the Unnecessary</p>
</blockquote>
<h2 id="technique-adt-reduction"><a class="header" href="#technique-adt-reduction">Technique: “ADT-reduction”</a></h2>
<p>What more is there to reduce here? Well, there is a struct ArtyE21 all of whose fields are unused:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ArtyE21 {
    _console: &amp;'static capsules::console::Console&lt;'static&gt;,
    _gpio: &amp;'static capsules::gpio::GPIO&lt;'static&gt;,
    _alarm: &amp;'static capsules::alarm::AlarmDriver&lt;
        'static,
        VirtualMuxAlarm&lt;'static, rv32i::machine_timer::MachineTimer&lt;'static&gt;&gt;,
    &gt;,
    _led: &amp;'static capsules::led::LED&lt;'static&gt;,
    _button: &amp;'static capsules::button::Button&lt;'static&gt;,
}

<span class="boring">}</span></code></pre></pre>
<p>We got lucky here: This struct has no lifetime or type parameters, so we can just do a trivial replacement, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S { }

<span class="boring">}</span></code></pre></pre>
<p>This, combined with “unusedification” of a now-unused import, leaves us with:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
      63     170    1549 tock/boards/arty-e21/src/main.rs

</code></pre>
<h3 id="adt-reduction-in-general"><a class="header" href="#adt-reduction-in-general">“ADT-reduction” in general</a></h3>
<p>In the general case, if there is a generic parameter on the struct, you will need it to retain a field (to allow the compiler to compute the variance of the parameter).</p>
<p>Usually lifetime parameters are (co)variant, in which case this suffices:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ _inner: &amp;'a () }

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>struct S&lt;'a&gt;(Cell&lt;&amp;'a ()) is another option for encoding invariance, note it imports std::cell::Cell.</p>
</blockquote>
<p>If you need an invariant lifetime parameter to reproduce the bug, then you can do it this way:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;{ _inner: &amp;'a mut &amp;'a () }

<span class="boring">}</span></code></pre></pre>
<p>Likewise, type parameters can usually be encoded like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T&gt; { _inner: Option&lt;T&gt; }

<span class="boring">}</span></code></pre></pre>
<p>If the type parameter has the ?Sized (anti)bound, then you can use this variant:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T: ?Sized&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T&gt; { _inner: Option&lt;Box&lt;T&gt;&gt; }
<span class="boring">}</span></code></pre></pre>
<p>Often if there is both a lifetime and a type parameter, then I will combine them into one field:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { _inner: Option&lt;&amp;'a T&gt; }

<span class="boring">}</span></code></pre></pre>
<p>but in general that might not reflect the contentsfor example, it implicitly requires that T outlive 'a, which may not have been the case originaly of the original struct, and thus may cause the original bug to be masked. So in general you may have to do:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt; { _inner1: &amp;'a (), _inner2: Option&lt;T&gt; }

<span class="boring">}</span></code></pre></pre>
<p>or some variation thereof.</p>
<p>Having said that, its pretty rare that struct S&lt;'a, T&gt; { _inner: Option&lt;&amp;'a T&gt; } doesn’t suffice.</p>
<hr />
<blockquote>
<p>themes: Delete the Unnecessary, Identify the Unnecessary</p>
</blockquote>
<h2 id="tactic-deimplificiation"><a class="header" href="#tactic-deimplificiation">Tactic: “Deimplificiation”</a></h2>
<p>After “loopification”, often whole impl blocks can be eliminated.</p>
<p>In the case of arty-e21, we have this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Write for Writer {
    fn write_str(&amp;mut self, _: &amp;str) -&gt; ::core::fmt::Result { loop { } }
}

<span class="boring">}</span></code></pre></pre>
<p>which is entirely unused.</p>
<p>So we can “cfgment” it out, and now the compiler identifies two unused imports (since this impl-block was their only use); more importantly, it now also identifies that the struct Writer is never constructed. (Which we already knew since we were able to revise its fields at will during “ADT-reduction”; but the point is that we couldn’t have removed its definition without first removing all of its associated impl blocks. Thus, “deimplification” is an important step in our reduction odysssey.</p>
<p>That, plus more “unusedification” gets us to 55 lines:</p>
<pre><code class="language-shell">% wc tock/boards/arty-e21/src/main.rs
      55     146    1396 tock/boards/arty-e21/src/main.rs

</code></pre>
<h3 id="fine-grained-deimplification"><a class="header" href="#fine-grained-deimplification">Fine-grained “deimplification”</a></h3>
<p>In general you may not be able to remove the whole impl block. But you can still try to remove individual items from it, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
   fn method(----) { ---- }
   ...
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
   ...
}

<span class="boring">}</span></code></pre></pre>
<h4 id="technique-split-impls"><a class="header" href="#technique-split-impls">Technique: “split-impls”</a></h4>
<blockquote>
<p>aka Regroup fn items in inherent impls.</p>
</blockquote>
<p>I sometimes like to employ As a special technique to remove individual methods from an inherent impl: Rust lets you define multiple inherent impls for a given type. So rather than deleting code or using “cfgments” for each item, I will instead take an impl and break it into two, where one of them is “cfgmented” out:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
    fn method1(----) { ---- }
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not_now)]
impl Foo {
    fn method1(----) { ---- }
}
impl Foo {
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>Here, you can now move items freely between the “cfgmented”-out impl and the still present impl. It has a similar effect to “cfgmenting” out the individual items, but in practice it feels a lot more like an easy bisection process, at least for my fingers.</p>
<ul>
<li>Especially since you can start with the whole impl “cfgmented”-out, and let the compiler tell you which methods you need to put back (e.g. due to downstream uses.)</li>
</ul>
<p>You can also sometimes do this impl as a way to make more fine-grained impl-blocks that have looser constraints, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;X: Bound&gt; Foo&lt;X&gt; {
    fn method1(...) { ... }
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;X: Bound&gt; Foo {
    fn method1(...) { ... }
}
impl&lt;X&gt; Foo&lt;X&gt; {
    fn method2(...) { ... }
    fn method3(...) { ... }
}

<span class="boring">}</span></code></pre></pre>
<p>(where here we assume method2 and method3 do not require the X: Bound).</p>
<hr />
<h2 id="a-pause"><a class="header" href="#a-pause">A pause</a></h2>
<p>This is about as far as we can usefully get in reducing arty-e21 on its own.</p>
<p>To make further progress, we need to start making changes to upstream dependencies.</p>
<p>Lets look at the situation there.</p>
<hr />
<blockquote>
<p>theme: Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-dep-reduction"><a class="header" href="#tactic-dep-reduction">Tactic: “dep-reduction”</a></h3>
<blockquote>
<blockquote>
<p>aka “eliminate upstream dependencies”</p>
</blockquote>
</blockquote>
<p>We have not yet changed anything about the crate graph as a whole. Technicaly, building arty-e21 still builds 12 crates before starting on arty-e21. (Maybe cargo has some flag to inform you about unused dependencies?)</p>
<p>In any case, from inspecting arty-e21, we can see that it directly uses only two dependencies now: kernel and chips/arty_e21.</p>
<p>We can remove other dependencies from the Cargo.toml and see where it gets us:</p>
<pre><code class="language-toml">[dependencies]
kernel = { path = &quot;../../kernel&quot; }
arty_e21 = { path = &quot;../../chips/arty_e21&quot; }

</code></pre>
<p>A build after a cargo clean now shows just nine crates being built before arty-e21</p>
<pre><code class="language-shell">   Compiling tock-registers v0.4.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-register-interface)
   Compiling tock-cells v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-cells)
   Compiling tock_rt0 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/tock-rt0)
   Compiling arty-e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/boards/arty-e21)
   Compiling riscv-csr v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/libraries/riscv-csr)
   Compiling kernel v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/kernel)
   Compiling rv32i v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/arch/rv32i)
   Compiling sifive v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/sifive)
   Compiling arty_e21 v0.1.0 (/Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/arty_e21)
</code></pre>
<p>If we want to make more progress here, we’ll need to start working on upstream crates.</p>
<p>Looking at chips/arty_e21/Cargo.toml, we can see it also depends on the kernel crate:</p>
<pre><code class="language-toml">[dependencies]
sifive = { path = &quot;../sifive&quot; }
rv32i = { path = &quot;../../arch/rv32i&quot; }
kernel = { path = &quot;../../kernel&quot; }

</code></pre>
<p>So this gives us a hint where to go next: Simplify chips/arty_e21 as much as we can, before we tackle trying to simplify the (hopefully root) kernel crate.</p>
<p>So lets see what we need from chips/arty_e21. It has a very small lib.rs file:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Drivers and chip support for the E21 soft core.

#![feature(asm, concat_idents, const_fn)]
#![feature(exclusive_range_pattern)]
#![no_std]
#![crate_name = &quot;arty_e21&quot;]
#![crate_type = &quot;rlib&quot;]

mod interrupts;

pub mod chip;
pub mod gpio;
pub mod uart;

<span class="boring">}</span></code></pre></pre>
<p>Now I have a choice: do I go ahead and inline these module defintions like we did with boards/arty-e21? Well, lets figure out if we can first isolate its exports to a bare minimum before doing that.</p>
<hr />
<blockquote>
<p>theme: Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-depublification"><a class="header" href="#tactic-depublification">Tactic: “Depublification”</a></h3>
<p>As I already mentioned, the compiler is probably already tellling you about some of these (see “unusedification”).</p>
<p>But if you want to maximize the set of unused things that the compiler will identify for you, you might need to help it along the way by removing pub annotations, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod foo { ... }
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo { ... }
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use foo;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use foo;
<span class="boring">}</span></code></pre></pre>
<p>or struct, enum, type, trait, fn, etc; basically any pub item.</p>
<p>This can help compiler see that items or imports are in fact not used outside of the current crate, and thus can be eliminated.</p>
<p>For chips/arty_e21, I was able to successfully do this replacement:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod chip;
pub mod gpio;
pub mod uart;

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod chip;
mod gpio;
mod uart;

<span class="boring">}</span></code></pre></pre>
<p>and everything still built.</p>
<p>After this point, I attempted blind “demodulification” each of mod interrupts, mod gpio, and mod uart (since its so easy to try when they are declared as out-of-line modules). Unfortunately, pub mod chip; currently depends on all of them being present.</p>
<p>So that’s when I went ahead and inlined the module definitions, leaving me with a 371-line lib.rs for chips/arty_e21:</p>
<pre><code class="language-shell">% wc tock/chips/arty_e21/src/lib.rs
     371    1354   12137 tock/chips/arty_e21/src/lib.rs
</code></pre>
<blockquote>
<blockquote>
<p>Maybe this argues for a strategy where one should attempt targetted “loopification” on your reachable (pub) modules in the crate, and then do subsequent “demodulification” of the out-of-line modules before jumping into “mod-inlining”. I have not tried that workflow too seriously yet, though; its not that hard to “demodulify” a module, since its just a matter of “cfgmenting” out the mod declaration.</p>
</blockquote>
</blockquote>
<p>Then I “loopified” it; in this case, I was lucky and was able to loopify everything in chips/arty_e21, and the bug still reproduces.</p>
<p>After “loopification”, I was able to successfully “demodulify” all of mod interrupts, mod gpio, and mod uart.</p>
<p>Finally, I did some “deimplification”, and managed to remove everything except for a impl kernel::Chip for ArtyExx { ... } and one inherent method on struct ArtyExx.</p>
<p>Those steps, plus “decommentification”, removed about 320 lines.</p>
<pre><code class="language-shell">% wc tock/chips/arty_e21/src/lib.rs
      52     163    1180 tock/chips/arty_e21/src/lib.rs
</code></pre>
<p>Perhaps most importantly, it got the source code to the point where it fits on a screen.</p>
<hr />
<blockquote>
<p>themes: Enable Incremental Steps, Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-simpl-impl"><a class="header" href="#tactic-simpl-impl">Tactic: “simpl-impl”</a></h3>
<blockquote>
<blockquote>
<p>aka use trait defaults</p>
</blockquote>
</blockquote>
<p>I did just mention that I had to keep an impl kernel::Chip for ArtyExx { ... }.</p>
<p>In general, the impl blocks we are trying to eliminate may be trait impls rather than inherent ones. In those cases, we cannot just remove methods from the impls willy-nilly, as that would cause the compiler to reject the trait implementation.</p>
<blockquote>
<blockquote>
<p>Did you see this coming?</p>
</blockquote>
</blockquote>
<p>So, you have to keep that impl entirely intact… unless you do some work up front …</p>
<p>Here’s the trick around that. First add a trait default implementation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr { ... fn m(); }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr { ... fn m() { loop { } } }

<span class="boring">}</span></code></pre></pre>
<p>This enables the subsequent transformation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Tr for C { ... fn m() { ---- } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Tr for C { ... }

<span class="boring">}</span></code></pre></pre>
<p>Thats right, you can turn a non-default trait method into a “loopified” default trait method, and that enables you to freely remove instances of that method from all of that trait’s impls. You can do this transformation piecewise, or for the whole trait definition, as you like.</p>
<p>And (I think) you can do it pretty much as freely as you like: you should not need to worry about changing a trait method to a “loopified” default causing breakage elsewhere when compiling the crate graph (unless there is some potential interaction with specialization that I have not considered).</p>
<p>If you apply the transformation repeatedly, it can often result in</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr { ---- } // all methods loopified
impl Tr for C { }

<span class="boring">}</span></code></pre></pre>
<p>which is simply awesome.</p>
<p>In our specific case, the trait in question is upstream: impl kernel::Chip for ArtyExx { ... }</p>
<p>So we are going to make an exception to our earler rule about trying to work at the leaves first: Here, we are justified in jumping upstream, to kernel/src/platform/mod.rs, and changing the definition of kernel::Chip, doing M-x query-replace of ; with { loop { } } to easily jump through the fn-items and add a “loopified” body to each one.</p>
<p>(In my case, I’m going to decommentify the relevant file first too.)</p>
<p>After adding “loopified” default methods to the traits in kernel::platform, we can return to chips/arty_e21 and further simplify the impl there to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl kernel::Chip for ArtyExx {
    type MPU = ();
    type UserspaceKernelBoundary = rv32i::syscall::SysCall;
    type SysTick = ();
}

<span class="boring">}</span></code></pre></pre>
<p>Now we need to apply a bit of artistry.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="tactic-type-trivialization"><a class="header" href="#tactic-type-trivialization">Tactic: “Type-trivialization”</a></h3>
<p>This associated type in impl kernel::Chip for ArtyExx is forcing dependency on rv32i:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type UserspaceKernelBoundary = rv32i::syscall::SysCall;

<span class="boring">}</span></code></pre></pre>
<p>But we have removed all the methods! Chances are actually quite good that there is no longer anyone that relies on that type defintion. (Its not a certainty, of course; clients of the trait might be extracting the type directly, and the associated may have trait bounds that will force us to use a non-trivial type there.)</p>
<p>But lets try it and see:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl kernel::Chip for ArtyExx {
    type MPU = ();
    type UserspaceKernelBoundary = ();
    type SysTick = ();
}

<span class="boring">}</span></code></pre></pre>
<p>yields:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0277]: the trait bound `(): kernel::syscall::UserspaceKernelBoundary` is not satisfied
  --&gt; /Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/chips/arty_e21/src/lib.rs:22:6
   |
22 | impl kernel::Chip for ArtyExx {
   |      ^^^^^^^^^^^^ the trait `kernel::syscall::UserspaceKernelBoundary` is not implemented for `()`

error: aborting due to previous error

<span class="boring">}</span></code></pre></pre>
<p>So, what to do about this?</p>
<p>Honestly, I figure this is another case where we are justified in going upstream and removing the bound in question, just to see what happens:</p>
<pre><code class="language-diff">diff --git a/tock/kernel/src/platform/mod.rs b/tock/kernel/src/platform/mod.rs
index 9544899..dd107dd 100644
--- a/tock/kernel/src/platform/mod.rs
+++ b/tock/kernel/src/platform/mod.rs
@@ -13,7 +13,7 @@ pub trait Platform {
 pub trait Chip {
     type MPU: mpu::MPU;

-    type UserspaceKernelBoundary: syscall::UserspaceKernelBoundary;
+    type UserspaceKernelBoundary;

     type SysTick: systick::SysTick;

</code></pre>
<p>And the answer is:</p>
<pre><code>error[E0277]: the trait bound `&lt;C as platform::Chip&gt;::UserspaceKernelBoundary: syscall::UserspaceKernelBoundary` is not satisfied
   --&gt; /Users/felixklock/Dev/Mozilla/issue65774/demo-minimization/tock/kernel/src/process.rs:468:5
    |
468 | /     stored_state:
469 | |         Cell&lt;&lt;&lt;C as Chip&gt;::UserspaceKernelBoundary as UserspaceKernelBoundary&gt;::StoredState&gt;,
    | |____________________________________________________________________________________________^ the trait `syscall::UserspaceKernelBoundary` is not implemented for `&lt;C as platform::Chip&gt;::UserspaceKernelBoundary`
    |
    = help: consider adding a `where &lt;C as platform::Chip&gt;::UserspaceKernelBoundary: syscall::UserspaceKernelBoundary` bound

error: aborting due to previous error

</code></pre>
<p>Darn. (We could take the compilers advice and add the aforementioned where clause, but that stands a good chance of just shifting the blame around without actually helping us make progress on reduction itself.)</p>
<p>You might think: “Lets try removing that field from the struct”; but note that the struct Process lives in the kernel crate, and that code has not yet been “loopified.” So there’s a good chance that there’s existing code that relies on that field being there, and we have to get rid of that code first.</p>
<p>Well, we did a good job getting chips/arty_e21 as small as we did. Let us take this as a sign that we should keep moving up, to now focus on reducing the kernel crate.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="technique-mod-inlining-and-loopification-via-pretty-printer"><a class="header" href="#technique-mod-inlining-and-loopification-via-pretty-printer">Technique: “mod-inlining” and “loopification” via pretty-printer</a></h3>
<p>I want to simplify the kernel crate.</p>
<p>However, its module hierarchy is a bit larger than the other two crates we’ve looked at so far:</p>
<pre><code>% find tock/kernel -name '*.rs'
tock/kernel/src/tbfheader.rs
tock/kernel/src/ipc.rs
tock/kernel/src/memop.rs
tock/kernel/src/lib.rs
tock/kernel/src/platform/mod.rs
tock/kernel/src/platform/systick.rs
tock/kernel/src/platform/mpu.rs
tock/kernel/src/callback.rs
tock/kernel/src/common/static_ref.rs
tock/kernel/src/common/list.rs
tock/kernel/src/common/peripherals.rs
tock/kernel/src/common/queue.rs
tock/kernel/src/common/ring_buffer.rs
tock/kernel/src/common/dynamic_deferred_call.rs
tock/kernel/src/common/mod.rs
tock/kernel/src/common/math.rs
tock/kernel/src/common/deferred_call.rs
tock/kernel/src/common/utils.rs
tock/kernel/src/hil/symmetric_encryption.rs
tock/kernel/src/hil/dac.rs
tock/kernel/src/hil/rng.rs
tock/kernel/src/hil/i2c.rs
tock/kernel/src/hil/pwm.rs
tock/kernel/src/hil/sensors.rs
tock/kernel/src/hil/watchdog.rs
tock/kernel/src/hil/led.rs
tock/kernel/src/hil/time.rs
tock/kernel/src/hil/crc.rs
tock/kernel/src/hil/ninedof.rs
tock/kernel/src/hil/entropy.rs
tock/kernel/src/hil/spi.rs
tock/kernel/src/hil/nonvolatile_storage.rs
tock/kernel/src/hil/mod.rs
tock/kernel/src/hil/usb.rs
tock/kernel/src/hil/adc.rs
tock/kernel/src/hil/gpio_async.rs
tock/kernel/src/hil/analog_comparator.rs
tock/kernel/src/hil/gpio.rs
tock/kernel/src/hil/radio.rs
tock/kernel/src/hil/eic.rs
tock/kernel/src/hil/flash.rs
tock/kernel/src/hil/uart.rs
tock/kernel/src/hil/ble_advertising.rs
tock/kernel/src/driver.rs
tock/kernel/src/component.rs
tock/kernel/src/sched.rs
tock/kernel/src/introspection.rs
tock/kernel/src/debug.rs
tock/kernel/src/process.rs
tock/kernel/src/syscall.rs
tock/kernel/src/returncode.rs
tock/kernel/src/grant.rs
tock/kernel/src/capabilities.rs
tock/kernel/src/mem.rs
</code></pre>
<p>I don’t want to manually-inline all those modules into kernel.</p>
<p>I’m also not too eager to manually “loopify” it (though that would be easier if the “mod-inlining” were done).</p>
<p>Luckily, we can leverage the compiler here.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="mod-inlining-via-pretty-printer"><a class="header" href="#mod-inlining-via-pretty-printer">“mod-inlining” via pretty-printer</a></h3>
<p>As mentioned earlier, we can add -Z unstable-options --pretty=expanded to the relevant rustc invocation (in ths case, the one compiling kernel/src/lib.rs) to get the content of the crate as one module tree.</p>
<ul>
<li>(Unfortunately for our immediate purposes, the macros in it are also expanded. But since macros could expand into mod-declarations, this is tough to avoid in the general case for solving this problem.)</li>
</ul>
<p>Pipe that output to a file, copy that file to tock/kernel/src/lib.rs, and you’re don- … well, no; you’re not done yet.</p>
<p>If you try to compile that as is, you get a slew of errors. Because some of the macros that expanded came from Rust’s core library, and make use of features that are not available in stable Rust. So you have to add feature-gates to enable each one. Luckily, the nightly compiler tells us which gates to add, so I was able to get away with adding this line to the top of the generated file:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(derive_clone_copy, compiler_builtins_lib, fmt_internals, core_panic, derive_eq)]

<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>Then the compilation of this expanded kernel worked, and the downstream problem continued to reproduce. Success!</p>
<p>At least, success if your definition of success is this:</p>
<pre><code>% wc tock/kernel/src/lib.rs
   10238   40254  540987 tock/kernel/src/lib.rs

</code></pre>
<p>Yikes, 10K lines.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="loopification-via-pretty-printer"><a class="header" href="#loopification-via-pretty-printer">“loopification” via pretty-printer</a></h3>
<blockquote>
<blockquote>
<p>aka -Z everybody_loops</p>
</blockquote>
</blockquote>
<p>Well, that’s okay: There are some steps we haven’t taken yet. Specifically, we haven’t done “loopification.”</p>
<p>Now, its not so much fun to “loopify” a file like this by hand. The keyboard macro I described above isn’t tha robust; it can end up really messing up the code if you apply it blindly.</p>
<p>But luckily, we have another option:</p>
<p>rustc -Z unpretty=everybody_loops is your friend.</p>
<p>Basically, take the command line we used up above for macro-expanding pretty-printing, but replace the --pretty=expanded with -Zunpretty=everybody_loops.</p>
<p>As before, pipe the output to a temporary file, and then copy that over to kernel/src/lib.rs.</p>
<p>And then we build … and … oh. The bug didn’t replicate.</p>
<ul>
<li>This is okay. It is not a disaster.</li>
</ul>
<p>It in fact motivates another technique: bisecting “loopification”.</p>
<h3 id="bisecting-the-module-tree"><a class="header" href="#bisecting-the-module-tree">Bisecting the module tree</a></h3>
<p>Warning: this technique may seem… strange. But I love it so.</p>
<p>The three steps are as follows:</p>
<ol>
<li>Unify modules into a single source file (which we did up above, via the pretty-printer). But in particular, leave leave the original source files for the mod tree in place. (You’ll see why in a moment.)</li>
<li>Replace all function bodies with loop { }(which we just did, again via the pretty-printer).</li>
</ol>
<blockquote>
<blockquote>
<p>If after doing this, you still get the same failure again, then congratulations: You have a single file (with a potentially huge module tree) and all of its function bodies are trivial loop { }. But of course, in our case of kernel, we know that we are not in this scenario. </p>
</blockquote>
</blockquote>
<ol start="3">
<li>Finally, swap modules in and out via “cfgmenting”.</li>
</ol>
<p>Remember up above when I suggested leaving the source files in place? This is where that comes into play.</p>
<p>A relatively tiny (and easily mechanized) change to the source code readily reverts individual modules back to their prior form:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod child_mod_1 {
    use import::stuff;
    fn some_function() -&gt; ReturnType {
        loop { }
    }

    mod even_more_inner {
       ...
    }
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod child_mod_1;

#[cfg(commented_out_for_bisection)]
mod child_mod_1 {
    use import::stuff;
    fn some_function() -&gt; ReturnType {
        loop { }
    }

    mod even_more_inner {
       ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This effectively puts back in the original code for child_mod_1.</p>
<p>You can search through your single lib.rs (or main.rs) file that holds the whole module tree (where function bodies are replaced with loop { }), and then choose a subset of these modules and apply the above transformation to point them at their original source file.</p>
<p>You can do this for, e.g., the first half the modules, and then re-run the compiler to see if the failure re-arises. If so, huzzah!</p>
<p>I successfully used this methodology to identify which mod in kernel we needed to keep in non-loopified form in order to reproduce the bug: mod process;.</p>
<p>And that gets us down to:</p>
<pre><code>wc tock/kernel/src/lib.rs
    3253   11085  112858 tock/kernel/src/lib.rs

</code></pre>
<p>Yeah, still 3K lines. But that’s a lot better than 10K, and there’s plenty more stuff to remove.</p>
<p>First, lets see if we can further narrow down which methods in mod process are the ones that we need for replicating the bug. For this, we can do bisection over the fn items within the (still out-of-line) mod process.</p>
<hr />
<h3 id="reduction-via-bisection"><a class="header" href="#reduction-via-bisection">Reduction via Bisection</a></h3>
<p>Sometimes you cannot simply remove all (or all but one) of the method bodies. For one reason or another (e.g. impl Trait in return position) you need to preserve the bodies of one or more methods that are not directly relevant to the bug at hand.</p>
<p>In this scenario, it can stil be useful to use the techniques above to eliminate irrelevant details in the other methods. But what is the best way to identify which methods are relevant and which aren’t? Well, that’s a fine segue to our original topic.</p>
<p>(… a significant amount of time has passed.)</p>
<p>Okay: after spending a lot of time doing pseudo-bisection, I managed to isolate three methods in process.rs that are necessary to reproduce the issue.</p>
<p>Part of my own process here (not process, ha ha) was to switch mindset away from trying to bisect to find the “one fn body” that causes the faiure. Instead, I had to focus on identifying a minimal subset of bodies that are necessary to cause it to arise.</p>
<p>That is, starting with N fn items, I’d “loopify” N/2 of them, and if the bug went away on that half, I’d put back in the previous bodies, cut that set in in half, and repeat until the bug came back. This tended to narrow things down to one fn item that, when “loopified”, made the bug go away.</p>
<p>Then I’d mark that one fn as strictly necessary, and repeat the process on the N-1 fn-items that still remained.</p>
<p>To be clear: this switch in mindset changes so-called “bisection” from a O(log n) process to an O(n log n) one: because you are going to do a separate O(log n) bisection step on O(n) fn-items. But on the plus side, its still a pretty mindless process (and probably could be mechanically automated).</p>
<p>Eventually, this led me to identify the three functions in process.rs whose non-“loopified” definitions are needed to witness the bug:</p>
<ul>
<li>load_processes</li>
<li><Process as ProcessType>::process_detail_fmt, and</li>
<li>Process::create.</li>
</ul>
<p>With that done, I redid the “mod-inlining” of mod process into kernel.</p>
<h2 id="popping-the-stack"><a class="header" href="#popping-the-stack">Popping the stack</a></h2>
<p>Now, as a reminder: the reason we dived into kernel was to see if we could remove the stored_state field from struct Process:</p>
<pre><code>stored_state:
    Cell&lt;&lt;&lt;C as Chip&gt;::UserspaceKernelBoundary as UserspaceKernelBoundary&gt;::StoredState&gt;,
</code></pre>
<p>The answer is unfortuately still no: two of the three methods we kept from mod process refer to that field.</p>
<p>But we can do some directed editing to see if the bug repreoduces after removing those references:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3067,12 +3067,6 @@ impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
             flash_start
         ));

-        self.chip.userspace_kernel_boundary().process_detail_fmt(
-            self.sp(),
-            &amp;self.stored_state.get(),
-            writer,
-        );
-
         self.mpu_config.map(|config| {
             let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
         });
@@ -3205,7 +3199,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {

             process.flash = slice::from_raw_parts(app_flash_address, app_flash_size);

-            process.stored_state = Cell::new(Default::default());
+            // process.stored_state = Cell::new(Default::default());
             process.state = Cell::new(State::Unstarted);
             process.fault_response = fault_response;

@@ -3246,6 +3240,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
                 }));
             });

+            /*
             let mut stored_state = process.stored_state.get();
             match chip.userspace_kernel_boundary().initialize_new_process(
                 process.sp(),
@@ -3263,6 +3258,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
                     return (None, app_flash_size, 0);
                 }
             };
+             */
</code></pre>
<p>And the answer is: YES. The bug reproduces!</p>
<p>And now we can move forward with removing that field… YES, still reproduces:</p>
<pre><code class="language-diff">
--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2809,9 +2809,6 @@ pub struct Process&lt;'a, C: 'static + Chip&gt; {

     header: tbfheader::TbfHeader,

-    stored_state:
-        Cell&lt;&lt;&lt;C as Chip&gt;::UserspaceKernelBoundary as UserspaceKernelBoundary&gt;::StoredState&gt;,
-
     state: Cell&lt;State&gt;,

     fault_response: FaultResponse,

</code></pre>
<p>And then see about removed the bound on the associated type that sent us on this path… YES</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2525,7 +2525,7 @@ mod platform {
         type
         MPU: mpu::MPU;
         type
-        UserspaceKernelBoundary: syscall::UserspaceKernelBoundary;
+        UserspaceKernelBoundary;
         type
         SysTick: systick::SysTick;
         fn service_pending_interrupts(&amp;self) { loop  { } }

</code></pre>
<p>So now we can pop our stack: We can go back to chips/arty_e21, and apply “type-trivialization”:</p>
<pre><code class="language-diff">
--- a/tock/chips/arty_e21/src/lib.rs
+++ b/tock/chips/arty_e21/src/lib.rs
@@ -21,7 +21,7 @@ impl ArtyExx {

 impl kernel::Chip for ArtyExx {
     type MPU = ();
-    type UserspaceKernelBoundary = rv32i::syscall::SysCall;
+    type UserspaceKernelBoundary = ();
     type SysTick = ();
 }
</code></pre>
<p>We did it!</p>
<p>With that in place, we can do more “dep-reduction”, by removing the rv32i dependency from chips/arty_e21.</p>
<p>At this point, we could continue with the above transformations to further reduce kernel.</p>
<p>But I want to switch to showing a different kind of minimization transformation, one that will let us make further simplifications to boards/arty-e21.</p>
<hr />
<h3 id="simplfying-the-existing-code"><a class="header" href="#simplfying-the-existing-code">Simplfying the existing code</a></h3>
<p>Looking again at boards/arty-e21, we have this method body:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe fn reset_handler() {
    let chip = static_init!(arty_e21::chip::ArtyExx, arty_e21::chip::ArtyExx::new());
    let process_mgmt_cap = create_capability!(capabilities::ProcessManagementCapability);
    let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&amp;PROCESSES));

    kernel::procs::load_processes(
        board_kernel,
        chip,
        &amp;0u8 as *const u8,
        &amp;mut [0; 8192], // APP_MEMORY,
        &amp;mut PROCESSES,
        kernel::procs::FaultResponse::Panic,
        &amp;process_mgmt_cap,
    );
}
<span class="boring">}</span></code></pre></pre>
<p>It would be nice to figure out which parts of this are actually relevant.</p>
<p>Unfortunately, kernel::procs::load_processes was one of the functions where we could not apply “loopification” without masking the rustc bug.</p>
<p>Let us see if we can at least simplfify the API of load_processes itself.</p>
<p>It currently looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(
    kernel: &amp;'static Kernel,
    chip: &amp;'static C,
    start_of_flash: *const u8,
    app_memory: &amp;mut [u8],
    procs: &amp;'static mut [Option&lt;&amp;'static dyn ProcessType&gt;],
    fault_response: FaultResponse,
    _capability: &amp;dyn ProcessManagementCapability,
) {
    let mut apps_in_flash_ptr = start_of_flash;
    let mut app_memory_ptr = app_memory.as_mut_ptr();
    let mut app_memory_size = app_memory.len();
    for i in 0..procs.len() {
        unsafe {
            let (process, flash_offset, memory_offset) = Process::create(
                kernel,
                chip,
                apps_in_flash_ptr,
                app_memory_ptr,
                app_memory_size,
                fault_response,
                i,
            );

            if process.is_none() {
                if flash_offset == 0 &amp;&amp; memory_offset == 0 {
                    break;
                }
            } else {
                procs[i] = process;
            }

            apps_in_flash_ptr = apps_in_flash_ptr.add(flash_offset);
            app_memory_ptr = app_memory_ptr.add(memory_offset);
            app_memory_size -= memory_offset;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The fact that Process::create was another function that we could not “loopify” gives us a hint has to how to simplfy this further: can we reduce this method body to just a Process::create call, and see if the bug persists?</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2586,31 +2586,17 @@ pub fn load_processes&lt;C: Chip&gt;(
     let mut apps_in_flash_ptr = start_of_flash;
     let mut app_memory_ptr = app_memory.as_mut_ptr();
     let mut app_memory_size = app_memory.len();
-    for i in 0..procs.len() {
         unsafe {
-            let (process, flash_offset, memory_offset) = Process::create(
+            Process::create(
                 kernel,
                 chip,
                 apps_in_flash_ptr,
                 app_memory_ptr,
                 app_memory_size,
                 fault_response,
-                i,
+                0,
             );
-
-            if process.is_none() {
-                if flash_offset == 0 &amp;&amp; memory_offset == 0 {
-                    break;
-                }
-            } else {
-                procs[i] = process;
-            }
-
-            apps_in_flash_ptr = apps_in_flash_ptr.add(flash_offset);
-            app_memory_ptr = app_memory_ptr.add(memory_offset);
-            app_memory_size -= memory_offset;
         }
-    }
 }
</code></pre>
<p>And yes, the bug still reproduces.</p>
<hr />
<blockquote>
<p>theme: Simplify Workflow</p>
</blockquote>
<h3 id="tactic-rhs-inlining"><a class="header" href="#tactic-rhs-inlining">Tactic: “RHS-inlining”</a></h3>
<p>This is just the classic transformation of taking the right-hand side of a let or const and copying it into the usage sites for the variable defined by the let or const. Once all uses of the variable have been replaced, you can try removing the let or const itself (i.e. “unusedification”)</p>
<p>In our specific case, we can apply this to load_processes:</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2583,16 +2583,13 @@ pub fn load_processes&lt;C: Chip&gt;(
     fault_response: FaultResponse,
     _capability: &amp;dyn ProcessManagementCapability,
 ) {
-    let mut apps_in_flash_ptr = start_of_flash;
-    let mut app_memory_ptr = app_memory.as_mut_ptr();
-    let mut app_memory_size = app_memory.len();
         unsafe {
             Process::create(
                 kernel,
                 chip,
-                apps_in_flash_ptr,
-                app_memory_ptr,
-                app_memory_size,
+                start_of_flash,
+                app_memory.as_mut_ptr(),
+                app_memory.len(),
                 fault_response,
                 0,
             );

</code></pre>
<p>However, this technique on its own does not tend to actually reduce the problem at hand, in terms of making it possible for us to remove imports or simplify fn API signatures.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="tactic-defaultification"><a class="header" href="#tactic-defaultification">Tactic: “Defaultification”</a></h3>
<blockquote>
<blockquote>
<p>aka “Scalars Gotta Scale”</p>
</blockquote>
</blockquote>
<p>If you really want to simplify, then you should replace the occurences of the variable with some “obvious” value based on its type.</p>
<p>(This is the obvious alternative to “loopification” when it comes to simplifying const fn.)</p>
<p>More specifically: frequently, the return type of a const fn (or the type of a const item) is some scalar type (like u32, f64, or bool). These all have “obvious” values that you can just plug in (respectively 0, 0.0, or false).</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn cfoo(----) -&gt; u32 { ---- }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn cfoo(----) -&gt; u32 { 0 }

<span class="boring">}</span></code></pre></pre>
<p>In the case of load_processes, “defaultification” yields this:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2587,9 +2587,9 @@ pub fn load_processes&lt;C: Chip&gt;(
             Process::create(
                 kernel,
                 chip,
-                start_of_flash,
-                app_memory.as_mut_ptr(),
-                app_memory.len(),
+                0 as *const u8,
+                (&amp;mut []).as_mut_ptr(),
+                0,
                 fault_response,
                 0,
             );
</code></pre>
<p>That means we’ve gotten rid of the uses of three fn parameters in the body of load_processes. Lets see what that can buy us for further reduction.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-genertrification"><a class="header" href="#technique-genertrification">Technique: “Genertrification”</a></h3>
<blockquote>
<blockquote>
<p>aka “Type Freedom”</p>
</blockquote>
</blockquote>
<p>Once you remove all uses of parameter (which is readily identifiable via either lint diagnostics or if the parameter has just _: ParamType for its declaration), you can “genertrify” it to get rid of the use of ParamType.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: ParamType, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;A&gt;(_: A, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>or even more simply (in terms of locality of the transformation):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: impl Sized, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>The beauty of this is that it can almost always be applied even if there remain uses of foo elsewhere in the code.</p>
<p>Therefore, I tend to recommend it over “param-elimination”, described below.</p>
<ul>
<li>However, this transformation does not work if fn foo must not carry any generic type parameters; e.g., if fn foo needs to be object-safe, then you cannot add the type parameteter A.</li>
<li>The other case where it cannot be applied is when an existing use is relying on the existing type for inference purposes. We will see an example of this below.</li>
</ul>
<p>In the case of load_processes, “genertrification” allows this change:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2577,11 +2577,11 @@ use core::cmp::max;
 pub fn load_processes&lt;C: Chip&gt;(
     kernel: &amp;'static Kernel,
     chip: &amp;'static C,
-    start_of_flash: *const u8,
-    app_memory: &amp;mut [u8],
-    procs: &amp;'static mut [Option&lt;&amp;'static dyn ProcessType&gt;],
+    _: impl Sized,
+    _: impl Sized,
+    _: impl Sized,
     fault_response: FaultResponse,
-    _capability: &amp;dyn ProcessManagementCapability,
+    _: impl Sized,
 ) {
         unsafe {
             Process::create(
</code></pre>
<p>And once we do that, we can revise any calls to load_processes and pass any value we like for the impl Sized arguments. So we’ve opened up new opportunities for “expr-elimination”:</p>
<pre><code class="language-diff">--- INDEX/tock/boards/arty-e21/src/main.rs
+++ WORKDIR/tock/boards/arty-e21/src/main.rs
@@ -39,17 +39,16 @@ impl Platform for ArtyE21 {
 #[no_mangle]
 pub unsafe fn reset_handler() {
     let chip = static_init!(arty_e21::chip::ArtyExx, arty_e21::chip::ArtyExx::new());
-    let process_mgmt_cap = create_capability!(capabilities::ProcessManagementCapability);
     let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&amp;PROCESSES));

     kernel::procs::load_processes(
         board_kernel,
         chip,
-        &amp;0u8 as *const u8,
-        &amp;mut [0; 8192], // APP_MEMORY,
-        &amp;mut PROCESSES,
+        (),
+        (),
+        (),
         kernel::procs::FaultResponse::Panic,
-        &amp;process_mgmt_cap,
+        (),
     );

 }
</code></pre>
<p>We would like to continue simplifying the APIs by applying “genertrification” elsewhere. For example, load_processes calls Process::create, so it would be useful to simplify its API.</p>
<p>The body of Process::create is currently over 150 lines of code. But after bisection-based “expr-elimination”, coupled with “RHS-inlining”, “defaultification”, and “unusedification”, we can get the body down to this far more managable 20 lines:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        kernel: &amp;'static Kernel,
        chip: &amp;'static C,
        app_flash_address: *const u8,
        remaining_app_memory: *mut u8,
        remaining_app_memory_size: usize,
        fault_response: FaultResponse,
        index: usize,
    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
            let mut process: &amp;mut Process&lt;C&gt; =
                &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

            process.debug = MapCell::new(ProcessDebug {
                app_heap_start_pointer: None,
                app_stack_start_pointer: None,
                min_stack_pointer: 0 as *const u8,
                syscall_count: 0,
                last_syscall: None,
                dropped_callback_count: 0,
                restart_count: 0,
                timeslice_expiration_count: 0,
            });

            return (
                Some(process),
                0usize,
                0usize,
            );
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>And now we can apply “genertrification”:</p>
<pre><code class="language-diff">
--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3065,13 +3065,13 @@ fn exceeded_check(size: usize, allocated: usize) -&gt; &amp;'static str { loop { } }
 impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
-        kernel: &amp;'static Kernel,
+        kernel: impl Sized,
         chip: &amp;'static C,
-        app_flash_address: *const u8,
+        app_flash_address: impl Sized,
         remaining_app_memory: *mut u8,
-        remaining_app_memory_size: usize,
-        fault_response: FaultResponse,
-        index: usize,
+        remaining_app_memory_size: impl Sized,
+        fault_response: impl Sized,
+        index: impl Sized,
     ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);
</code></pre>
<h4 id="you-cant-always-genertrify-what-you-want"><a class="header" href="#you-cant-always-genertrify-what-you-want">“you can’t always genertrify what you want”</a></h4>
<p>Unfortunately, I was not able to “genertrify” the remaining_app_memory formal parameter, even though it is unused in the function body. Why is this? Because the current call-site is relying on the type of the formal parameter for inference purposes. So in this case, we need to update the API in tandem with the call site:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2588,7 +2588,7 @@ pub fn load_processes&lt;C: Chip&gt;(
                 (),
                 chip,
                 (),
-                (&amp;mut []).as_mut_ptr(),
+                (),
                 0,
                 (),
                 0,
@@ -3068,7 +3068,7 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
         kernel: impl Sized,
         chip: &amp;'static C,
         app_flash_address: impl Sized,
-        remaining_app_memory: *mut u8,
+        remaining_app_memory: impl Sized,
         remaining_app_memory_size: impl Sized,
         fault_response: impl Sized,
         index: impl Sized,
</code></pre>
<p>This allows further “expr-elimination”:</p>
<pre><code class="language-diff">
--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3076,17 +3076,6 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

-            process.debug = MapCell::new(ProcessDebug {
-                app_heap_start_pointer: None,
-                app_stack_start_pointer: None,
-                min_stack_pointer: 0 as *const u8,
-                syscall_count: 0,
-                last_syscall: None,
-                dropped_callback_count: 0,
-                restart_count: 0,
-                timeslice_expiration_count: 0,
-            });
-
             return (
                 Some(process),
                 0usize,
</code></pre>
<p>and we bave gotten Process::create down to something that actually is close to minimal, at least with given the transformations we have covered so far:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        kernel: impl Sized,
        chip: &amp;'static C,
        app_flash_address: impl Sized,
        remaining_app_memory: impl Sized,
        remaining_app_memory_size: impl Sized,
        fault_response: impl Sized,
        index: impl Sized,
    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
            let mut process: &amp;mut Process&lt;C&gt; =
                &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

            return (
                Some(process),
                0usize,
                0usize,
            );
    }
...
}
<span class="boring">}</span></code></pre></pre>
<p>But of course, we can go further!</p>
<h3 id="once-all-the-code-is-gone-"><a class="header" href="#once-all-the-code-is-gone-">Once all the code is gone …</a></h3>
<p>The applicability of many of the remaining patterns depends on whether you have successfully trivialized all or most method bodies. That is, if you have gotten rid of most of the complex expressions in the program, then you can usually remove things like struct field declarations or any “interesting” types on formal parameters.</p>
<p>So, lets see if we can further reduce the complexity of our example by simplifying the APIs of the functions involved.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-param-elimination"><a class="header" href="#technique-param-elimination">Technique: “Param-elimination”</a></h3>
<p>If you have successfully eliminated all uses of a method foo, then you can apply this transformation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: ArgType, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>In some rare cases, the compiler bug will requires a method signature to keep the same number of arguments; for that scenario, you can instead use “type-trivialization” for the parameter:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: ArgType, ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_: (), ----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>Either way, these transformations can only be applied if all uses of foo have been eliminated via trivialization of bodies as described above (or if you are willing to update them all accordingly). Thus, I tend to recommend applying “genertrification” instead: that transformation can be applied without concern about the usage sites.</p>
<p>Of course, if you have already applied “genertrification” and also updated all call sites to pass something trivial like (), then you can readily apply either “param-elimination” or “type-trivialization”: it really should be easy to update the call-sites in that scenario.</p>
<p>In our particular case of Process::create, we currently have a fn-signature that looks like:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>crate unsafe fn create(
    kernel: impl Sized,
    chip: &amp;'static C,
    app_flash_address: impl Sized,
    remaining_app_memory: impl Sized,
    remaining_app_memory_size: impl Sized,
    fault_response: impl Sized,
    index: impl Sized,
) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
<span class="boring">}</span></code></pre></pre>
<p>And we already updated the single call-site to pass () or 0 for each of the parameters of type impl Sized, so now we can just remove them entirely:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2585,13 +2585,7 @@ pub fn load_processes&lt;C: Chip&gt;(
 ) {
         unsafe {
             Process::create(
-                (),
                 chip,
-                (),
-                (),
-                0,
-                (),
-                0,
             );
         }
 }
@@ -3065,13 +3059,7 @@ fn exceeded_check(size: usize, allocated: usize) -&gt; &amp;'static str { loop { } }
 impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
-        kernel: impl Sized,
         chip: &amp;'static C,
-        app_flash_address: impl Sized,
-        remaining_app_memory: impl Sized,
-        remaining_app_memory_size: impl Sized,
-        fault_response: impl Sized,
-        index: impl Sized,
     ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

</code></pre>
<p>And compiling still hits the same ICE, so this “param-elimination” was a legitimate reduction of the problem.</p>
<p>Next we’ll consider a related transformation on the fn-signature.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-ret-elimination"><a class="header" href="#technique-ret-elimination">Technique: “Ret-elimination”</a></h3>
<p>If you have successfully eliminated all uses of the value returned from calls to foo, then you can apply this transformation:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) { loop { } }

<span class="boring">}</span></code></pre></pre>
<p>If fn foo still has a body, then you can just turn every return point in the body into a normal expression:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { if A { return B; } TailReturn }

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) { if A { B; } TailReturn; }

<span class="boring">}</span></code></pre></pre>
<p>In our case, the sole call to Process::create now looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    unsafe {
        Process::create(
            chip,
        );
    }

<span class="boring">}</span></code></pre></pre>
<p>So we can directly apply “ret-elimination” to the definition of Process::create:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -3060,11 +3060,11 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
         chip: &amp;'static C,
-    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
+    ) {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

-            return (
+            (
                 Some(process),
                 0usize,
                 0usize,
</code></pre>
<p>But… Ah ha! Doing this causes the compilation error to disappear!</p>
<p>What happened?</p>
<p>Well, inspecting the return type, we can see that “Ret-elimination” in this case has gotten rid of the type: (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize). Nested within that tuple, we see the type &amp;'static dyn ProcessType. So, the attemtpt to return (Some(process), 0, 0) is causing the generated code to coerce the process: &amp;mut Process<C> into a trait-object of type &amp;dyn ProcessType. And apparently this is part of generating the bug!</p>
<p>So, do not look at this reduction-failure as a set-back: It in fact may serve as a clue as to the root cause of the bug.</p>
<hr />
<h3 id="final-reduction-touches-on-processcreate"><a class="header" href="#final-reduction-touches-on-processcreate">Final reduction touches on Process::create</a></h3>
<p>For Process::create, we have:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
            let mut process: &amp;mut Process&lt;C&gt; =
                &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

            return (
                Some(process),
                0usize,
                0usize,
            );
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>We can simplfy this API by reducing the return type to the core element that matters: the trait object:</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -3045,15 +3045,11 @@ impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
     #[allow(clippy::cast_ptr_alignment)]
     crate unsafe fn create(
         chip: &amp;'static C,
-    ) -&gt; (Option&lt;&amp;'static dyn ProcessType&gt;, usize, usize) {
+    ) -&gt; &amp;'static dyn ProcessType {
             let mut process: &amp;mut Process&lt;C&gt; =
                 &amp;mut *((&amp;mut []).as_mut_ptr() as *mut Process&lt;'static, C&gt;);

-            return (
-                Some(process),
-                0usize,
-                0usize,
-            );
+            process
     }

     #[allow(clippy::cast_ptr_alignment)]
</code></pre>
<p>In fact, we can do even better. The initialization expression on the right-hand side of let mut process = ... is ugly, and its actually completely irrelevant.</p>
<p>In cases like these where we are hitting an ICE, we can use a special kind of “defaultification” to conjure up types without needing any knowledge of their expression.</p>
<hr />
<blockquote>
<p>theme: Trivialize Content</p>
</blockquote>
<h3 id="technique-none-defaulting"><a class="header" href="#technique-none-defaulting">Technique: “None-defaulting”</a></h3>
<blockquote>
<blockquote>
<p>This is yet another case where the fact that we are debugging a compile-time issue is crucial. You obviously cannot be tossing None.unwrap() into code you expect to run usefully.</p>
</blockquote>
</blockquote>
<p>The idea of “none-defaulting” is simple: You need the compiler to think you have a value of type T. But the steps to make an instance of T are not relevant to reproducing the bug. So just make a None::<T>, and unwrap it.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: T = ----;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: T = None.unwrap();
<span class="boring">}</span></code></pre></pre>
<p>In our case, applying this technique to Process::create yields this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) -&gt; &amp;'static dyn ProcessType {
            let mut process: &amp;mut Process&lt;C&gt; = None.unwrap();

            process
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>And compiling this, the ICE still reproduces!</p>
<h2 id="so-where-are-we-now"><a class="header" href="#so-where-are-we-now">So, where are we now</a></h2>
<p>We’ve still got a set of three crates, one of which is over 3,000 lines long.</p>
<p>But we’ve also reduced the set of non-trival functions in that big crate to just three:</p>
<ul>
<li>Process::create,</li>
<li>load_processes, and</li>
<li><Process as ProcessType>::process_detail_fmt.</li>
</ul>
<p>If you think for a momeent, you can see how everything is tying together here: This ICE is occurring in the midst of some step of code-generation. We previously established that in order to observe the ICE, the compiler needs to handle code-generation for the coercion from &amp;Process to a trait object &amp;dyn ProcessType . A method like <Process as ProcessType>::process_detail_fmt is part of the virtual-methods that get their code generated as part of that coercion.</p>
<p>We already showed Process::create is now pretty trivial.</p>
<p>As for load_processes, after doing some additional “unusedification” and “param-elimination” we can get it down to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(
    chip: &amp;'static C,
) {
        unsafe {
            Process::create(
                chip,
            );
        }
}
<span class="boring">}</span></code></pre></pre>
<p>which we might as well rewrite into the one-liner:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(chip: &amp;'static C) { unsafe { Process::create(chip); } }

<span class="boring">}</span></code></pre></pre>
<p>That just leaves <Process as ProcessType>::process_detail_fmt, which we have not looked at yet.</p>
<p>As part of the earlier (undocumented) bisection process on the out-of-line mod process;, I already “simpl-impled” the ProcessType trait declaration, so it looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ProcessType {
    fn appid(&amp;self) -&gt; AppId { loop { } }
    ...
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) { loop { } }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>This means we can remove all of the irrelevant methods from the impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt;, leaving us with just the single method:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        ...
    }
}

<span class="boring">}</span></code></pre></pre>
<p>And since this is now the only impl of ProcessType, we can also remove the other methods from the ProcessType trait itself:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ProcessType {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) { loop { } }
}

<span class="boring">}</span></code></pre></pre>
<p>I cannot stress how satisfying it is to be able to retest the ICE in between each of these steps. It gives you excellent points to pause, get up from the keyboard and take a walk (which is another surprisingly effective debugging methodology).</p>
<p>But we still have the body of fn process_detail_fmt itself, which is about 175 lines of code. So lets try to winnow that down.</p>
<p>“Suffix-bisection” ends up revealing that the ICE is triggered by this bit of code in the method.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    self.mpu_config.map(|config| {
        let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
    });

<span class="boring">}</span></code></pre></pre>
<p>And so we can “expr-eliminate” all the rest, leaving this defintion of the method:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        self.mpu_config.map(|config| {
            let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
        });
    }
}

<span class="boring">}</span></code></pre></pre>
<p>That looks pretty simple (after all, its a a three line body). But its still doing some relatively interesting stuff: there’s that format_args! macro in there, and a closure being constructed.</p>
<p>We might try to simplify the body further: turn the closure body into the main body of process_detail_fmt itself.</p>
<p>The closure takes an input of type config; a quick inspect of the map method shows that should have the same type as is fed into the MapCell here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mpu_config: MapCell&lt;&lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig&gt;,

<span class="boring">}</span></code></pre></pre>
<p>Unfortunately, we quickly discover that just moving the closure body into the process_detail_fmt method is not a valid reduction. That is, I tried compiling with this definition instead:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        let config = None::&lt;&lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig&gt;.unwrap();
        let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
    }
}

<span class="boring">}</span></code></pre></pre>
<p>and got this ICE:</p>
<pre><code>error: internal compiler error: src/librustc/traits/codegen/mod.rs:53: Encountered error `Unimplemented` selecting `Binder(&lt;() as core::fmt::Display&gt;)` during codegen

</code></pre>
<blockquote>
<blockquote>
<p>When reduction uncovers a different bug, it is of course good practice to record that distinct state of the test source code somewhere. E.g. you could make a separate git branch for it, and come back to later.</p>
</blockquote>
</blockquote>
<p>That is certainly a similar looking ICE. But if we want to be sure about our reduction, we really need to see the same error: if we don’t see [FulfillmentError(Obligation(...))], then we should not be satisifed.</p>
<p>So, we apparently have to keep more of the original code from process_detail_fmt.</p>
<p>At this point we must note that MapCell is a type that kernel is pulling in from another crate, tock-cells.</p>
<p>So we might need to go and modify code over in tock-cells if we want to fully reduce this code.</p>
<p>Or we might be able to get away with just copying its definition locally, avoiding the hassle of the full process of reducing the tock-cells crate itself.</p>
<hr />
<blockquote>
<p>themes: Eliminate Coupling, Identify the Unnecessary</p>
</blockquote>
<h3 id="tactic-cut-spaghetti-imports"><a class="header" href="#tactic-cut-spaghetti-imports">Tactic: “Cut-spaghetti-imports”</a></h3>
<p>This is pretty easy: If you’ve “loopified” most of your code, you can often do this replacement.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ...::Type;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type;
<span class="boring">}</span></code></pre></pre>
<p>or, if applicable:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Type = ();
<span class="boring">}</span></code></pre></pre>
<p>If you haven’t done full “loopification” everywhere (our situation), then you may need to do this.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type { ... } // (adapt definition from elsewhere, potentially via cut-and-paste).
impl Type { ... }
<span class="boring">}</span></code></pre></pre>
<p>Note: may need to add (potentially artificial) generic parameters, like so:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ...::Type;
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct&lt;'a, T&gt; Type(&amp;'a (), Option&lt;T&gt;);
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Type&lt;'a, T&gt; = (&amp;'a (), Option&lt;T&gt;);
<span class="boring">}</span></code></pre></pre>
<p>In our case, we are going to make a local version of tock_cells::MapCell.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MapCell&lt;T&gt; {
    val: core::cell::UnsafeCell&lt;core::mem::MaybeUninit&lt;T&gt;&gt;,
    occupied: Cell&lt;bool&gt;,
}
impl&lt;T&gt; MapCell&lt;T&gt; {
    pub fn is_some(&amp;self) -&gt; bool {
        self.occupied.get()
    }
    pub fn map&lt;F, R&gt;(&amp;self, closure: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(&amp;mut T) -&gt; R,
    {
        if self.is_some() {
            self.occupied.set(false);
            let valref = unsafe { &amp;mut *self.val.get() };
            // TODO: change to valref.get_mut() once stabilized [#53491](https://github.com/rust-lang/rust/issues/53491)
            let res = closure(unsafe { &amp;mut *valref.as_mut_ptr() });
            self.occupied.set(true);
            Some(res)
        } else {
            None
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>I got this by cut-and-pasting the definiton for struct MapCell<T> (and then fixing its types so I could avoid adding use statements elsewhere), and then cut-and-pasting its fn map method, and finally cut-and-pasting its fn is_some method after a compilation attempt said that was missing.</p>
<p>With that done, compilation continues to show the ICE.</p>
<p>If you “loopify” the body of MapCell::map, the ICE goes away. There is something relevant inside there.</p>
<p>Some intelligent (as in, non-mechanical) “expr-elimination” and “none-defaulting” gets MapCell::map down to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; MapCell&lt;T&gt; {
    pub fn map&lt;F, R&gt;(&amp;self, closure: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(&amp;mut T) -&gt; R,
    {
            closure(None::&lt;&amp;mut T&gt;.unwrap());
            loop { }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Compilation still shows the same ICE here, so we haven’t lost anything yet.</p>
<p>And yet, this version of map does not use self at all!</p>
<p>This brings us to another kind of simplification: going from object methods to top-level functions.</p>
<hr />
<blockquote>
<p>themes: Identify the Unnecessary, Trivialize Content</p>
</blockquote>
<h3 id="tactic-deobjectification"><a class="header" href="#tactic-deobjectification">Tactic: “Deobjectification”</a></h3>
<p>The goal of “deobjectification” is to replace a method defined in an impl with a top-level function. Moving some necessary component for reproducing the bug out of the impl can make the impl itself unnecessary, and thus removable.</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;X&gt; Type&lt;X&gt; {
    pub fn foo&lt;T&gt;(&amp;self, args: ---) -&gt; ReturnType { --- } // where `---` does not use `Self`/`self`
}

<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn top_foo&lt;X, T&gt;(args: ---) -&gt; ReturnType { --- }

<span class="boring">}</span></code></pre></pre>
<p>In our case, lets try to pull MapCell::map out of MapCell:</p>
<pre><code class="language-diff">--- a/tock/kernel/src/lib.rs
+++ b/tock/kernel/src/lib.rs
@@ -2577,6 +2577,13 @@ impl&lt;T&gt; MapCell&lt;T&gt; {
             loop { }
     }
 }
+
+fn mapcell_map&lt;T, F, R&gt;(closure: F) -&gt; Option&lt;R&gt; where F: FnOnce(&amp;mut T) -&gt; R
+{
+    closure(None::&lt;&amp;mut T&gt;.unwrap());
+    loop { }
+}
+
 use crate::common::{Queue, RingBuffer};
 use crate::mem::{AppSlice, Shared};
 use crate::platform::mpu::{self, MPU};
@@ -2719,7 +2726,7 @@ pub struct Process&lt;'a, C: 'static + Chip&gt; {

 impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
     unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
-        self.mpu_config.map(|config| {
+        mapcell_map(|config: &amp;mut &lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig| {
             let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
         });
     }
</code></pre>
<p>Success: compilation still ICE’s in the same way.</p>
<p>And now that we’ve remove the last uses of fields in self for Process, we can simplify its definition considerably:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Process&lt;'a, C: 'static + Chip&gt; {
    chip: &amp;'static C,
    tasks: &amp;'a (),
}

<span class="boring">}</span></code></pre></pre>
<p>(And that simplification lets us remove the struct MapCell we added a few steps ago, since we no longer need it for the now-eliminated mpu_config field.)</p>
<p>So now we’ve reduced all three methods to pretty simple bodies; we had to add a fourth method (mapcell_map) in the process; but that method was always there all along as part of the puzzle. It had just been waiting for us in the upstream tock-cells crate.</p>
<p>Furthermore, we can apply “ret-elimination” to mapcell_map, both on the fn mapcell_map itself, and on its closure argument:</p>
<pre><code class="language-diff">--- INDEX/tock/kernel/src/lib.rs
+++ WORKDIR/tock/kernel/src/lib.rs
@@ -2564,10 +2564,9 @@ use core::{mem, ptr, slice, str};

 use crate::callback::{AppId, CallbackId};
 use crate::capabilities::ProcessManagementCapability;
-fn mapcell_map&lt;T, F, R&gt;(closure: F) -&gt; Option&lt;R&gt; where F: FnOnce(&amp;mut T) -&gt; R
+fn mapcell_map&lt;T, F&gt;(closure: F) where F: FnOnce(&amp;mut T)
 {
     closure(None::&lt;&amp;mut T&gt;.unwrap());
-    loop { }
 }

 use crate::common::{Queue, RingBuffer};

</code></pre>
<p>We have now gotten ourself down to the following core set of methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn mapcell_map&lt;T, F&gt;(closure: F) where F: FnOnce(&amp;mut T)
{
    closure(None::&lt;&amp;mut T&gt;.unwrap());
}

...

pub fn load_processes&lt;C: Chip&gt;(chip: &amp;'static C) { unsafe { Process::create(chip); } }

pub struct Process&lt;'a, C: 'static + Chip&gt; {
    chip: &amp;'static C,
    tasks: &amp;'a (),
}

pub trait ProcessType {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) { loop { } }
}

...

impl&lt;C: Chip&gt; ProcessType for Process&lt;'a, C&gt; {
    unsafe fn process_detail_fmt(&amp;self, writer: &amp;mut dyn Write) {
        mapcell_map(|config: &amp;mut &lt;&lt;C as Chip&gt;::MPU as MPU&gt;::MpuConfig| {
            let _ = writer.write_fmt(format_args!(&quot;{}&quot;, config));
        });
    }
}

...

impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) -&gt; &amp;'static dyn ProcessType {
            let mut process: &amp;mut Process&lt;C&gt; = None.unwrap();

            process
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<blockquote>
<p>theme: Eliminate Coupling</p>
</blockquote>
<h3 id="technique-ret-ascription"><a class="header" href="#technique-ret-ascription">Technique: “Ret-ascription”</a></h3>
<p>We could further reduce Process::create a tiny bit: We can remove its return type, as long as we ensure that the coercion implied by the return type still happens in the code.</p>
<p>This is a variant on “ret-elimination”: we again want to remove the return type from the fn signature, but this time we will also ensure that any coercions implied by the return type still occur:</p>
<p>Change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) -&gt; ReturnType { if A { return B; } TailReturn }
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(----) { if A { let _: ReturnType = B; } let _: ReturnType = TailReturn; }
<span class="boring">}</span></code></pre></pre>
<p>For Process::create, this looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: 'static + Chip&gt; Process&lt;'a, C&gt; {
    #[allow(clippy::cast_ptr_alignment)]
    crate unsafe fn create(
        chip: &amp;'static C,
    ) {
        let mut process: &amp;mut Process&lt;C&gt; = None.unwrap();

        let _: &amp;'static dyn ProcessType = process;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And furthermore, we can apply “deobjectification” and “param-elimination” here; this method doesn’t even have a self parameter.</p>
<p>That gets us here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_processes&lt;C: Chip&gt;(_: &amp;'static C) { process_create::&lt;C&gt;(); }

fn process_create&lt;C: 'static + Chip&gt;() {
    let _: &amp;'static dyn ProcessType = None::&lt;&amp;mut Process&lt;C&gt;&gt;.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="take-a-breath"><a class="header" href="#take-a-breath">Take a breath</a></h2>
<p>Now that all of the involved methods seem relatively small, this seems like a good time to take a breath.</p>
<p>At this point, we could try to take these pieces and build-up a new example from scratch, preserving the core elements identified above. That’s not a bad idea at all, at this point; it could be worth spending a half-hour or so on. Either building up an example from scratch will work, or it won’t. Let’s assume for now that we are not able to jump to a minimal example, even with the pieces we have identified as core to the problem up above?</p>
<p>What now?</p>
<p>We could attempt to remove large swaths of code from the example as it stands: After all, we know we just need these methods; can we just comment everything else out?</p>
<p>Well, no. You can’t just comment random things out. The interdependencies in the crate graph will frustrate attempts to do so.</p>
<p>For example, I tried commenting out most of the code after the mod process { ... }, in the lib.rs, and got a slew of “unresolved import” errors. So, if you want to continue reducing this exmaple, we need to do it in a more directed fashion.</p>
<p>In the interest of trying to follow a semi-mindless process here, lets look at what we need to do in order to really minimize kernel to its core:</p>
<ol>
<li>We have to finish minimizing the leaves. There are crates unrelated to the ICE still being pulled into the build here, and they rely on things in kernel that we will not be able to remove until those crates are themselves reduced or otherwise eliminated from the crate graph.</li>
</ol>
<p>For us, we can apply some of the other techniques we have learned about to the leaf crates, such as using “none-defaulting” to create an instance of arty_e21::chip::ArtyExx in board/argy-e21/main.rs.</p>
<ol start="2">
<li>We have to reducing the coupling within kernel itself. It can be maddening trying to comment out modules at random. When that madness becomes too much for me, I force myself to adopt a more disciplined approach: I use the “cut-spaghetti-imports” tactic to replace the existing use imports with local definitions. (Remember: since most fn-items in every module are “loopified”, the “cut-spaghetti-imports” tactic will work fairly often.</li>
<li>This goes hand-in-hand with the general point above about reducing coupling within kernel: We have to finish mimimizing mod process { ... } itself within kernel. All of the interesting functions for reproducing the bug live there, so we know we cannot “cfgment” out that module for now. But if we have to keep mod process, we won’t be able to remove the other modules until we remove the dependencies that it has on those modules.</li>
</ol>
<p>I hope to return to this richly-documented minimization of rust-lang/rust#65774 the future; and when I do, I hope to cover all three of the points above.</p>
<p>But for now, I hope this was a helpful tour of various minimization technique that you can employ for reducing ICEs and other static analysis bugs in rustc.</p>
<h2 id="refer-37"><a class="header" href="#refer-37">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p>后续值得细读的:</p>
<ul>
<li><a href="http://blog.pnkfx.org/blog/2022/05/12/linking-rust-crates/">Linking Rust Crates, Part 1 - The {pnk}f(eli)x Blog</a></li>
<li><a href="http://blog.pnkfx.org/blog/2022/01/10/why-i-use-a-debugger/">Why I use a debugger - The {pnk}f(eli)x Blog</a></li>
<li><a href="http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/">Breaking News: Non-Lexical Lifetimes arrives for everyone - The {pnk}f(eli)x Blog</a></li>
<li><a href="http://blog.pnkfx.org/blog/categories/turbowish/">Category: turbowish - The {pnk}f(eli)x Blog</a></li>
<li>...</li>
</ul>
<h2 id="logging-25"><a class="header" href="#logging-25">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230228 ZQ init.</li>
</ul>
<pre><code>     _~^*~~_
 \/ /  * ◷  \ \/
   '_   ⏡   _'
   \ '--+--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate中合理划分目录"><a class="header" href="#crate中合理划分目录">Crate中合理划分目录</a></h1>
<blockquote>
<p>tips...重要也不重要</p>
</blockquote>
<h2 id="background-25"><a class="header" href="#background-25">background</a></h2>
<p><a href="tip//dev/cli_ferris_art.html">Ferris艺术</a> 中触发的灵魂问题...</p>
<h2 id="goal-31"><a class="header" href="#goal-31">goal</a></h2>
<p>比如当前 crate 目录:</p>
<pre><code>foo/
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── bar1/
│   │   └── echo.rs
│   ├── bar1.rs
│   ├── bar2/
│   │   └── echo.rs
│   ├── bar2.rs
│   └── main.rs
...
</code></pre>
<p>在两个 echo.rs 中都有相同函数不过内容不同:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//src/bar1/echo.rs:
pub fn bang() {
    println!(&quot;src/bar1/echo.rs: {}&quot;, env!(&quot;CARGO_PKG_VERSION&quot;));
}

//src/bar2/echo.rs:
pub fn bang() {
    println!(&quot;src/bar2/echo.rs: {}&quot;, env!(&quot;CARGO_PKG_VERSION&quot;));
}
<span class="boring">}</span></code></pre></pre>
<p>如何能自如的:</p>
<ul>
<li>在 main.rs 中调用 bar1,bar2 中的对象?</li>
<li>在 bar1/echo.rs 中又如何调用 bar2/echo.rs 中的对象?</li>
<li>...以及为什么?</li>
</ul>
<h2 id="trace-27"><a class="header" href="#trace-27">trace</a></h2>
<p>按照 Python 中的经验, 进行了尝试, 越调越乱;</p>
<p>直到搜索到: <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">Cargo Targets - The Cargo Book</a></p>
<p>才明从根儿上就忽略了一点:</p>
<pre><code>一个包可以包含多个二进制 crate 项和一个可选的 crate 库
</code></pre>
<p>就是那个 <code>一个</code> 可选....</p>
<p>所以,必须要从一开始先整理好目录结构, 才可能开展自由分组,
要追加唯一的 <code>lib.rs</code> 变成:</p>
<pre><code>foo/
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── bar1/
│   │   └── echo.rs
│   ├── bar1.rs
│   ├── bar2/
│   │   └── echo.rs
│   ├── bar2.rs
│   ├── lib.rs       &lt;=== 关键配置
│   └── main.rs
...
</code></pre>
<p>在 Cargo.toml 中追加配置:</p>
<pre><code class="language-toml">[lib]
path = &quot;src/lib.rs&quot;
</code></pre>
<p>然后,关键技巧来了:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod bar1;
pub mod bar2;

//  使用 pub use 重导出名称
pub mod echos{
    pub use super::bar1::echo::*;
    pub use super::bar2::echo::*;
}
<span class="boring">}</span></code></pre></pre>
<p>也就是说在合法的 库文件中,
将不同目录中的模块通过在一个重新定义的模块中,
重新拉到名称空间中, 并 pub ,
这才, 才能让平行的不同目录中的各模块可见,</p>
<p>这时, 才能在 <code>src/bar1/echo.rs</code> 中通过 <code>super::super::bar2</code> 形式引用到隔壁的资源...</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::super::bar2::echo::bang as bar2_echo_bang;

pub fn bang() {
    println!(&quot;src/bar1/echo.rs: {}&quot;, env!(&quot;CARGO_PKG_VERSION&quot;));
    bar2_echo_bang();
}
<span class="boring">}</span></code></pre></pre>
<p>当然, 如果两个 echo 中的 bang() 相互引用,就变成了经典的 OOP 中的菱形循环引用:</p>
<pre><code>use super::super::bar2::echo::bang as bar2_echo_bang;
          ^                   +
         /                     \
        /                       V
src/bar1/echo.rs            src/bar2/echo.rs
-&gt; bang()                   -&gt; bang()
        ^                       /
         \                     /
          +                   V
use super::super::bar1::echo::bang as bar1_echo_bang;

</code></pre>
<p>在编译运行后将进入死循环, 直到 stack overflow 爆出:</p>
<pre><code>...
src/bar2/echo.rs: 0.1.42
src/bar1/echo.rs: 0.1.42
src/bar2/echo.rs: 0.1.42
src/bar1/echo.rs: 0.1.42
src/bar2/echo.rs: 0.1.42
src/bar1/echo.rs: 0.1.42
src/bar2/echo.rs: 0.1.42
src/bar1/echo.rs: 0.1.42

thread 'main' has overflowed its stack
fatal runtime error: stack overflow
Abort trap: 6
</code></pre>
<p>综上, 在项目扩大时, 还是将关键组件都 crate 化,
变成标准的外部或是本地 crate ,再调教好 build 过程,
那么, 无论多大的工程, 最后都可以控制在一小组文件中, 
组合调用已经安全无忧编译好的 crate 们....</p>
<h2 id="refer-38"><a class="header" href="#refer-38">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p><a href="https://kaisery.github.io/trpl-zh-cn/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#%E4%BD%BF%E7%94%A8-pub-use-%E9%87%8D%E5%AF%BC%E5%87%BA%E5%90%8D%E7%A7%B0">使用 use 关键字将路径引入作用域 - Rust 程序设计语言 简体中文版</a> -&gt; 使用 pub use 重导出名称</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1899628">Rust中的代码组织:package/crate/mod - 腾讯云开发者社区-腾讯云</a></li>
<li><a href="http://llever.com/gentle-intro/pain-points.zh.html">模块和货物 - Rust 的绅士介绍</a></li>
<li>...</li>
</ul>
<pre><code>          _~∽|^~_
      () /  - ♡  \ \/
        '_   ⌐   _'
        \ '--∽--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-和默认参数"><a class="header" href="#rust-和默认参数">Rust 和默认参数</a></h1>
<p>原文: <a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></p>
<blockquote>
<p>快译</p>
</blockquote>
<p>Rust 不支持函数声明中的默认参数;
而且和很多语言不同, 无法通过函数重载来模拟;
这让很多来自其它编程语言的 Rustacean 新人感到沮丧,
所以, 就想解释一下为什么这其实是件好事儿,
以及,如果使用默认 trait 和结构更新语法来实现类似的效果;</p>
<p>默认参数(和函数重载)不是面向对象编程的一部分,
但是,又是许多 Rustaceans 新人原先编程语言的共同特征;
因此, 这篇文章在某些方面和我正在进行的关于 Rust 如何不是面向对象的系列文章相吻合,
故而, 被标准为这个系列的文章;
还受到 Reddit 中对我第一篇 OOP 相关贴子回复的启发;</p>
<h2 id="默认参数是如何工作咯比如-c"><a class="header" href="#默认参数是如何工作咯比如-c">默认参数是如何工作咯(比如 C++)</a></h2>
<p>在开始讨论为什么 Rust 没有默认参数以及我们可以折腾什么之前,
得先聊明白什么是默认参数以及在哪些情况下有用;</p>
<p>假设你有一个带有很多参数的函数,
比如(以 Reddit 回复中的示例)在 GUI 中创建一个窗口:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible)

auto handle = createWindow(10, 30, false); // Create invisible window
auto handle2 = createWindow(100, 500, true); // Create visible window
</code></pre>
<p>现在, 假设你准备创建的大多数窗口都是可见的,
并且,你不想让程序员负担必须指定窗口是否可见的担心 --- 甚至于不想明确的考虑这事儿 --- 在正常情况下,
在支持默认参数的编程语言中,你可以为可见性提供默认值:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true)

auto handle = createWindow(10, 30, false); // Create invisible window!

auto handle2 = createWindow(100, 500, true); // Create visible window!

auto handle3 = createWindow(100, 500); // Also create visible window!
auto handle4 = createWindow(100, 500); // Most of the time, that's what
auto handle5 = createWindow(100, 500); // you want, so why have to say it?
Default parameters can also be simulated with function overloading for programming languages where function overloading is available but default parameters are not:

WindowHandle createWindow(int width, int height, bool visible);

WindowHandle createWindow(int width, int height) {
    return createWindow(width, height, true);
}
</code></pre>
<p>Rust 也没有函数重载,这是个复杂的多的问题,
但是, 很多相同的论点都适用这个习惯用法的理解;</p>
<h2 id="默认参数的好处和坏处"><a class="header" href="#默认参数的好处和坏处">默认参数的好处(和坏处)</a></h2>
<p>默认值很好,这种风格的默认参数是实现并从中获益的一种方式;</p>
<p>默认值是好的,因为,她们坚持 DRY 原则 --- 不要重复自己(Don’t Repeat Yourself);
如果我们没有默认值, 就不得不重复那些实际上对理解代码没有帮助的参数;
如果最佳默认秋粮的更改方式楼主更新代码的最佳方法是继续使用默认值--- 也许因为最佳实践发生了变化 ---
我们将不得不更新每个调用, 而不是只要更改一处, 定义了默认参数那里;</p>
<p>默认徝很好,因为,她们减少了程序员的认知负担;
程序员必须一次性在大脑中保留大量信息,
而默认设置通过不强迫在无关场景时要考虑额外的细节来帮助程序员---这是太多数默认设置的常见作用场景;</p>
<p>默认秋粮也使代码更加简洁,
因此, 很受欢迎;
但是,这不是专有的特殊价值;
我相信 DRY 原则很重要, 这通常意味着更加简洁的代码,
但是,考虑到现代编辑器和 IDE, 以及现代人劝为把不用又和阅读速度的期待,
适度的冗长以能换取其它好处(比如, 清晰度和明确性),
我还是完全可以接受的;
相信默认参数,因为这是在 C++ 和 Python 中实现的,
在清晰度和明确性方面付出了巨大的代价,
因此,简洁性并不是证明她们合理的充分理由;</p>
<p>在这种情况中, 让我特别困扰的是代码中的不清晰之处,
在于代码的读者不知道可能还有更多的参数;
没有暗示可能还有其它秋粮;
如果维护者想更改其中一个调用以便创建不可见的窗口,
领导作用可能没有意识到应该先检验 create_window 的文档:
毕竟, 似乎只接受两个参数,
而且也没有任何远程反应针对不可见窗口;</p>
<p>幸运的是, Rust 具有替代特性,
使我们能在不牺牲明确性和清晰性的情况下,
也获得认知负荷和 DRy 的好处;</p>
<h2 id="rust-中的默认值-默认-trait"><a class="header" href="#rust-中的默认值-默认-trait">Rust 中的默认值: 默认 trait</a></h2>
<p>Rust 不允许使用默认参数,
而是允许你使用 Default trait 有选择的为你的类型指定默认值;</p>
<p>是这样工作的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
}

impl Default for Foo {
    fn default() -&gt; Self {
        Foo::Bar
    }
}
<span class="boring">}</span></code></pre></pre>
<p>或是, 使用更加简洁的 派生/derive 语法编写:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum Foo {
    #[default]
    Bar,

    Baz,
}
<span class="boring">}</span></code></pre></pre>
<p>一旦定义了这个默认值,
Foo::default() 或是(在类型明确的上下文中) Default::default() 就可以代表 Foo::Bar ;</p>
<p>如果你习惯为你的函数参数重用现有类型,
这可能看起来比不用更加糟糕;
毕竟, 我们默认的参数是 bool 类型的,
孤儿规则(在 Rust 的 trait 相关章节有解释) 禁止我们在 bool 上定义默认 trait ---
正如我在上面提及的, Default 允许你对类型定义默认值;
即便,我们可以为 bool 设置默认值也是一件过于强大的事儿,
无法仅仅为这个函数参数提供默认值!
毕竟, 其它一些函数也可能有一个具有不同默认值的 bool 类型参数;</p>
<p>但是,如果在 Rust 中考虑, 这更加有意义 --- 甚至是惯用的和首选的 --- 为配置和函数参数等等创建自定义类型;
毕竟, 如果你不查实文档, 可能不清楚 true 的含义;
甚至于不清楚和可见性有什么关系,
更不用说很容易将 true 当参数时意味着不可见窗口是可见的;</p>
<p>在 Rust 中,我们更加愿意为这一情况定义一个新类型, 一个列出可见性选项的枚举---如果创建一个新的可见性选项,
这才有所帮助;
在这个枚举上, 声明一个默认值才是合理的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum WindowVisibility {
    #[default]
    Visible,

    Invisible,
}
<span class="boring">}</span></code></pre></pre>
<p>是的, 这比我们的原始代码有些冗长, 但更清晰,
而且不乏 DRY ;
简洁本身并不是一种价值;
明确的列出选项比隐式选项更可取;</p>
<p>然后, 当我们调用该函数时, 可以这么使用默认值:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_window(width: u32, height: u32, visibility: WindowVisibility) -&gt; WindowHandle;

let handle = create_window(10, 30, WindowVisibility::Invisible);
let handle2 = create_window(100, 500, WindowVisibility::Visible);

let handle3 = create_window(100, 500, WindowVisibility::default());
let handle4 = create_window(100, 500, WindowVisibility::default());
let handle5 = create_window(100, 500, Default::default()); // 也允许
<span class="boring">}</span></code></pre></pre>
<p>正如承诺的那样, 这样冗长些, 同样 DRY,
但是, 更加明确和清晰; (无歧义)</p>
<p>注意: 我使用独立函数只是为了举例;
实际上, 这个特定函数很可能是类型内部方法的一部分,
例如 WindowHandle::new 或是 WindowHandle::create_window;</p>
<h3 id="rust-中默认值缩放-结构更新语法"><a class="header" href="#rust-中默认值缩放-结构更新语法">Rust 中默认值缩放: 结构更新语法</a></h3>
<p>所以, 这对于一个默认值来说形式上更好;
但是,拓展性并不好;
如果我们想在我们的窗口创建函数中追加另外3个参数怎么办?
在 C++ 中, 可以可以为她们提供默认值,
调用者甚至不需要更新(参数仅用来示例, 并不代表在创建窗口):</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true,
                          WindowStyle windowStyle = WindowStyle::Standard,
                          int z_position = -1,
                          bool autoclose = false);

createWindow(100, 500); // Still works identically
createWindow(100, 500, false); // Also still works
createWindow(100, 500, false, WindowStyle::Standard, 2, true); // Specify everything
</code></pre>
<p>这是一个有用的功能;
在 Rust 中,使用目前讨论的技术,
无论参数有多少,我们都必须重复编写 Default::default() ;
这是 DRY 违规行为, 会干挠追加新参数的能力;</p>
<p>但是, 此功能也存在缺陷;
你现在已经限制自己在左侧指定参数,
以便在右侧追加参数;
在调用 createWindow 最后一个示例中, 我们通过显式指定一个值来违反 DRY,
当时我们可能想使用默认值,但是,该值不可用, 因为,我们想为以后的参数覆盖默认值;</p>
<p>幸运的是, Rust 也有这种版本;
正如我们只是为了这个函数调用而创建了一个枚举一样,
在 Rust 中为这种配置参数创建结构也是惯用的;
该结构看起来像这样:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowConfig {
    pub width: u32,
    pub height: u32,
    pub visibility: WindowVisibility,
    pub window_style: WindowStyle,
    pub z_position: i32,
    pub autoclose: AutoclosePolicy,
}
<span class="boring">}</span></code></pre></pre>
<p>然后, 我们就可以为整个结构指定 Default:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for WindowConfig {
    fn default() -&gt; Self {
        Self {
            width: 100,
            height: 100,
            visibility: WindowVisibility::Visible,
            window_style: WindowStyle::Standard,
            z_position: -1,
            autoclose: AutoclosePolicy::Disable,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>现在, 似乎使用起来很乏味;
你可能想象得这么使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = WindowConfig::default();
config.width = 500;
config.z_position = 2;
config.autoclose = AutoclosePolicy::Enable;
let handle = create_window(config);
<span class="boring">}</span></code></pre></pre>
<p>我认为即便是这样也比默认秋粮可取,
因为,这样是明确的;
然而, Rust 有一个专门为这种情况设计的语法结构:
struct update syntax ;
有了这,我们获得的东西和默认参数非常相似,
但是,更冗长/明确/灵活:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = create_window(WindowConfig {
    width: 500,
    z_position: 2,
    autoclose: AutoclosePolicy::Enable,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<p>不像 C++ 风格的言论参数,
我们可以完全覆盖我们想要的默认值;
同样明确的是,
如果我们愿意, 甚至可以修改其它参数,
而不需强制维护开发者检查文档;</p>
<p>除此之外, 这样允许定义其它默认值集;
除了 WindowConfig::default 之渑, 可能还有另外一组用来创建对话框的配置参数,
例如: like WindowConfig::dialog() 或是 WindowConfig::default_dialog ;
程序员通常在创建不可见窗口, 或是高度相同的窗口应用,
可能会定义自己的默认设置, config::app_local_default_window_config();
这些不会通过 Default 特性来调解,
但是, Default 只是一个 trait ,
而 Default::default() 是一个方法调用;
你可以改为调用自己的方法,
并仍然使用此<code>结构更新语法</code>;</p>
<p>所以,现在我们在 Rust 中有一个习惯用语系统来替换默认参数;
这和 DRY 一样,
并且同样减少了认知负荷;
更加重要的是, 这样作并没有牺牲对到底发生了什么的明确性与清晰性 --- 一个给定的函数总是采用相同数量的参数,
这是 Rust 维护开发者可以(并且正在)依赖的不变量;</p>
<h3 id="构建器模式"><a class="header" href="#构建器模式">构建器模式</a></h3>
<p>在这点上, Rustacean 老手们应该能注意到还没讨论一种通用的 Rust 方法来设计这些配置结构,
即:  <code>构建器模式</code> (Builder Pattern);</p>
<p>这是有原因的: 我不喜欢丫的;
(译按: 千金婎买我愿意, 没错...)
我个人更加喜欢使用 Default 和 struct update 语法,
其它人可能会使用  <code>构建器模式</code>  ;
我认为这种模型不够明确, 而且由于在非 OOP 编程语言方面有很多经验,
所以,我觉得这是一种没有问题的解决方案, 主要成果只是令代码看起来更加 OOP 而已;</p>
<p>不过, 这也是 Rust 中常用的模式, 一般使用 <code>构建器模式</code> 的 crate,
因而值得熟悉之;
这和以往的概念相同:
使用充满参数的结构, 将配置发送到 构建函数或是函数调用;
有时这种会被称为 WindowBuilder 而不是 WindowConfig;</p>
<p>但是, 不直接使用结构更新语法, 而是添加了一堆辅助方法来执行结构更新:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>或者, 正如想指出的那样:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(self, height: u32) -&gt; Self {
        Self {
            height,
            ..self
        }
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>有时, 枚举被拆分为多个更新方法:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn autoclose_enable(mut self) -&gt; Self {
        self
        self.autoclose = AutoclosePolicy::Enable;
    }

    fn autoclose_disable(mut self) -&gt; Self {
        self.autoclose = AutoclosePolicy::Disable;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然后, 通常并不是调用例如: window constructor,
你调用在构建器上定义的构建方法
(此时,已经对影响设计的无偿 OOP 哲学感到畏缩)</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn build(self) {
        window_create(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>其实,不用 struct update 语法,
而是将对这些方法调用链接在一起:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = WindowBuilder::new()
    .width(500)
    .z_position(2)
    .autoclose_enable()
    .build();
<span class="boring">}</span></code></pre></pre>
<p>我仍然更加喜欢这个, 而不是默认参数,
但是, 同时也感觉有点俗气;
我不喜欢被迫使用像 构建器 这样的抽象&quot;对象&quot;来思考,
也不喜欢这种风格中更直观的假设;
为什么 &quot;构建器&quot; 是作某件事儿的对象?
为什么它比&quot;配置&quot;结构更受欢迎?
OOP 程序员是否意识到在现实生活中, 绝大多数对象根本不作任何事儿,
当然, 也不会构建其它对象?</p>
<p>但是, 对于熟悉 OOP 习惯用法的人来说,
这可能更可取;
这是一个普通选择的选项, 因此, 至少识别这种模式很重要;</p>
<h2 id="结论和应用"><a class="header" href="#结论和应用">结论和应用</a></h2>
<p>Rust 有很多不同于其它语言的习惯;
我经常看到新的 Rustacean 提议为 Rust 添加默认参数和其它类似的功能,
而这些新 Rustacean 感到困惑的是, 
领导作用感受到的强烈要求在更大的 Rust 社区中并没有被广泛感受到;</p>
<p>通常, 这和默认参数类似;
有实现相同目标的替代习语, 嘦这些目标符合 Rust 的价值观:
在此场景中, DRYness 并减少开发者认知负担;
根据 Rusty 的价值观, 她们在其它方面也是更好的解决方案: 额外的明确性值得多点冗长代码;</p>
<p>所以, 我希望这可以作为一个案例研究来报时大家理解,
通常总是有 Rusty 的方法来实现 OOP 领域流行功能目标,
以及, 为什么 Rustacean 更加喜欢这些方案而不是盲目的积累新功能;</p>
<h2 id="logging-26"><a class="header" href="#logging-26">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230220 ZQ v0 DONE</li>
<li>230212 ZQ init.</li>
</ul>
<pre><code>          _~∽&amp;∽~_
      \/ /  ^ o  \ \/
        '_   ▽   _'
        / '--⌄--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-超越面向对象第1部分"><a class="header" href="#rust-超越面向对象第1部分">Rust 超越面向对象,第1部分</a></h1>
<p>原文: <a href="https://www.thecodedmessage.com/posts/oop-1-encapsulation/">Rust Is Beyond Object-Oriented, Part 1: Intro and Encapsulation :: The Coded Message</a></p>
<h2 id="快译-1"><a class="header" href="#快译-1">快译</a></h2>
<p>是的, Rust 不是一种 OOP 编程语言;</p>
<p>Rust 可能看起来像一种 OOP 编程语言:
类型可以和 &quot;“methods&quot; 关联,
可以是 &quot;intrinsic&quot; 的或是通过 &quot;traits&quot;;
通常可以使用 C++ 或是 Java 风格的 OOP 语法调用方式:
map.insert(key, value) 或 foo.clone();
就像在 OOP 语言中一样,
此语法涉及放置在调用者的 <code>.</code> 中, 而在被调用者中称为 self;</p>
<p>但请不要误会: 尽管 Rust 可能借用了一些技巧/术语和语法,
但是, Rust 并不是一种面向对象的编程语言;
面向对象编程的三大支柱理念: 封装/多态/继承;
其中, Rust 完全否决了 继承,
因此, 永远不可能成为&quot;真正的&quot; OOP 语言;
不过, 即便对于封装和多态, Rust 实现的方式也和 OOP 语言不同 --- 稍后将对此进行更加详细的介绍;</p>
<p>这一切都让很多程序员感到惊讶以及无措;
我在 Reddit 上看到 Rust 新手询问如何按字面意思实现 OOP 设计模式,
试图获得像“shapes” 或是 “vehicles”这种&quot;类层次结构&quot;,
使用作为&quot;Rust 版本继承&quot;的 traits --- 换句话说, 
试图解决他们想象中的问题, 
因为, 他们致力于 OOP 方法, 并通过构建人为的 OOP 示例来尝试了解他们期待的应该存在的另外一个版本 Rust;</p>
<p>这对很多人来说是一个绊脚石;
我经常看到 Rust 新手和怀疑论者在互联网上提到&quot;缺乏OOP&quot;,
这是 Rust 难以适应/不合适他们的关键原因,
甚至是 Rust 永远不会流行的原因;
对于那些在 OOP 的高度来学习编程的人来说 --- 当像 C 和 ML 那样完美的语言都必须变成 Object-C 和 OCaML 这种面向对象的语言 --- 
对非 OOP 语言的大量炒作感觉就不太香了;</p>
<p>这也不是一个容易的调整;
如此多的程序猿以明确的面向对象的方式学习软件设计和体系结构;
我看到一个又一个问题,
一个初级或中级 Rust 程序员想要作一个面向对象的事儿,
并想要一个字面上的 Rust 等价物;
通常, 这些都是经典的 &quot;XY 问题&quot; (原文:<a href="https://xyproblem.info/">XY problem</a>, 酷壳有精采的翻译:<a href="https://coolshell.cn/articles/10804.html">X-Y Problem | 酷 壳 - CoolShell</a>)案例, 他们很难调头用更 Rusty 的方式解决问题;</p>
<p>这其实都不是 Rust 的错;
答案还是要我们去调整,
虽然不容易;
我们要成为更好的程序员, 不仅精通多种语言,
而且要精通不同的编程范式;</p>
<p>而且, 作为一种范式, OOP 实际上非常平庸 --- 以至于我写了一整篇文章来解释为什么,
以及为什么 Rust 的方法更好;</p>
<h3 id="面向对象思想"><a class="header" href="#面向对象思想">面向对象思想</a></h3>
<blockquote>
<p>OOP Ideology</p>
</blockquote>
<p>嗯哼,好象明白了;
我曾经是自己主动变成 OOP 信徒的;
还记得当年是如何向我们收费的:
不仅仅是一套代码组织实践,更加是编程方面的一场革命;
OOP 方法被认为更直观,尤其对非程序员而言, 因为更加符合我们对自然世界的看法;</p>
<p>对于这种营销的典型示例, 以下是流行杂志(Byte Magazine, 1981年)中关于 OOP 第一篇公开文章的摘录:</p>
<hr />
<blockquote>
<p>许多不知道计算机如何工作的人发现 OOP 想法很自然;
相比之下, 反而是很多有计算机经验的人最初认为 OOP 系统有些奇怪...</p>
</blockquote>
<hr />
<p>为 OOP 买帐很容易;
当然, 我们的日常生源没有任何子程序或是变量之类的东西 --- 或者,
即便有, 我们也没有明确的考虑它们!
但是, 生活中确实有我们可以与之交互的对象, 每个对象都有自己的功能;
怎么可能不直观呢?</p>
<p>这是非常引人注目的伪认知科学,轻研究,重说服力;
这些 object/对象 可以认为是 &quot;agents&quot;, 几乎象人一样,
所以, 你可以利用你的社交技能来处理它,
而不仅仅是分析性思维
(嫑介意 object/对象 的行为一点儿也不像人,而且,实际上在某种程序上更加笨,
这时仍然需要分析思维);
或是, 你可以将对象和类视为形式世界本身的近乎柏拉图式的表达, 使其在哲学上引人注目;</p>
<p>哦, 当年我是如何接受的? 尤其是在肆意鲁莽的青年时期；
我个人吸收了 OOP 和柏拉图之间的联系;
深入研究了元对象协议, 
以及在 Smalltalk 中每个类都必须有一个元类的事实;
Smalltalk 代码元类的概念对我来说几乎是神秘的,
因为, 任何值都可以组织在同一层次结构中,
对象反而位于其根部;</p>
<p>我赢得在一本书中读到 OOP 风格的多态使得 if-else 语句变得多余,
因此,我们应该努力最终只使用 OOP 风格的多态;
不知何故, 这没让我失望, 这让我当时很兴奋;
而且,当我了解到 Smalltalk 实际正是这样作的,
就更加兴奋了
(如果你忽略优化掉某些抽象的实现细节):
在 Smalltalk 中, if-than-else 的概念是通过 ifTrue: 和 ifElse: 以及 ifTrue:ifFalse: 等方法实现的,
还得配套单实例的 True 和 False 类,以及其全局对象 true 和 false;</p>
<p>(译按: 光是听起来就非常,嗯哼? 这不是一样的东西嘛?)</p>
<p>作为一名更成熟的程序员,接触到意识形态较少的 C++ OOP 以及 Haskell 中的函数式编程替代方案后,
我的立场就软化了, 然后, 发生了巨大转变, 现在我几乎不再是 OOP 的脑残粉,
尤其是当其最佳思想已经在 Haskell 和 Rust 中进行了更新综合;
我已意识到这种对新程序员的炒作对于任何范式都是典型的(FUD ~ Fear/Uncertainty/Doubt, 意为:懼、惑、疑, 现在统称为 PUA 技术);
对于新手来说, 任何新编程范式都来了使用不同范式的资深程序员更加直观;
函数式编程也是如此;
甚至对于 Rust 也有同样的说法;
其实和范式是否更好并无太大的关系;</p>
<p>至于 if-else 语句完全用多态来替换,
好吧, 很容易想出一组图灵完备的元语;
你不邕为用多态来模拟 if 语句以及 true;
你还可以模拟带有递归的 shile 循环,
又或是带有 while 循环和堆栈的递归；
你可以使用 while 循环模拟 if 语句;</p>
<p>这些事实都不能使用这种替代成为一个好主意;
对于不同的情况, 编程语言中存在不同的特性,
适度的对应使用, 实际上原本就是一件好事情;</p>
<p>毕竟,编程的目的是编写程序, 而不是证明图灵完备性/哲学研究又或是写概念诗;</p>
<p>(译按: 不过, 现实中的确有这类研究僧, 主要社会贡献就是制造新概念哪...)</p>
<h3 id="实用性"><a class="header" href="#实用性">实用性</a></h3>
<blockquote>
<p>Practicality</p>
</blockquote>
<p>因此, 在这个系列文章中, 我打算从实际角度评估 OOP,
作为一名程序猿, 在使编程语言在认知上更易于管理或是更容易进行抽象方面具有经验;
我将根据我解决实际编程问题的经验来进行评估 --- 我认为这是种不好的迹象,
很多 OOP 抽象如何工作的案例只有在真正高级的程序中才有意义,
或是关于动物园中不同类型的形状或是动物的人为例子才有意义;</p>
<p>和大多数 OOP 介绍不同, 我不会关注 OOP 和 OOP　之前的编程语言的比较；
相反, 我将主要和 Rust 进行比较,
Rust 从 OOP 中汲取了很多好想法,
也许还会和函数式编程语言(比如 Haskell)进行比较;
这些编程语言采纳了 OOP 的一些好想法,
但是, 都以一种修复缺陷并进一步超越的姿态, 对合理的 OOP 进行了改造;</p>
<p>我将根据面向对象编程的三个传统支柱: 封装/多态和继承来组织这种比较,
第一篇将重点放在封装上;
对于每个支柱, 将讨论 OOP 如何定义, 以及在 OOP 世界之外存在哪些等价物或是替代品,
以及这些在实际易用性和编程能力方面进行对比;</p>
<p>不过,在开始之前,想先谈谈一个用例, 这个用例曾颠覆过大部分内容: 图形用户界面或是说 GUI;
尤其是在浏览器时代之前,
编写 GUI 程序以便直接在台式机(或笔记本电脑)上运行,
是程序员工作的主要部分;
OOP 的许多早期开发是和 Xerox PARC 的图形用户界面研究一起完成的,
OOP 非常适合该用例;
因此, 值得优先考虑 GUI;</p>
<p>例如, 人们通常会在其它编程语言中模拟 OOP;
GTK+ 就是一个很好的例子,
将 OOP 实现为 C 中一系列宏和约定;
这样作的原因有很多,包括熟悉 OOP 设计和希望创建某种运行时的多态;
但是,根据我的经验, 这在实现 GUI 框架时最为常见;</p>
<p>在本系列文章中, 主要关注将 OOP 应用在其它用途的场景,
但是,也会酌情讨论 GUI;
在这个介绍性部, 我仅指出 GUI 框架在传统 OOP 设计和编程语言之外显然是可能的,
甚至于在 Rust 中也是如此;
有时, GUI 可以通过完全不同的机制工作,
例如主要在 Haskell 中开创性的功能响应式了渔的哪, 我个人更加喜欢传统的基于 OOP 的编程,
而传统的 OOP 功能对此却并没有什么帮助;</p>
<p>现在, 事不宜迟, 让我们从实用角度, 逐一比较 OOP 和 Rust 以及其后各种 OOP 编程语言;
对于首篇文章, 其余部分将重点关注封装;</p>
<h3 id="第一支柱-封装-encapsulation"><a class="header" href="#第一支柱-封装-encapsulation">第一支柱: 封装/ Encapsulation</a></h3>
<p>在面向对象编程中, 封装和类的概念密切相关,
类是面向对象编程中的基本抽象层;
每个类都包含一些记录数据的格式/布局,
即, 每个实例包含一定数量字段的数据结构;
记录类型的单个实例称为&quot;对象&quot;;
每个类还包含和该记录类型紧密配对的代码,
组织成称为方法的过程;
核心想法是, 所有字段都只能从方法内部访问,
无论是通过 OOP 意识形态的约定还是通过编程语言的强制规则;</p>
<p>这里的基本好处是 接口/interface ,也就是代码如何和其它代码交互,
或者说你必须知道什么才能使用代码,
比 实现/implementation 要简单的多, 实现/implementation 是代码如何实际完成 的更加流畅变化的细节, 其原本的工作;</p>
<p>但是, 虽然许多编程语言都有这样的抽象;
任何超过十几行的程序就有太多的部分, 无法一次全部反映到你的大脑中,
因此,所有现代编程语言都有将程序划分为更小组件的方法,
作为管理复杂性的一种方式,
接口/interface 总是比 实现/implementation 更加简单,
无论是由编程语言强制执行, 还是&quot;荣誉系统&quot;的问题;
因此, 从广义上玛, 所有现代编程语言都有某种版本的封装;</p>
<p>一种简单的封装形式 --- 太多数面向对象的编程语言将其作为类中的一层来维护 --- 就是过程,
也称为函数/子例程或是(OOP 中的称呼)方法;
现代编程语言不允许任何代码行直接跳转到任何其它代码行,
而是倾向将代码块组合为过程,
然后, 你可以在不影响外部代码的情况下,
更改过程的内容, 并更改外部代码, 同样在不影响程序的情况下,
嘦都遵循相同的 接口/interface 和 契约/contract;</p>
<p>契约/contract 通常至少部分是人类层面的约定;
一般没有什么可以阻止你采用一个应该处理一些数据的过程,
而是让其无限循环或是令程序崩溃;
但是, 其中的一些, 例如过程和程序其余部分的分离, 
以及在许多情况中, 允许在调用中接受和返回的值的数量和类型,
将由编程语言强制执行;</p>
<p>例如,在过程内部声明的变量通常是局部的,
而且没有办法在过程外部引用;
输入和输出通常姴在过程顶部的签名中;
通常, 外部代码只能在第一行进入过程, 而不能在中途的任意一行进入;
某些编程语言(包括 Rust)中, 过程甚至于可以包含其它过程,
这些过程只能在外部过程中调用;</p>
<p>但是,当然现代程序通常比少数用锥程序更复杂;
因此,现代编程语言(再次强调: <strong>&quot;现代&quot;</strong> 一词在这里的使用非常宽松)具有另一层封装抽象:模块;</p>
<p>模块通常包含一组过程,有些可以从外部访问, 有些则不能;
在非 duck 类型语言中, 通常要定义很多聚合类型, 同样是有些可以从外部访问,有些不行;
通常甚至于可以抽象的公开这些类型,因此,程序的其余部分可以访问类型的实在,但是不能访问记录字段,
甚至于不能访问是记录类型的事实;
甚至于 C 在其模块系统中也有这种能力 --- 反而是 C++ 没有引入这点, 只是追加了一个额外的/正交级别的逐字段访问控制;</p>
<p>从务实的角度来看,基于类的封装并不是 OOP 的某个特殊见解,
而是一种专门的---或是更确切的说, 严格限制的---模块形式;
在 OOP 编程语言中, 我们有类的概念, 是一种特殊形式的模块
(有时是唯一受支持的形式, 有时甚至于在完全不同的/更加传统的模块概念下分层,以便增加概念上的混淆);
只是,对于一个&quot;类&quot;,通常只能定义一个主要类型, 和模块本身共享一个名称,
而且,该类型的字段被给予特殊保护, 以便防止类外代码的访问;</p>
<p>当然, 类和模块之间还有其它区别,但是,这些和其支柱有关, 我们稍后将论及;
现在我们只讨论和封装相关的 &quot;类&quot; 概念 --- 其中, 类只是具有一种特权抽象类型的特殊模块;</p>
<p>这是一种编写模块的合理方式,但是, 并不像面向对象编程思想所表明的那样特别
(特别是当我们讨论其它支柱的替代方案时,但是,同样稍后再讨论);
在某些情况中,模块没有定义任何记录类型,这在 Java 等编程语言中很尴尬,
无论如何你都必须定义一个空记录类型, 并仍然创建一个 &quot;类&quot;;
在某些情况中, 一个模块定义了多个可以公开访问的类型,
这些类型紧密的纠缠在一起 --- 并且 OOP 风格鼓励你在这些类型之间进行封装, 这样一来更多的阻碍而不是帮助;</p>
<p>从根本上说, 能够对其它模块隐藏记录的字段很重要, 这就是为什么 C 也支持;
甚至对于在 Rust 中实现对不安全特性的安全抽象是必不可少的,
例如集合/collections, 其中原始指针和一同记录的其它字段相结合具有不变量;
但是, 这对 OOP 来说并不陌生,而且, 这并不是每种可能类型的最佳选择;</p>
<p>作为这点的证据,在 Java 和 Smalltalk 中,
在较小程度上甚至在 C++ 或是 Python 中,
坚持每一种类型的封装风格意味着你可以获得这些样板方法,
比如说 setFoo 和 getFoo;
这些方法什么都不作,只是充当一些本质上是哑记录类型的字段访问器;
从理论上说, 如果你想更改设置或是读取这些字段时发生的事情,
这会有所帮助,得是不是, 实际上, 这只是原始字段访问器, 本质上就是 契约/contract 的一部分;
例如, 如果她们改为进行网络调用而不是仅仅返回一个值,
那么对于这种简单命名的方法, 将强烈触发惊喜原则:</p>
<p>说起来要简单的多:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Point {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
<span class="boring">}</span></code></pre></pre>
<p>... 相比俺还是 Java 程序员时惯用的 “JavaBean” 等价物
(Java 从那时起显然发生了变化,
但是, 这代表了很多 OOP 编程琂,包括 Smalltalk 和许多关于如何编程的书籍):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>class Point {
    private double x;
    private double y;
    private double z;

    double getX() {
        return x;
    }

    double setX(double x) {
        this.x = x;
    }

    double getY() {
        return y;
    }

    double setY(double y) {
        this.y = y;
    }

    double getZ() {
        return z;
    }

    double setZ(double z) {
        this.z = z;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>此类数据类型通常不使用 OOP 类获得的任何其它功能,
例如多态或是继承;
在此类 “JavaBean” 类中使用此类功能也将违反最小意外原则;
&quot;类&quot;概念对于这些记录类型来说,根本就是矫枉过正;</p>
<p>当然, Java 开发者(或是 Smalltalk 又或 C#) 会说,
应该通过这些 getter 和 setter 方法间接访问字段, 他们是面向未来的类,
以防设计发生变化
(事实上我是当 Reddit 上有人提出这点时,才被提醒到, 追加了这段);
但是,我发现这是虚伪的,
或者蕛是被误导的 --- 它通常用于程序内部结构的一部分,
在这种情况中, 更加合理的作法是向结构所有用户公开更改字段;
除了字面意义上的设置或是获取字段之外，
也很难想到这些方法还可以作什么不足为奇的事儿，
正如方法名称所暗示的那样 --- 例如,
进行网络调用对于获取或是设置方法来说,
将是一个令人震惊的惊喜,
并且,因此至少违反了隐含的协约;
在我编写 OOP 代码时,
我从来没见过适合 getter 或是 setter 执行任何操作的情况,
除了字面上的获取或是设置字段;</p>
<p>如果代码确实更改为要求 getter 或是 setter 执行其它操作,
我宁愿更改方法的名称以便反映具体还作了什么,
而不是假装这不是重大变更;
fetchZFromNetwork 或是 setAndValidateZ 似乎比 getZ 或是 setZ 更加合适,
它们所作的事儿, 比我们假设 setter 或是 getter 所作的简单字段访问到的更多;
OOP 坚持每个类型都应该是其自己的代码抽象边界,
这在应用这些轻量级聚合类型时, 常常就变的荒谬了;
这些类型的 getter 和 setter 用以保护不应该存在且哪小得小妨碍的抽象边界,
并且,在未来防止在不更改接口的情况中,
不应该进行的实现变更;</p>
<p>setter 和 setter 简而言之,
是一种反模式;
如果你打算创建除 &quot;数据结构&quot; 之外的抽象,
其中验证或是网络调用又或原始字段访问之外的任何其它内容加班是合适的,
那么这些 get 和 set 名称就是该抽象的错误名称;</p>
<p>2023-02-13 追加了此段:
明确的说, 这些异议也适用于属性;
我反对的不是语法上的不便,
而是使用代码透明的替换字段访问的整个概念是一件值得努力的好事,
或者是保持开放的重要可能性;
有希望 foo.bar = 3 永远不会在 Rust 中触发进行网络调用!
如果这必须是异步的呢?
如果我在调用函数,应该很清楚;
而 Rust 是关于明确性的思考成果;</p>
<p>实际上, get 和 set 函数仅用作包装器以便满足 OOP 思想的约束;
领导作用称提供的面向未来的证明是一种幻想;
如果你在抽象边界上提供“JavaBean”样式类型或是具有属性的类型,
那么你实际上就像提供原始字段访问一样被锁定 --- 你最有可能希望对这些结束进行的更改不允许移动 getter 和 setter 以保持兼容性;
对于你想要进行的更改,
利用这种面向未来的方法可能是完全不可能的,
充其量会涉及可怕的骇客攻击;</p>
<p>在所有这些方面, Rust 似乎和 OOP 语言相同;
从表面上看, 又和类非常相似;
你可以定义和给定类型关联的函数 --- 它们甚至于被称为方法!
和 OOP 方法一样,
在语法上优先采用该类型的值
(或是对这些值的引用)作为第一个参数,
称为特殊名称 self;
你甚至于可以将记录类型(在 Rust 中称为结构)的字段标记为公共或
(默认情况下)私有,
就像在面向对象的编程语言中一样鼓励私有字段;</p>
<p>根据这个支柱, Rust 似乎非常接近 OOP;
对于这个支柱来说, 这是个公平的评估,
也是一个有意的选择,目的是让习惯了 C++
(或是 Java 又或 JavaScript) OOP 编程日常语法的人们更容易使用
Rust 编程;</p>
<p>但是, 相似之处只是肤浅的;
封装其实是 OOP 中最不明显的支柱
(毕竟, 所有现代编程语言都有某种形式的封装),
Rust 中的实现不受类型约束;
当你在 Rust 中声明一个字段私有时(通过不指定 pub),
这并不意味着对其方法私有,
这只是意味着对模块私有;
一个模块可以提供多种类型,
并且该模块中的任何函数, 无论是否是该类型的&quot;方法&quot;,
都可以访问该类型中定义的所有字段;
在适当的时候鼓励传递记录,
而不是鼓励访问者被强制访问,
即便在紧密绑定的相关代码中也是如此;</p>
<p>这是我们看到 Rust 的第一个迹象,
尽管语法很简洁, 但是, 并不是一种 OOP 编程语言;</p>
<p>This is the first sign we see that Rust, in spite of its superficial syntax, is not an OOP programming language.</p>
<h3 id="接下来"><a class="header" href="#接下来">接下来</a></h3>
<p>在这点上, 今天不得不暂停一下;</p>
<p>当然, 封装并不是 OOP 风格类所能作的唯一奇特的事儿;
如果是这样, 那么类就不会迷惑这么多人这么多年了:
每个人都会明白,类不过是美化的模块,
而方法不过是美化的过程;</p>
<p>在本系列下篇文章中,
我们将讨论和 OOP 相关的其它特性,
OOP 剩下的两大传统支持,
多态和继承,
从实践的角度分析,
并了解 Rust 和 OOP 在性能方面的比较, 针对那些支柱概念;</p>
<p>接下来将是 多态!</p>
<h2 id="logging-27"><a class="header" href="#logging-27">logging</a></h2>
<ul>
<li>230225 ZQ v1 done</li>
<li>230220 ZQ re-start</li>
<li>230215 ZQ init.</li>
</ul>
<pre><code>         _~^|^~_
     \/ /  ◵ ◷  \ ()
       '_   △   _'
       ( '--∽--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-超越面向对象第2部分"><a class="header" href="#rust-超越面向对象第2部分">Rust 超越面向对象,第2部分</a></h1>
<p>原文:<a href="https://www.thecodedmessage.com/posts/oop-2-polymorphism/">Rust Is Beyond Object-Oriented, Part 2: Polymorphism :: The Coded Message</a></p>
<h2 id="快译-2"><a class="header" href="#快译-2">快译</a></h2>
<p>在这篇文章中, 通过讨论 OOP 三大传统支柱中的第二个: 多态,
继续系列文章:关于 Rust 和传统 OOP 范式的不同;</p>
<p>多态性是面向对象编程中的一个特别重要的话题，
也许是其三大支柱中最重要的一个;
关于多态性是什么, 各种编程语言如何实现(在 OOP 世界内外---是的,多态性也存在于 OOP 宇宙之外),
如何有效的使用, 以及更加关键的何时嫑使用;
可以写一些关于如何单独使用多态的 Rust 版本的书了;</p>
<p>不幸的是, 这只是一篇 blog,所以,
我无法像我想的那样详细或是多样性的介绍多态;
相反,我将特别关注 Rust 和 OOP 概念的不同之处;
我将从描述其在 OOP 中的工作方式开始,
然后, 讨论如何在 Rust 中实现相同的目标;</p>
<p>在 OOP 中,多态性就是一切;
试图采取所有决策(或是尽可能多的决策)并将其统一在一个通用的狭义机制中:
运行时多态;
但是, 不幸的是, 并不是任意运行时多态, 而是一种特定的/狭义的运行时多态形式,
受到 OOP 哲学和实现如何工作细节的限制:</p>
<ul>
<li>间接需求: 每个对象通常都必须存储在堆上,才能使运行时多态生效, 因为,不同的&quot;运行时类型&quot;具有不同的尺寸; 这鼓励了可变对象的别名使用;不仅如此,要真正调用一个方法,必须穿过三层间接:
<ul>
<li>解引用对象引用</li>
<li>解引用类指针或是 “vtable” 指针</li>
<li>最后完成间接函数调用</li>
</ul>
</li>
<li>排斥优化: 除了间接函数调用的内在成本之外, 调用是间接的这一事实, 意味着内联是不可能的；通常,多态方法很小,甚至于微不足道,例如返回常量/设置字段或是重新排列参数并调用另一个方法, 因此, 内联会很有用; 内联对于允许优化跨内联边界也很重要;</li>
<li>仅能在单一参数上多态: 特殊的接收者参数,称为 self 或是 this, 是运行时多态也的并上通常可能通过的唯一参数; 其它参数的多态可以用那些类型中的辅助方式来模拟, 这就很尴尬, 而且, 返回类型的多态也是不可能的;</li>
<li>每个值都是独立多态的: 在运行时多态中, 通常没有办法说集合的所有元素都属于实现相同接口/interface 的某种类型 T,但是, 该类型是什么又应该在运行时能确定;</li>
<li>和其它 OOP 特性纠缠在一起: 在 C++ 中,运行时多态和继承紧密耦合；　在很多 OOP 语言中, 多态仅适用于类的类型, 正如我在上篇 blog 中讨论的那样, 类类型是一种受约束的模块形式;</li>
</ul>
<p>其实我完全可以针对以上每条吐糟单独写一大篇文章 --- 也许有一天真的会;</p>
<p>不过,尽管有这么多限制, 多态仍然被视为使用 OOP 语言进行决策的首选方式,
并且, 特别直观且易于访问;
受过训练的程序员, 嘦可能就一定使用此工具,
无论是否是手上决策是最佳工具, 即便当前不需要用多态进行运行时决策;
有些编程语言,例如 Smalltalk 甚至折叠了 &quot;if-then&quot; 逻辑,
并循环到 this 这个奇怪的特定决策结构中,
通过多态方法(如: ifTrue:idFalse)最终实现,
这些方法将在 True 和 False 类中以不同方式再实现
(和 therefore 在 true 以及 false 对象上配套);</p>
<p>需要明确的是, 拥有基于 vtable 的运行时多态性机制本身并不是一件坏事儿 --- Rust 甚至有也一个
(和上述 OOP 版本相似,但是,并不完全对等);
但是, Rust 版本只用以相对罕见的情况, 在这种情况中,
该机制最适合整个儿 palette 机制;
在 OOP 中, 将这种严格约束且忾和用低下的决策制定形式提升到所有其它形式之上,
以及使用多态是表达程序注释和业务编辑的最佳方式以及最直观方式的哲学断言,
本身就是个问题;</p>
<p>事实证明,当你选择最适合手头情况的工具时, 编程更加吻合人体工程学 --- 而 OOP 运行时多态性,
只是偶尔才是最合适完成当前工作的实效工具;</p>
<p>因此, 让我们看看在 OOP 使用运行时多态性时, 可以使用的 Rust 版四种替代方案;</p>
<h3 id="备选方案0枚举"><a class="header" href="#备选方案0枚举">备选方案#0：枚举</a></h3>
<p>不仅有其它形式的多态性, 而且具有更少的严格约束
(例如 Haskell 的类型类)或一组不同的权衡
(例如 Rust 的 trait,主要基于 Haskell 类型类),
Rust 中还有另外一个决策系统, 即:代数数据类型(ADTs, algebraic data types)
或曰求合/sum 类型,
也能接管 OOP 样式多态的很多应用程序;</p>
<p>在 Rust 中, 这些被称为 枚举/enums;
很多编程语言中的枚举是存储在整数尺寸类型中的常量列表,
有时以类型安全的方式实现(比如在 Java 中),
有时不是(比如在 C 中),
有时可以使用任何一种选项(比如,在 C++ 中枚举和枚举类之间就有区别);</p>
<p>Rust 枚举支持这种熟悉的用例, 而且具有类型安全:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Visibility {
    Visible,
    Invisible,
}
<span class="boring">}</span></code></pre></pre>
<p>但是, 还支持和每个选项关联的附加字段,
创建类型理论中称为&quot;总和类型&quot;(sum type)的东西,
但在 C 或是 C++ 程序员中更加广为人知识的叫&quot;联合标记&quot;(tagged union)
--- 不同之处在于, Rust 中, 编译器知道并能强制执行标记;</p>
<p>以下是一些枚举声明的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum UserId {
    Username(String),
    Anonymous(IpAddress),
    // ^^ This isn't supposed to be a real network type,
    // just an example.
}

let user1 = User::Username(&quot;foo&quot;.to_string());
let user2 = User::Anonymous(parse_ip(&quot;127.0.0.1&quot;)?);

pub enum HostIdentifier {
    Dns(DomainName),
    Ipv4Addr(Ipv4Addr),
    Ipv6Addr(Ipv6Addr),
}

pub enum Location {
    Nowhere,
    Address(Address),
    Coordinates {
        lat: f64,
        long: f64,
    }
}

let loc1 = Location::Nowhere;
let loc2 = Location::Coordinates {
    lat: 80.0,
    long: 40.0,
};
<span class="boring">}</span></code></pre></pre>
<p>你可能会问,这些<code>联合标记</code>和多态有什么关系?
好吧, 大多数 OOP 语言对于这些 求合类型/sum type 没什么好办法,
但是, 她们确实有强大的运行时多态机制,
所以, 你会看到运行时多态用 Rust 枚举实现也是一样的适合
(我可能进一步争辩: 更加合适):
每当有一些小关于如何协商会议值的选项, 但是,这些选项又包含不同细节时;</p>
<p>比如, 这是一种使用继承和运行时多态在 Java 中表示 UserId 类型的方法 --- 当我还是学生时, 
肯定会这么来(将每个类放在不同的文件中):</p>
<pre><code class="language-java">class UserId {
}

class Username extends UserId {
    private String username;
    public Username(String username) {
        this.username = username;
    }

    // ... getters, setters, etc.
}

class AnonymousUser extends UserId {
    private Ipv4Address ipAddress;
    
    // ... constructor, getters, setters, etc.
}

UserId user1 = new Username(&quot;foo&quot;);
UserId user2 = new AnonymousUser(new Ipv4Address(&quot;127.0.0.1&quot;));
</code></pre>
<p>重要的是, 就像在枚举示例中一样,
我们可以将 user1 和 user2 给定相同类型的变量,
并将她们得狮给相同类型的函数, 并通常对她们执行相同的操作;</p>
<p>现在这些 OOP 风格的类看起来轻飘到飞溅的程度,
但是, 这主要是因为我们没有为这种情况添加任何真正的操作代码 --- 只有数据和结构, 
以及一些变量定义和模板;
让我们考虑一下, 如果我们真的对用户 ID 尝试进行任何操作时会怎么样?</p>
<p>例如,我们可能想确认她们是否为管理员;
在我们的假设中, 假设匿名用户永远不是管理员,
而拥有用户名的用户只有在用户名以字符串 admin_ 开头时,才是位管理员;</p>
<p>理论上认可的 OOP 方法是添加一个方法,
比如: administrator;
为了让这个方法起作用, 我们必须将其追加到所有三个类: 基数以及两个子类:</p>
<pre><code class="language-java">class UserId {
    // ...
    public abstract bool isAdministrator();
}

class Username extends UserId {
    // ...
    public bool isAdministrator() {
        return username.startsWith(&quot;admin_&quot;);
    }
}

class AnonymousUser extends UserId {
    // ...
    public bool isAdminstrator() {
        return false;
    }
}
</code></pre>
<p>因此, 为了在 Java 中为这种类型添加这种简单的操作,如此简单的能力,
我们却必须使用三个类,
而且必须存储在三个文件中;
丫们每个对象都包含一个方法来作一些简单的事儿,
但是, 在任何羌族都看不到谁是管理员, 又或者不是管理员的完整逻辑 --- 有人可能会很不合时宜的问出这个问题;</p>
<p>Rust 则为这种操作使用 match,
将有关所有信息放在一个地方完成判定:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_administrator(user: &amp;UserId) -&gt; bool {
    match user {
        UserId::Username(name) =&gt; name.starts_with(&quot;admin_&quot;),
        UserId::AnonymousUser(_) =&gt; false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>诚然, 这将产生更加复杂的单个函数,
但是,具有明确的所有逻辑;
让编辑明显而不是隐含在继承屡次结构中, 
这就违反了 OOP 原则, 
在 OOP 宇宙中, 方法应该简单, 多态性用于隐含的表达逻辑;
但是,这并不能保证任何事儿, 只是将其扫到地毯下而已:
事实证明, 隐藏复杂性会令其更难应对, 而不是相反;</p>
<p>让的我们来看另外一个例子;
我们已经用了一段时间的 UserId 代码,
你的任务是为这个系统编写一个新的 Web 前端;
你需要某种方式, 以 HTML 格式显示用户信息,
要么是指向用户配置文件的链接(对于指定用户),
要么是将 IP 地址字符串化为红色(对于匿名用户);
因此, 你决定为这个小型类型追加一个新操作 toHTML,
将输出新前端的专用 DOM 类型;
(也许 Java 被编译为 WebAssembly 呢? 我也不确定,不过细节不重要;-)</p>
<p>你逈后端核心库深入的 UserId 类屡次结构的维护者提交了 pull request;
然后, 他们拒绝了;</p>
<p>事实上, 他们有很好的理由, 你必须勉强承认;
他们说:&quot;这是一种荒谬的关注点分离&quot;;
此外, 公司也无法从你的前端获得此核心库处理类型;</p>
<p>所以, 你叹了口气, 写了个 Rust 匹配表达式的等价物, 但是用的是 Java
(请原谅我荒谬的假设有个 HTML 库):</p>
<pre><code class="language-java">Html userIdToHtml(UserId userId) {
    if (userId instanceof Username) {
        Username username = (Username)userId;
        String usernameString = username.getUsername();
        Url url = ProfileHandler.getProfileForUsername(usernameString);
        return Link.createTextLink(url, username.getUsername());
    } else if (userId instanceof AnonymousUser) {
        AnonymousUser anonymousUser = (AnonymousUser)userId;
        return Span.createColoredText(anonymousUser.getIp().formatString(), &quot;red&quot;);
    } else {
        throw new RuntimeException(&quot;IDK, man&quot;);
    }
}
</code></pre>
<p>你的老板们在代码审查时拒绝了这段代码,
你你使用了 instanceof 反模式,
但是, 后来在你让他们和不接受你的其它补丁的核心库维护者争论之后,
丫们勉强接受了这段代码;</p>
<p>但是, 看看那坨 instanceof 代码有多难看!
难怪 Java 程序员认为这是一种反模式!
但是, 在这种情况中, 已经是最合理的事儿了,
实际上, 是除了实施观察者东西方或是访问者模式又或是其它相当于基础设施的东西之外,
唯一可能的实现, 只是用来创造具有控制反转的实例而已;</p>
<p>当操作集有界(或是接近有限)并且该类的子类数量可能以意想不到的方式增长时,
通过向每个子类追加一个方法来实现操作是有意义的;
可是,通常情况中, 操作的数量又会以意想不到的方式增长,
而子类的数量总是有限的(又或是接近有限);</p>
<p>对于后一种情况, 这种情况比 OOP 拥护者想象的更加常见,
Rust 枚举 --- 以及一般的 求和类型 --- 是完美的;
一但你习惯了她们, 你就会发现自己一直在使用;</p>
<p>我要郑重声明,
在所有面向对象的编程语言中,都没有这么糟糕;
在某些情况中, 你可以按任何顺序编写任意类方法组合,
因此,如果你愿意, 可以将所有三个实现写在一个地方;
Smalltalk 传统上允许你在一个特殊的浏览器中游览代码库,
你可以在其中看到一个类实现的方法列表,
或者一个接受给定&quot;消息&quot;的类列表,
正如 Smalltalk 所说的那样,
这样你就可以随心所欲的操弄对象了;</p>
<p>(译按: 当然, 你必须在 Salltalk 对应解释器的 IDE 环境中, 一但出了这个对象镜像, 将失去一切观察能力, 这导致 Smalltalk 没办法使用其它传统 IDE)</p>
<h3 id="备选方案-1-闭包"><a class="header" href="#备选方案-1-闭包">备选方案 #1: 闭包</a></h3>
<blockquote>
<p>Alternative #1: Closures</p>
</blockquote>
<p>有时, 一个 OOP 接口或是多态决策只涉及一个实际操作;
在这种情况中,只能使用闭包;</p>
<p>我不想在这方面花太多时间,
因为, 大多数 OOP 程序员已经意识到这点,
并且, 自从他们的 OOP 语言已经赶上了函数式语言,
并获得了 lambda 语法 --- Java 中的 Java 8 ,
C++ 中的, C++11;
因此, 像 Java 的 Comparator 这种愚蠢的单一方法接口 ---
幸运的是 --- 基本上已经都感染过去式了;</p>
<p>此外, Rust 中的闭包在技术上涉及 traits,
因此,使用和接下来的两个替代方案相同的机制来竀,
所以,也有人可能会争辩说这在 Rust 中并不是真正的独立选项;
然而,在我看来 lambda/闭包和
FnMut/FnOnce/Fn 等 trait 们在美学上和情境上都非常特别,
值得花点时间掌握;</p>
<p>因此, 我将花些时时间来说明这点:
如果你发现自己只使用一种方法编写 trait 
(Java 接口或是 C++ 类),
请考虑你是否应该改用某种闭包或是 lambda 类型;
毕竟只有你自己才能防止过度设计;</p>
<h3 id="备选方案2-具有traits的多态"><a class="header" href="#备选方案2-具有traits的多态">备选方案#2: 具有Traits的多态</a></h3>
<p>就像 Rust 有个比 OOP 类概念更加灵活/强大的封装版本,
正如在上篇文章中讨论的那样,
Rust 有一个比 OOP 假设更加强大的多态版本: trait;</p>
<p>trait 就像来自 Java 的接口
(又或是 C++ 中的全抽象超类),
但是,并没有我在文章开头指出的大部分限制;
trait 即没有语义约束, 也没有性能约束;
trait 在语义和原理方面深受 C++ 模板的启发;
C++ 程序员可以将其视为带有concepts/概念的模板
(除非设计的,从一开始就融入编程语言,
而且不必要处理所有不使用它的代码;)</p>
<p>让我们从语义开始:
你可以使用 trait 完成那些无法使用纯 OOP 完成的,
即便你将世界上所有的间接调用都丢给她?
好吧, 在纯粹的 OOP 术语中,
是无法编写像 Rust Eq 和 Ord 这样的接口,
这里给出了非常简单的定义
(Eq 和 Ord 的真正定义在于拓展了其它允许不同类型之间的部分等价和排序的类,
但是, 像这种简化定义,
非部分 Eq 和 Ord 的 Rust 标准库版本确定涵盖了相同类型值之间的等价和排序):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Eq {
    fn eq(self, other: &amp;Self) -&gt; bool;
}

pub enum Ordering {
    Less,
    Equal,
    Greater,
}

trait Ord: Eq {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p>看看发生了什么?
就像在 OOP 风格的接口中一样,
这些无法采用 Self 类型的“接受者”类型,
一个 self 秋粮 -- 也就是说,任何实现 trait 的具体类型
(技术上这里是对 Self 或 &amp;Self 的引用);
但是, 和 OOP 风格的接口不同,
这里还能采用另外一个 &amp;Self 类型的参数;
为了实现 Eq 和 Ord,
类型 T 提供了一个函数,
该函数接受对 T 的两个引用;
字面上的意思是: 对 T 的两个引用, 而不是对 T 的一个引用和对 T 或是任何子类的一个引用
(这样的事情在 Rust 中并不存在),
不是对 T 的一个引用和对实现 Eq 的任何其它值的一个引用,
而是对同一具体类型的两个真正的非异构引用,
然后，函数就可以比较她们是否相等(或是进行排序);</p>
<p>这点很就将要,因为,
我们想用这种能力来实现像排序这类方法:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec&lt;T&gt; {
    pub fn sort(&amp;mut self) where T: Ord {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>OOP-style polymorphism is ideal for heterogeneous containers, where each element has its own runtime type and its own implementation of the interfaces. But sort doesn’t work like that. You can’t sort a collection like [3, &quot;Hello&quot;, true]; there’s no reasonable ordering across all types.</p>
<p>Instead, sort operates on homogeneous containers. All the elements have to match in type, so that they can be mutually compared. They don’t each need to have different implementations of the operations.</p>
<p>Nevertheless, sort is still polymorphic. A sorting algorithm is the same for integers or strings, but comparing integers is a completely different operation than comparing strings. The sorting algorithm needs a way of invoking an operation on its items – the comparison operation – differently for different types, while still having the same overall structure of code.</p>
<p>This can be done by injecting a comparison function, but many types have an intrinsic, default ordering, and sort should default to it. Thus, polymorphism – but not an OOP-friendly variety.</p>
<p>See the contrivance Java goes through to define sort:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static &lt;T extends Comparable&lt;? super T&gt;&gt; 
void sort(List&lt;T&gt; list)
<span class="boring">}</span></code></pre></pre>
<p>There is no simple trait that can require T to be comparable to other Ts, for T to be ordered. Instead, as far as the programming language is concerned, the idea that T is comparable to itself, rather than to any other random type, is only articulated as an accident to this method. Nothing is stopping someone from implementing the Comparable interface in an inconsistent way, like having Integer implement Comparable<String>.</p>
<p>Additionally, when it actually looks up the implementation of Comparable, it decides what implementation to use based on the first argument of any comparison, not based on the type. Normally, they will all be the same type, but theoretically, this list could be heterogeneous, as long as all the objects “extend” T, and they could implement Comparable differently. The computer has to do extra work to indulge this possibility, even though it would certainly be a mistake.</p>
<p>As we’re now drifting outside of the realm of semantics, and into the realm of performance, let’s discuss the performance implementations of this fully.</p>
<p>The Java sort method, as we mentioned, requires every item in the collection to be a full object type, which means that instead of storing the values directly in the array, the values are stored in the heap, and references are stored in the array. This is unnecessary with a traits-based approach – the values can live directly in the array.</p>
<p>This means that different arrays will have different element sizes, so this has to be handled by a trait as well. And it is: The size of the values is also parameterized via the Sized trait. The size does have to be consistent among all the items of the array, but this is enforceable because we can express that all the elements are actually the exact same type – unlike Java’s List<T> which only expresses that they’re of type T or some subtype of T.</p>
<p>Rust’s sort method could have been implemented by passing the size information (from the Sized trait) and the ordering function (from the Ord trait) at runtime as an integer value and a function pointer. This is how typeclasses work in Haskell, which was the inspiration for Rust traits. This would still be more efficient than the Java, as there would be a single ordering function, rather than a different indirect lookup for every left side of the comparison, allowing indirect branch prediction to work in the processor.</p>
<p>But Rust goes even further than that, and implements its traits instead via monomorphization. This is similar to C++ template instantiation, but semantically better constrained. The premise is that while sort is only one method semantically, in the outputted, compiled code, a different version of sort is outputted for every type T that it is called with.</p>
<p>C++ templates create infamously bad error messages and are difficult to reason about, because they are essentially macros, and awkward ones. Even Rust cannot create great error messages with its macro system. But also, writing them requires expertise, and means that the programmer is forgoing many of the benefits of the type system – templates are often called, in my opinion rightly so, a form of compile time duck-typing. For these reasons, template programming in C++ is often considered more advanced (read as harder and less convenient rather than more powerful) than OOP-style polymorphism.</p>
<p>In Rust, however, traits provide an organized and more coherent way of accessing similar technology, getting the performance benefits of templates while still giving the structure of a solid type system.</p>
<h3 id="alternative-3-dynamic-trait-objects"><a class="header" href="#alternative-3-dynamic-trait-objects">Alternative #3: Dynamic Trait Objects</a></h3>
<p>Sometimes, however, you do need full run-time polymorphism. You have the opposite of the scenario with the enum: You have a closed set of operations that can be performed on a value, but what those operations actually do will change dynamically in a way that cannot be bounded ahead of time.</p>
<p>In such situations, Rust has you covered with the dyn keyword. Please don’t overuse it, though. In almost all situations where I’ve thought it might be appropriate, static polymorphism combined with other design elements have worked out better.</p>
<p>Legitimate use cases for dyn tend to come up in situations involving inversion of control, where a framework library takes on a main loop, and the client code says how to handle various events. In network programming, the framework library says how to juggle all the sockets and register them with the operating system, but the application needs to say what to actually do with the data. In GUI programming, the framework code can say what widget was being clicked on, but very different things happen if that widget is a button versus a text box versus a custom widget you invented for this particular app.</p>
<p>Now, you don’t strictly need run-time polymorphism for this. You could use closures (or even raw function pointers) instead, creating struct of closures (or function pointers) if multiple operations are called for – which amounts to basically doing what dyn does the hard way by hand. For example, I fully expected tokio to use Rust’s run-time polymorphism feature internally to handle this inversion of control in task scheduling. Instead, for what I imagine are performance reasons, tokio implements dyn by hand, even calling its struct of function pointers Vtable.</p>
<p>But dyn does all of this work for you, for your trait. The only requirement is that your trait be object-safe, and the list of requirements may seem familiar, especially when it comes to the requirements for an associated function (e.g. a method) to be “dispatchable”:</p>
<hr />
<ul>
<li>Not have any type parameters (although lifetime parameters are allowed),</li>
<li>Be a method that does not use Self except in the type of the receiver.</li>
<li>Have a receiver with one of the following types:
<ul>
<li>&amp;Self (i.e. &amp;self)</li>
<li>&amp;mut Self (i.e &amp;mut self)</li>
<li>Box<Self></li>
<li>Rc<Self></li>
<li>Arc<Self></li>
<li>Pin<P> where P is one of the types above</li>
</ul>
</li>
<li>Does not have a where Self: Sized bound (receiver type of Self (i.e. self) implies this).</li>
</ul>
<hr />
<p>That is to say, it can be polymorphic in exactly one parameter, and that parameter must be by reference – more or less the exact requirements for methods to support run-time polymorphism in OOP.</p>
<p>This is of course because dyn uses almost exactly the same mechanism as OOP to implement run-time polymorphism: the “vtable.” Box<dyn Foo> really contains two pointers rather than one, one to the object in question, and the pointer to the “vtable,” the automatically-generated structure of function pointers for that type. The one-parameter requirement is because that is the parameter whose vtable is used to look up which concrete implementation of a method to call, and the indirection requirement is because the concrete type might be different sizes, with the size only known at run-time.</p>
<p>To be clear, these are limitations on one particular implementation strategy for run-time polymorphism. Alternative strategies exist that fully decouple the vtable from individual values of the type, as in Haskell.</p>
<p>There are still a few advantages of Rust’s version of run-time polymorphism with traits as opposed to OOP-style interfaces.</p>
<p>Performance-wise, it’s something done alongside a type, rather than intrinsic to the type. Normal values don’t store a vtable, spreading the cost of this throughout the program, but rather, the vtables are only referenced when a dyn pointer is created. If you never create a dyn pointer to a value of a given type, that type’s vtable doesn’t even have to be created. Certainly, you don’t have 8 bytes of extra gunk in every allocation for all the vtable pointers! This also means there’s one fewer level of indirection.</p>
<p>Semantically, it’s also a good thing that it’s just one option among many, and that it’s not the strongly preferred option that the entire programming language is trying to push you towards. Often, even usually, static polymorphism, enums, or even just good old-fashioned closures more accurately represent the problem at hand, and should be used instead.</p>
<p>Finally, the fact that run-time and static polymorphism in Rust both use traits makes it easier to transition from one system to another. If you find yourself using dyn for a trait, you don’t have to use it everywhere that trait is used. You can use the mechanisms of static polymorphism (like type parameters and impl Trait) instead, freely mixing and matching with the same traits.</p>
<p>Unlike in C++, you don’t have to learn two completely different sets of syntax for concepts vs parent classes, and vastly different semantics. Really, in Rust, dynamic polymorphism is just a special case of static polymorphism, and the only differences are the things that actually are different.</p>
<h2 id="logging-28"><a class="header" href="#logging-28">logging</a></h2>
<ul>
<li>230215 ZQ init.</li>
</ul>
<pre><code>         _~^&amp;∽~_
     \/ /  O ^  \ \/
       '_   v   _'
       / '--#--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-运算符重载六件趣事"><a class="header" href="#rust-运算符重载六件趣事">Rust 运算符重载六件趣事</a></h1>
<p>原文: <a href="https://wishawa.github.io/posts/fun-rust-operators/">Six fun things to do with Rust operator overloading | Wisha Wanichwecharungruang</a></p>
<p><img src="https://wishawa.github.io/posts/fun-rust-operators/dot-product-pooh.jpg" alt="dot-product-pooh" /></p>
<h2 id="快译-3"><a class="header" href="#快译-3">快译</a></h2>
<h3 id="c-输入出"><a class="header" href="#c-输入出">C++ 输入/出</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stdin().read_line(&amp;mut buffer).unwrap();
println!(&quot;Hello I am {name}!!!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>可以重载 cin 和 count 上的移位运算符来达成:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cin &gt;&gt; &amp;mut buffer;
cout &lt;&lt; &quot;Hello I am &quot; &lt;&lt; name &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>看起来意义更加不明了了?
)</p>
<h3 id="可变函数"><a class="header" href="#可变函数">可变函数</a></h3>
<p>想替代</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::cmp::max(x, y);
[w, x, y, z].into_iter().max();
<span class="boring">}</span></code></pre></pre>
<p>可以搞成:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// max+ is like std::cmp::max but better
// it supports &gt;2 arguments
max+(x, y);
max+(w, x, y, z);
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>内置标准库太丰富了...简直必须要有一个信仰过程</p>
<p>)</p>
<h3 id="更简洁的构建器"><a class="header" href="#更简洁的构建器">更简洁的构建器</a></h3>
<p>这是一个更严重的问题;
构建器模式有时涉及大量重复的方法调用;
以 warp web 框架的这种用法为例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
    .and(warp::path::param())
    .and(warp::header(&quot;user-agent&quot;))
    .map(|param: String, agent: String| {
        format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
    });
<span class="boring">}</span></code></pre></pre>
<p>如果 API 看起来像这样呢?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
	+	warp::path::param()
	+	warp::header(&quot;user-agent&quot;)
	&gt;&gt;	|param: String, agent: String| {
			format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
		};
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>等等, 这就是语法糖了吧?
)</p>
<h3 id="中缀函数"><a class="header" href="#中缀函数">中缀函数</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.pow(y);
dot_product(a, b);
a.cross(b.cross(c).cross(d))
<span class="boring">}</span></code></pre></pre>
<p>我们可以这么来:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x ^pow^ y;
a *dot* b;
a *cross* (b *cross* c *cross* d);
<span class="boring">}</span></code></pre></pre>
<p>很多人就想要这个!</p>
<p>(<code>是也乎:</code></p>
<p>嗯哼? 的确流畅很多哪...
)</p>
<h3 id="doublefish"><a class="header" href="#doublefish">Doublefish</a></h3>
<p>std::mem 提供有这些功能:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val(&amp;value);
<span class="boring">}</span></code></pre></pre>
<p>Turbofish 爱好者会喜欢 size_of,
但是对 size_of_val 没什么感觉;
所以, 我们可以自行改造出新版本的 size_of_val ,
看起来更象 turbofishy:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val&lt;&lt;&amp;value&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h3 id="join-和-race"><a class="header" href="#join-和-race">Join 和 Race</a></h3>
<p>特性组合器可能具有短路行为能力;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// quit if any of the 3 errors
(fut1, fut2, fut3).try_join().await;

// quit if any of the 3 succeeds
(fut4, fut5, fut6).race_ok().await;
<span class="boring">}</span></code></pre></pre>
<p>可以通过 &amp; 和 | 在形式上表达出这点:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(TryJoin &gt;&gt; fut1 &amp; fut2 &amp; fut3).await;
(RaceOk &gt;&gt; fut4 | fut5 | fut6).await;
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>这是从形式上和语义同步了.
)</p>
<h2 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h2>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/10golkq">Discuss this on Reddit</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=71da59351b0988249a69014e6b191353">Playground</a> containing the implementations behind some of the code shown here</li>
<li><a href="https://doc.rust-lang.org/std/ops/index.html">std::ops docs</a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">Rust operators precedence table</a></li>
</ul>
<h2 id="refer-39"><a class="header" href="#refer-39">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-29"><a class="header" href="#logging-29">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230125 ZQ init.</li>
</ul>
<pre><code>           _~^&amp;-~_
       \) /  * ?  \ (/
         '_   ⩌   _'
         ( '--~--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="笔记"><a class="header" href="#笔记">笔记</a></h1>
<blockquote>
<p>logging</p>
</blockquote>
<h2 id="background-26"><a class="header" href="#background-26">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>任何自学都需要探索+内省, 同时来, 否则, 很容易不知道在折腾什么...</p>
<h2 id="goal-32"><a class="header" href="#goal-32">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li>是谁?</li>
<li>在哪?</li>
<li>去哪?</li>
</ul>
<p>随时嗯哼明白...</p>
<h2 id="trace-28"><a class="header" href="#trace-28">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
基本环境
<ul>
<li><input disabled="" type="checkbox"/>
基本语法</li>
<li><input disabled="" type="checkbox"/>
基本 std</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
基本项目结构</li>
<li><input disabled="" type="checkbox" checked=""/>
基本经典工程</li>
<li><input disabled="" type="checkbox"/>
基本...习惯们?</li>
</ul>
<h2 id="refer-40"><a class="header" href="#refer-40">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://www.ainavpro.com/">Ai导航 | 最新最前沿的ai产品</a></li>
</ul>
<h2 id="logging-30"><a class="header" href="#logging-30">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<pre><code>          _~`~∽~_
      \/ /  o ◷  \ \/
        '_   ∧   _'
        \ '--#--' &lt;

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-课程笔记"><a class="header" href="#rust-课程笔记">Rust 课程笔记</a></h1>
<h2 id="background-27"><a class="header" href="#background-27">background</a></h2>
<p>Rust 社区很给力各种渠道中,有各种教程,
只是, 每个教程都有自己的特点和盲区...</p>
<h2 id="goal-33"><a class="header" href="#goal-33">goal</a></h2>
<p>高速刷过时, 见到有趣/有用/有种的片段, 收集摘录在一起, 形成自己的小抄...</p>
<h2 id="trace-29"><a class="header" href="#trace-29">trace</a></h2>
<h3 id="init"><a class="header" href="#init">init.</a></h3>
<p>Recommended tools:</p>
<ul>
<li><input disabled="" type="checkbox"/>
cargo readme - to regenerate README.md based on template and lib.rs comments</li>
<li><input disabled="" type="checkbox"/>
cargo insta - to review test snapshots</li>
<li><input disabled="" type="checkbox"/>
cargo edit - to add/remove dependencies</li>
<li><input disabled="" type="checkbox"/>
cargo fmt - to format code</li>
<li><input disabled="" type="checkbox"/>
cargo clippy - for all insights and tips
<ul>
<li>安装：rustup component add clippy</li>
<li>参考: <a href="https://skyao.io/learning-rust/docs/build/rustup/rustup-book.html">Rustup Book学习笔记 | Rust学习笔记</a></li>
<li>如果出问题:
<ul>
<li><a href="https://github.com/rust-lang/rustup/issues/1558">Fresh install on macos can't install rustfmt and clippy using rustup · Issue #1558 · rust-lang/rustup</a></li>
<li>rustup toolchain remove stable &amp;&amp; rustup toolchain install stable</li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>info: syncing channel updates for 'stable-x86_64-apple-darwin'
info: latest update on 2023-02-09, rust version 1.67.1 (d5a82bbd2 2023-02-07)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
info: downloading component 'rust-std'

...

  stable-x86_64-apple-darwin installed - rustc 1.67.1 (d5a82bbd2 2023-02-07)

info: checking for self-updates
</code></pre>
<ul>
<li><input disabled="" type="checkbox"/>
cargo fix - for fixing warnings</li>
</ul>
<h4 id="检验和切换工具链"><a class="header" href="#检验和切换工具链">检验和切换工具链</a></h4>
<p>~ <a href="https://github.com/gavadinov/Learn-Rust-by-Building-Real-Applications/tree/master/memory_management">Learn-Rust-by-Building-Real-Applications/memory_management at master · gavadinov/Learn-Rust-by-Building-Real-Applications</a></p>
<p>查实当前使用的工具链:</p>
<blockquote>
<p>rustup toolchain list</p>
</blockquote>
<p>安装指定工具链:</p>
<blockquote>
<p>rustup toolchain install nightly-x86_64-unknown-linux-gnu</p>
</blockquote>
<h4 id="宏查阅"><a class="header" href="#宏查阅">宏查阅</a></h4>
<p>~ <a href="https://github.com/dtolnay/cargo-expand">dtolnay/cargo-expand: Subcommand to show result of macro expansion</a></p>
<p>使用:</p>
<blockquote>
<p>crago expand</p>
</blockquote>
<p>在终端中展开宏并打印...如果工程大点儿, 就不可看了...</p>
<h3 id="project"><a class="header" href="#project">project</a></h3>
<h4 id="cli"><a class="header" href="#cli">CLI</a></h4>
<p>~ <a href="https://rust-cli.github.io/book/tutorial/index.html">A command line app in 15 minutes - Command Line Applications in Rust</a></p>
<p>还是老习惯, CLI-&gt;RESTful-&gt;GUI-&gt; ...</p>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<h4 id="dbg"><a class="header" href="#dbg">dbg!()</a></h4>
<p>类似 ic 的工具, 可以随时插入代码, 并在运行时打印对应变量名和值...</p>
<h3 id="testting"><a class="header" href="#testting">testting</a></h3>
<h3 id="coding"><a class="header" href="#coding">coding</a></h3>
<h2 id="refer-41"><a class="header" href="#refer-41">refer:</a></h2>
<blockquote>
<p>Udemy</p>
</blockquote>
<ul>
<li><a href="https://www.udemy.com/course/rust-programming-the-complete-guide/">The Complete Rust Programming Course | Udemy</a></li>
<li><a href="https://www.udemy.com/course/rust-fundamentals/">Learn Rust by Building Real Applications | Udemy</a>
<ul>
<li>用了一半篇幅来介绍内存管理模型,以及 GDB 观察过程...</li>
</ul>
</li>
</ul>
<blockquote>
<p>Youtube</p>
</blockquote>
<ul>
<li>110+<a href="https://www.youtube.com/playlist?list=PL3azK8C0kje1DUJbaOqce19j3R_-tIc4_">Rust 编程语言入门教程 [2021] - YouTube</a>
<ul>
<li>42+<a href="https://www.youtube.com/playlist?list=PLVvjrrRCBy2JSHf9tGxGKJ-bYAN_uDCUL">RUST PROGRAMMING TUTORIALS - YouTube</a></li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW">Intro to Rust - YouTube</a></li>
<li>14+<a href="https://www.youtube.com/playlist?list=PLKkEWK6xRmes17LQUEA5bNjYISuCEOTXx">Rust For Starters - YouTube</a></li>
</ul>
</li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8">The Rust Lang Book - YouTube</a></li>
<li>25+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDD5vy2BuSHvFZU0a6RDmgb">Rust Projects - YouTube</a>
<ul>
<li>24+<a href="https://www.youtube.com/playlist?list=PL5dTjWUk_cPYuhHm9_QImW7_u4lr5d6zO">50 RUST Projects - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/@jonhoo">Jon Gjengset - YouTube</a>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFgY2faCIYjJZv_RluGkTlKt">Rust live-coding - YouTube</a>
<ul>
<li>都是几个小时的连续调试过程</li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">Crust of Rust - YouTube</a></li>
</ul>
</li>
</ul>
<pre><code>      _~`|-~_
  \/ /  - =  \ \/
    '_   ⏝   _'
    ( '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-丑句法"><a class="header" href="#rust-丑句法">Rust 丑句法</a></h1>
<p>原文: <a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html#Rust-s-Ugly-Syntax">Rust's Ugly Syntax</a></p>
<h2 id="快译-4"><a class="header" href="#快译-4">快译</a></h2>
<p>大家抱怨 Rust 的语法;
不过,俺想大多数时候,
当人们认为在对 Rust 语法有疑问时,
实际上在反抗对应语义;
在这篇有点儿异想天开的文章中,
俺将尝试理清这两点;</p>
<p>先从一个丑陋的语法示例开始:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}</span></code></pre></pre>
<p>此函数读取给定二进制文件内容;
这是直接从标准库中提取的, 所以, 不算是稻草人式无用示例;
而且,至少对俺来说, 这绝对不算漂亮;</p>
<p>让我们想象一下,如果 Rust 有更好的语法, 这个函数应该是什么样儿;
如果和真正的编程语言有任何相似之处, 无论真假, 纯属试合!</p>
<p>从 Rs++ 开始:</p>
<pre><code class="language-c++">template&lt;std::HasConstReference&lt;std::Path&gt; P&gt;
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
std::read(P path) {
    return read_(path.as_reference());
}

static
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
read_(&amp;auto const std::Path path) {
    auto file = try std::File::open(path);
    std::vector bytes;
    try file.read_to_end(&amp;bytes);
    return okey(bytes);
}
</code></pre>
<p>Rhodes 变体:</p>
<pre><code class="language-ruby">public io.Result&lt;ArrayList&lt;Byte&gt;&gt; read&lt;P extends ReferencingFinal&lt;Path&gt;&gt;(
        P path) {
    return myRead(path.get_final_reference());
}

private io.Result&lt;ArrayList&lt;Byte&gt;&gt; myRead(
        final reference lifetime var Path path) {
    var file = try File.open(path);
    ArrayList&lt;Byte&gt; bytes = ArrayList.new();
    try file.readToEnd(borrow bytes);
    return Success(bytes);
}
</code></pre>
<p>经典 RhodesScript:</p>
<pre><code class="language-js">public function read&lt;P extends IncludingRef&lt;Path&gt;&gt;(
    path: P,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    return myRead(path.included_ref());
}

private function myRead(
    path: &amp;const Path,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    let file = try File.open(path);
    Array&lt;byte&gt; bytes = Array.new()
    try file.readToEnd(&amp;bytes)
    return Ok(bytes);
}
</code></pre>
<p>响尾蛇/Rattlesnake:</p>
<pre><code class="language-python">def read[P: Refing[Path]](path: P): io.Result[List[byte]]:
    def inner(path: @Path): io.Result[List[byte]]:
        file := try File.open(path)
        bytes := List.new()
        try file.read_to_end(@: bytes)
        return Ok(bytes)
    return inner(path.ref)
</code></pre>
<p>以及, CrabML:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>read :: 'p  ref_of =&gt; 'p -&gt; u8 vec io.either.t
let read p =
  let
    inner :: &amp;path -&gt; u8 vec.t io.either.t
    inner p =
      let mut file = try (File.open p) in
      let mut bytes = vec.new () in
      try (file.read_to_end (&amp;mut bytes)); Right bytes
  in
    ref_op p |&gt; inner
;;
<span class="boring">}</span></code></pre></pre>
<p>作为一个稍微严肃和有用的练习,
让我们作相反的尝试--保留 Rust 语法,
但是, 尝试简化语义直到最终结果, 看会是什么样儿;</p>
<p>这是我们的起点:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}</span></code></pre></pre>
<p>这时, 最大的噪音源是嵌套函数;
动机有点儿深奥;
外部函数是通用的,而内部不是;
使用编译模式,这意味着外部函数和用户代码一起编译,
而嵌的将优化;
相比之下, 内部函数是在编译 std 本身时编译的,
从而节省了编译用户代码的时间;
简化这一点(损失一些性能)的一种方法,
说是泛型函数总是单独编译,
但是,能在幕后接受一个额外的运行时秋粮, 可以描述物理维度上的输入参数;</p>
<p>这样我们获得:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path.as_ref())?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>下个噪音元素是 <code>&lt;P: AsRef&lt;Path&gt;&gt;</code> 约束;
这是必需的,因为 Rust 喜欢将内存中字节的物理布局作为接口公开,
特别是对可以带来性能的情况;
特殊的, Path 的含义并不是文件路径的某种抽象,
这里只是字面意义上内存中的一堆连续字节;
所以, 我们需要 AsRef 来将其和任何能够表示这种字节片的抽象一起工作;
但是, 如果我们不关心性能,
就可以要求所有接口都相当抽象,并通过虚函数调用进行调解,
而不是直接访问内存;
那么, 我们就不需要 AsRef 这堆东西了:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>这样简化后,我们实际上也可以摆脱 <code>Vec&lt;u8&gt;</code> -- 如果我们不再使用泛型来表达语言本身的高效可增长字节数组;
我们必须使用运行时提供的一些不透明字节类型:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Bytes&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Bytes::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>从技术上讲,我们仍然随身携带所有权和备用系统,
但是,由于无法直接控制类型的内存布局,
就无法带来巨大的性能优势;
仍然有助于避免 GC,防止迭代器失效,
并静态检验非线程安全代码是否实际上没有跨线程使用;
不过, 如果我们只切换到 GC, 我们可以轻松摆脱那些 &amp;指针;
我们甚至于不需要太担心并发性--因为,我们的对象是单独分配的,而且总是在指针后面,
我们可以通过注意到指针大小,
无论是否在 x86 系统上都是原子操作来消除数据竞争;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; io::Result&lt;Bytes&gt; {
  let file = File::open(path)?;
  let bytes = Bytes::new();
  file.read_to_end(bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>最后,我们在这对错误的处理过于迂腐 -- 我们并仅要关注返回类型失败的可能,
甚至于要用 ? 来突出指示任何可能失败的特定表达式;
完全不考虑错误处理,
让一些顶层处理程序来处理:
(比如: try { } catch (...) { /* intentionally empty */ })</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; Bytes {
  let file = File::open(path);
  let bytes = Bytes::new();
  file.read_to_end(bytes);
  bytes
}
<span class="boring">}</span></code></pre></pre>
<p>现在是否好多了?</p>
<h2 id="ps"><a class="header" href="#ps">PS:</a></h2>
<p>的确是篇奇想, 这样简化后, 几乎就是 多了一些控制符号的 Python 了,
又或是根本可以视为 TypeScript 了;
当然, 如果有这种低效版 Rust 多数程序员还是愿意使用的;
就象当年 CoffeeScript 的尝试;</p>
<h2 id="logging-31"><a class="header" href="#logging-31">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230206 ZQ init.</li>
</ul>
<pre><code>       _~^*`~_
   \) /  &gt; #  \ (/
     '_   ⏝   _'
     | '-----' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图形描述-rust-中所有权和借用"><a class="header" href="#图形描述-rust-中所有权和借用">图形描述 Rust 中所有权和借用</a></h1>
<p>原文: <a href="https://rufflewind.com/2017-02-15/rust-move-copy-borrow">Graphical depiction of ownership and borrowing in Rust - Rufflewind's Scratchpad</a></p>
<h2 id="快译-5"><a class="header" href="#快译-5">快译:</a></h2>
<p>以下是 Rust 语言中 moving, copying, 和 borrowing 的图形描述;
这些概念中的大多数是 Rust 持有的,
因此, 也是很多学习者常见绊脚石;</p>
<p>为了避免图形混乱, 尽量减少了文字;
并不是要取代现有各种教程, 而是为喜欢直观理解概念的程序员提供不同的视角;
如果你正在学习 Rust 并发现这些图形有报时,
建议你使用这类图表注释自己的代码以便帮助巩固概念 ;-)</p>
<h2 id="rust-中所有权和借用"><a class="header" href="#rust-中所有权和借用">Rust 中所有权和借用</a></h2>
<p><img src="https://rufflewind.com/img/rust-move-copy-borrow.png" alt="" /></p>
<p>可以通过点击图像来放大, 也可以下载 <a href="https://rufflewind.com/img/rust-move-copy-borrow.svg">SVG</a>
和 <a href="https://rufflewind.com/img/rust-move-copy-borrow.pdf">PDF</a> 版本在本地放大;</p>
<p>上面的图形描述了你拥有数据的两种主要语义: 移动或是复制;</p>
<p>关于移动的解释(~&gt;)看起来太简单了;
这里没有把戏: 移动语义本身就很奇怪,因为,大多数语言允许变量被程序员随意使用多次;
这和现实世界的大部分情况形成鲜明对比:
我不能把我的笔给别人,然后,仍然用它继续写字!
在 Rust 中,任何类型未实现 Copy trait 的变量都具有移动语义,
并且会像所示那样运行;</p>
<p>复制语义(⎘)是为实现 Copy trait 的类型保留的;
在这种情况中, 对象的每次使用都会产生一个副本, 正如所示分叉; 中间的两个数字描绘了你可以借用你拥有物品的两种方式,
以及每种方式提供的操作;</p>
<p>对于可变借用, 我使用了锁符号(🔒)来表示原始对象在借用期间被有效锁定,
令其无法使用;</p>
<p>相反,对于非可变备用, 我使用了雪花符号(❄)来表示原始对象只是被冻结了:
你仍然可以获取更多非可变引用, 但是, 你不能移动或是获取其可变引用;</p>
<p>在这两个图中, <code>'ρ</code> 是我为引用的生命周期选择的名称;
我故意使用希腊字母是因为目前 Rust 中还没有具体生命周期的语法;</p>
<p>最后两个图以图形和文本形式总结了两种引用之间的主要区别和相似之处;
在这种场景中&quot;外部(<a href="https://doc.rust-lang.org/beta/book/mutability.html#interior-vs-exterior-mutability">exteriorly</a>)&quot;限定词很重要,
因为, 你仍然可以通过类似 <a href="https://doc.rust-lang.org/std/cell/">Cell</a> 的东西拥有内部可变性;</p>
<h2 id="logging-32"><a class="header" href="#logging-32">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230220 ZQ init.</li>
</ul>
<pre><code>      _~-|`~_
  () /  * *  \ ()
    '_   ⎕   _'
    | '--∽--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0基础入门c"><a class="header" href="#0基础入门c">0基础入门C?</a></h1>
<blockquote>
<p>突然被问</p>
</blockquote>
<h2 id="background-28"><a class="header" href="#background-28">background</a></h2>
<p>不是问怎么修电脑就不错了</p>
<h2 id="goal-34"><a class="header" href="#goal-34">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>最小最快最有效果的自学...</p>
<h2 id="trace-30"><a class="header" href="#trace-30">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>TBD...</p>
<h2 id="refer-42"><a class="header" href="#refer-42">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p>私人推荐图书:</p>
<ul>
<li>入门:
<ul>
<li><a href="https://book.douban.com/subject/25703412/">嗨翻C语言 (Head First C)</a></li>
<li>配套: 
<ul>
<li><a href="https://book.douban.com/subject/23779374/">明解C语言 (柴田望洋)</a></li>
<li><a href="https://wizardforcel.gitbooks.io/lcthw/content/">笨办法学C 中文版 · 笨办法学C</a></li>
</ul>
</li>
</ul>
</li>
<li>进一步的:
<ul>
<li><a href="https://book.douban.com/subject/1139336/">C程序设计语言（第2版·新版)</a></li>
<li><a href="https://book.douban.com/subject/3012360/">C和指针</a></li>
<li><a href="https://book.douban.com/subject/3775842/">C标准库</a></li>
<li><a href="https://book.douban.com/subject/4141733/">Linux C编程一站式学习 (豆瓣)</a>
<ul>
<li><a href="https://linux-c-learning-all-in-one.readthedocs.io/zh_CN/latest/">Linux C编程一站式学习 — Linux C编程一站式学习 rc 文档</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>足够了,基本上都有免费电子版本...</p>
<h2 id="logging-33"><a class="header" href="#logging-33">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<pre><code>           _~∽|^~_
       \/ /  ◷ ◵  \ (/
         '_   𝟂   _'
         &gt; '--⌄--' |

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
</code></pre>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->


                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">

        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
    </script>


    <!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/custom.js"></script>
    <script type="text/javascript" src="assets/bigPicture.js"></script>

    <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>
    <hr />

    <p style="text-align:center">

        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议"
                style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
        本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可;-)
][ <b>
    <a href="/rss.xml">RSS</a>
    </b>

    </p>
    <hr />

    <script src="https://utteranc.es/client.js" repo="zhrust/comments" issue-term="pathname" label="✨💬✨"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>

</html>