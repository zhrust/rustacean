<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>be Rustaceans</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

</head>

<body>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script>
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="abt/index.html"><strong aria-hidden="true">1.</strong> 有关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abt/gh-pages.html"><strong aria-hidden="true">1.1.</strong> gh-pages</a></li><li class="chapter-item expanded "><a href="abt/zhrust.html"><strong aria-hidden="true">1.2.</strong> zhrust</a></li></ol></li><li class="chapter-item expanded "><a href="101/index.html"><strong aria-hidden="true">2.</strong> 学习</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="101/graph-rust-move-copy-borrow.html"><strong aria-hidden="true">2.1.</strong> 图形描述 Rust 中所有权和借用</a></li><li class="chapter-item expanded "><a href="101/exercism.html"><strong aria-hidden="true">2.2.</strong> Exercism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="101/ex42all-your-base.html"><strong aria-hidden="true">2.2.1.</strong> 42:all-your-base</a></li><li class="chapter-item expanded "><a href="101/ex43Allergies.html"><strong aria-hidden="true">2.2.2.</strong> 43:Allergies</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="dev/index.html"><strong aria-hidden="true">3.</strong> 开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/20-things-ive-learned-in-my-20-years-as-a-software-engineer.html"><strong aria-hidden="true">3.1.</strong> 20年来作为软件工程师学到的10件事</a></li><li class="chapter-item expanded "><a href="dev/concepts-i-wish-i-learned-earlier.html"><strong aria-hidden="true">3.2.</strong> 希望一早知道的关键概念</a></li></ol></li><li class="chapter-item expanded "><a href="tip/index.html"><strong aria-hidden="true">4.</strong> 技巧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tip/rust6fun-operator-overloading.html"><strong aria-hidden="true">4.1.</strong> 运算符重载六件趣事</a></li><li class="chapter-item expanded "><a href="tip/oop-1-encapsulation.html"><strong aria-hidden="true">4.2.</strong> Rust 超越面向对象,第1部分</a></li><li class="chapter-item expanded "><a href="tip/oop-2-polymorphism.html"><strong aria-hidden="true">4.3.</strong> Rust 超越面向对象,第2部分</a></li><li class="chapter-item expanded "><a href="tip/default-params.html"><strong aria-hidden="true">4.4.</strong> OOP:Rust 和默认参数</a></li></ol></li><li class="chapter-item expanded "><a href="log/index.html"><strong aria-hidden="true">5.</strong> 笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="log/rust-s-ugly-syntax.html"><strong aria-hidden="true">5.1.</strong> Rust 丑句法</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">be Rustaceans</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/zhrust/rustacean/tree/main/src" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script>
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="有关"><a class="header" href="#有关">有关</a></h1>
<blockquote>
<p>as Zoom.Quiet</p>
</blockquote>
<h2 id="main-index"><a class="header" href="#main-index">main index</a></h2>
<p><a href="https://zoomquiet.io/">mapping -&gt; ZoomQuiet.io {by gen4dot2htm.py vv.190718 at:190911 18:07:32,877571}</a></p>
<h2 id="location"><a class="header" href="#location">location</a></h2>
<h2 id="actions"><a class="header" href="#actions">actions</a></h2>
<p>...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gh-pages"><a class="header" href="#gh-pages">gh-pages</a></h1>
<blockquote>
<p>免费使用的成本</p>
</blockquote>
<h2 id="background"><a class="header" href="#background">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>凡是可以编译为 静态网站 的, 都可以通过 gh-pages/GitHub-Pages 服务来进行免费发布;</p>
<h2 id="goal"><a class="header" href="#goal">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
本地编译好, 嘦 git push ,一切就可以自动完成发布</li>
<li><input disabled="" type="checkbox"/>
而且发布到指定域名</li>
</ul>
<h2 id="trace"><a class="header" href="#trace">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<h2 id="refer"><a class="header" href="#refer">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages">验证 GitHub Pages 的自定义域 - GitHub Docs</a></li>
</ul>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zhrust"><a class="header" href="#zhrust">zhRust</a></h1>
<blockquote>
<p>zn.rust 域名</p>
</blockquote>
<h2 id="background-1"><a class="header" href="#background-1">background</a></h2>
<blockquote>
<p>名正言顺</p>
</blockquote>
<p>Ｒust 发布时间不短了,
rust 相关中文社区比当年 Python 的多不少,
所以, 2022年未很难找到简短好记的域名可以注册了</p>
<h2 id="goal-1"><a class="header" href="#goal-1">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>但是, 总是要有一个 Rust 方向的持续输出域名, 
要求从来不变</p>
<ul>
<li>rust,rustacean 相关</li>
<li>越短越好</li>
<li>越便宜越好</li>
<li>...</li>
</ul>
<h2 id="trace-1"><a class="header" href="#trace-1">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li>原先有 101.camp,101.so 所以尝试 rust.so, 已经没有</li>
<li>又尝试 rustacean.so 还有,只是贵而且又长...</li>
<li>那么 在 namecheap.com 再挖掘一下, 没想到
<ul>
<li>.rust 竟然有这个根域名</li>
<li>立即先注册 cn.rust 以及 china.rust</li>
</ul>
</li>
<li>可惜几天过去 dig 指令依然查不到记录,看来 <code>.rust</code> 还是一个预备根域名,至少中国根还不识别..
<ul>
<li>只能恢复使用 <code>rs.101.so</code> 这个域名</li>
<li>另外将 <code>weekly.rs.101.so</code> 也发布出来开始坚持关注每周社区关键变化...</li>
</ul>
</li>
</ul>
<h2 id="refer-1"><a class="header" href="#refer-1">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-1"><a class="header" href="#logging-1">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230101 ZQ 变更域名指向</li>
<li>221230 ZQ init.
<ul>
<li>迁移 utterances 🔮 评注到 https://github.com/zhrust/comments</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学习"><a class="header" href="#学习">学习</a></h1>
<blockquote>
<p>learnning ...</p>
</blockquote>
<h2 id="background-2"><a class="header" href="#background-2">background</a></h2>
<blockquote>
<p>可能背景</p>
</blockquote>
<p>和其它语言不同, Rust 有太多公开的秘密,如果不能快速先习惯一批,
很难写出可以运行的软件来...</p>
<h2 id="goal-2"><a class="header" href="#goal-2">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>最常用的那 20% Rust 常识...</p>
<h2 id="trace-2"><a class="header" href="#trace-2">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<h2 id="refer-2"><a class="header" href="#refer-2">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<h3 id="youtube"><a class="header" href="#youtube">Youtube</a></h3>
<blockquote>
<p>真的是什么都有</p>
</blockquote>
<ul>
<li>各种劝解:
<ul>
<li><a href="https://www.youtube.com/watch?v=sDtQaO5_SOw">Rust Linz, June 2021 - Tim McNamara - How to learn Rust - YouTube</a></li>
</ul>
</li>
<li>110+<a href="https://www.youtube.com/playlist?list=PL3azK8C0kje1DUJbaOqce19j3R_-tIc4_">Rust 编程语言入门教程 [2021] - YouTube</a>
<ul>
<li>42+<a href="https://www.youtube.com/playlist?list=PLVvjrrRCBy2JSHf9tGxGKJ-bYAN_uDCUL">RUST PROGRAMMING TUTORIALS - YouTube</a></li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW">Intro to Rust - YouTube</a></li>
<li>14+<a href="https://www.youtube.com/playlist?list=PLKkEWK6xRmes17LQUEA5bNjYISuCEOTXx">Rust For Starters - YouTube</a></li>
</ul>
</li>
<li>44+<a href="https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8">The Rust Lang Book - YouTube</a></li>
<li>25+<a href="https://www.youtube.com/playlist?list=PLJbE2Yu2zumDD5vy2BuSHvFZU0a6RDmgb">Rust Projects - YouTube</a>
<ul>
<li>24+<a href="https://www.youtube.com/playlist?list=PL5dTjWUk_cPYuhHm9_QImW7_u4lr5d6zO">50 RUST Projects - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/@jonhoo">Jon Gjengset - YouTube</a>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFgY2faCIYjJZv_RluGkTlKt">Rust live-coding - YouTube</a>
<ul>
<li>都是几个小时的连续调试过程</li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">Crust of Rust - YouTube</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLZaoyhMXgBzoM9bfb5pyUOT3zjnaDdSEP">Rust Talks - YouTube</a>
<ul>
<li>各种畅想...</li>
<li><a href="https://www.youtube.com/playlist?list=PLnhCUtqrIE-zgfmf6hn6fLwhfR_hDSG9T">Contributing to Rustc - YouTube</a> ~ 牛人直播如何为 Rust 编译器贡献特性...</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=_jMSrMex6R0&amp;list=PLFjq8z-aGyQ6t_LGp7wqHsHTYO-pDDx84">Rust - YouTube</a>
<ul>
<li>各种前景分析</li>
<li><a href="https://www.youtube.com/watch?v=qjwWF6K-7uE&amp;list=PLFjq8z-aGyQ78CQu1G3C5CT9ieiNpsnbJ">WebAssembly - YouTube</a> ~ 各种实现应用</li>
</ul>
</li>
<li>...</li>
</ul>
<h2 id="logging-2"><a class="header" href="#logging-2">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图形描述-rust-中所有权和借用"><a class="header" href="#图形描述-rust-中所有权和借用">图形描述 Rust 中所有权和借用</a></h1>
<p>原文: <a href="https://rufflewind.com/2017-02-15/rust-move-copy-borrow">Graphical depiction of ownership and borrowing in Rust - Rufflewind's Scratchpad</a></p>
<h2 id="快译"><a class="header" href="#快译">快译:</a></h2>
<p>以下是 Rust 语言中 moving, copying, 和 borrowing 的图形描述;
这些概念中的大多数是 Rust 持有的,
因此, 也是很多学习者常见绊脚石;</p>
<p>为了避免图形混乱, 尽量减少了文字;
并不是要取代现有各种教程, 而是为喜欢直观理解概念的程序员提供不同的视角;
如果你正在学习 Rust 并发现这些图形有报时,
建议你使用这类图表注释自己的代码以便帮助巩固概念 ;-)</p>
<h2 id="rust-中所有权和借用"><a class="header" href="#rust-中所有权和借用">Rust 中所有权和借用</a></h2>
<p><img src="https://rufflewind.com/img/rust-move-copy-borrow.png" alt="" /></p>
<p>可以通过点击图像来放大, 也可以下载 <a href="https://rufflewind.com/img/rust-move-copy-borrow.svg">SVG</a>
和 <a href="https://rufflewind.com/img/rust-move-copy-borrow.pdf">PDF</a> 版本在本地放大;</p>
<p>上面的图形描述了你拥有数据的两种主要语义: 移动或是复制;</p>
<p>关于移动的解释(~&gt;)看起来太简单了;
这里没有把戏: 移动语义本身就很奇怪,因为,大多数语言允许变量被程序员随意使用多次;
这和现实世界的大部分情况形成鲜明对比:
我不能把我的笔给别人,然后,仍然用它继续写字!
在 Rust 中,任何类型未实现 Copy trait 的变量都具有移动语义,
并且会像所示那样运行;</p>
<p>复制语义(⎘)是为实现 Copy trait 的类型保留的;
在这种情况中, 对象的每次使用都会产生一个副本, 正如所示分叉; 中间的两个数字描绘了你可以借用你拥有物品的两种方式,
以及每种方式提供的操作;</p>
<p>对于可变借用, 我使用了锁符号(🔒)来表示原始对象在借用期间被有效锁定,
令其无法使用;</p>
<p>相反,对于非可变备用, 我使用了雪花符号(❄)来表示原始对象只是被冻结了:
你仍然可以获取更多非可变引用, 但是, 你不能移动或是获取其可变引用;</p>
<p>在这两个图中, <code>'ρ</code> 是我为引用的生命周期选择的名称;
我故意使用希腊字母是因为目前 Rust 中还没有具体生命周期的语法;</p>
<p>最后两个图以图形和文本形式总结了两种引用之间的主要区别和相似之处;
在这种场景中&quot;外部(<a href="https://doc.rust-lang.org/beta/book/mutability.html#interior-vs-exterior-mutability">exteriorly</a>)&quot;限定词很重要,
因为, 你仍然可以通过类似 <a href="https://doc.rust-lang.org/std/cell/">Cell</a> 的东西拥有内部可变性;</p>
<h2 id="logging-3"><a class="header" href="#logging-3">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230220 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercism"><a class="header" href="#exercism">Exercism</a></h1>
<blockquote>
<p>练习主义</p>
</blockquote>
<h2 id="background-3"><a class="header" href="#background-3">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/about">About Exercism</a></p>
<p>是一个神奇的网站</p>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.30.38.jpg" alt="" /></p>
<p>一是个专注用练习题来学习各种开发语言的网站,
免费,包含越来越多的语言</p>
<h2 id="goal-3"><a class="header" href="#goal-3">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust">Rust on Exercism</a></p>
<p>至少先刷完这 103 道题目, 然后, 再开发具体的实用工具;</p>
<h2 id="trace-3"><a class="header" href="#trace-3">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p><img src="https://ipic.zoomquiet.top/2022-12-14-zshot%202022-12-14%2021.31.48.jpg" alt="rust" /></p>
<p>不过最终是乱序来的</p>
<h2 id="refer-3"><a class="header" href="#refer-3">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<p><a href="https://cheats.rs/">Rust Language Cheat Sheet</a></p>
<ul>
<li><a href="https://juejin.cn/post/7146144676532191262">16｜数据结构：Vec<T>、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？ - 掘金</a></li>
<li>...</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a16a825f50d4d34866d432c15fa3ebd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="" /></p>
<h2 id="logging-4"><a class="header" href="#logging-4">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221214 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rs42all-your-base"><a class="header" href="#rs42all-your-base">rs42all-your-base</a></h1>
<blockquote>
<p>所有进制</p>
</blockquote>
<h2 id="background-4"><a class="header" href="#background-4">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/docs/tracks/rust">All Your Base in Rust on Exercism</a></p>
<h2 id="logging-5"><a class="header" href="#logging-5">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id="try_fold"><a class="header" href="#try_fold">try_fold()</a></h3>
<blockquote>
<p>表达能力的典范...</p>
</blockquote>
<h2 id="refer-4"><a class="header" href="#refer-4">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Positional_notation#External_links">Positional notation - Wikipedia</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html">Iterator in std::iter - Rust</a>
<ul>
<li><a href="https://qiita.com/lo48576/items/34887794c146042aebf1">Rustのイテレータの網羅的かつ大雑把な紹介 - Qiita</a></li>
<li><a href="https://zenn.dev/megeton/articles/fb6266bcb6aa1b">Ruby脳のためのRust配列系メソッドまとめ</a></li>
<li>...</li>
</ul>
</li>
<li><a href="https://rustcc.cn/article?id=2f4b3a15-7874-4c68-b9d8-5a717e9a3af0">rust新手的一个问题：fold和scan。 - Rust语言中文社区</a>
<ul>
<li><a href="https://juejin.cn/post/7067102952602746910">抛弃Rust的try...catch和null检查 - 掘金</a></li>
<li>...</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ex43allergies"><a class="header" href="#ex43allergies">ex43Allergies</a></h1>
<blockquote>
<p>过敏源</p>
</blockquote>
<h2 id="background-5"><a class="header" href="#background-5">background</a></h2>
<blockquote>
<p>具体背景</p>
</blockquote>
<p><a href="https://exercism.org/tracks/rust/exercises/allergies">Allergies in Rust on Exercism</a></p>
<h2 id="logging-6"><a class="header" href="#logging-6">logging</a></h2>
<blockquote>
<p>记要</p>
</blockquote>
<h3 id=""><a class="header" href="#">&amp;</a></h3>
<blockquote>
<p>现实世界的 与计算</p>
</blockquote>
<h2 id="refer-5"><a class="header" href="#refer-5">refer.</a></h2>
<blockquote>
<p>各种参考</p>
</blockquote>
<ul>
<li><a href="https://hltj.me/lang/2016/11/07/10m-letters.html">由“千万字母表问题”看多范式编程语言 | 灰蓝时光</a>
<ul>
<li><a href="http://www.nct9.ne.jp/m_hiroi/linux/rust14.html">Linux Programming / お気楽 Rust プログラミング超入門</a></li>
</ul>
</li>
<li>...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<blockquote>
<p>projects ...</p>
</blockquote>
<h2 id="background-6"><a class="header" href="#background-6">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>开发语言学习, 不用来开发真实项目, 基本是表演学习行为了...</p>
<h2 id="goal-4"><a class="header" href="#goal-4">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>一组日常要用工具, 原创/再制/...</p>
<p>关键是积累一组可用作品, 打底儿.</p>
<h2 id="trace-4"><a class="header" href="#trace-4">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>???</p>
<h2 id="refer-6"><a class="header" href="#refer-6">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-7"><a class="header" href="#logging-7">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20年来作为软件工程师学到的20件事"><a class="header" href="#20年来作为软件工程师学到的20件事">20年来作为软件工程师学到的20件事</a></h1>
<p>原文: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/">20 Things I've Learned in my 20 Years as a Software Engineer - Simple Thread</a></p>
<h2 id="注意请先阅读此内容"><a class="header" href="#注意请先阅读此内容">注意:请先阅读此内容</a></h2>
<p>即将展现的是一篇包含大量建议的 blog ;
向前人学习对成功至关重要,但是,我们常常忘记另外一个重要警告:
几乎所有的建议都是上下文相关的, 但是,很少对上下文提供细节;</p>
<p>&quot;你需要收取更多费用!&quot; 这经营了20年的公司说, 多年以来收费&quot;太低&quot;,无法赢得客户并取得成功;</p>
<p>&quot;你需要将一切构建为微服务!&quot; 该公司表示, 构建了一个快速的整体,获得了数千客户,然后,在开始遇到问题时, 全面转向了微服务;</p>
<p>如果不了解上下文, 建议就毫无意义,甚至更糟糕,有害;
如果那些人早点听从他们自己的建议,他们自己可能会因此受苦;
对于任何建议很难逃脱这个陷阱;
我们可能是我们经历的终点,但是,我们却是通过现在的镜头来观察;</p>
<p>因此,为了让你了解一下这些建议的来源,特此说明:
我在职业生涯的前半段担当软件工程师,为各种小型企业和初创公司工作,
然后,我进入咨询行业并在许多非常太的企业工作;
最后, 我开创了 <code>Simple Thread</code>,
我们从一个2人团队成长为一个25人的团队;
10年前, 我们主要和中小型企业合作,现在我们和大型和小型企业合作;</p>
<p>我的所有建议来自于:</p>
<ul>
<li>几乎总是在小而精干的团队中,我们必须用很少的资源作很多事情</li>
<li>重视工作软件而不是特定工具</li>
<li>一直在开始新项目,同时还要维护一些系统</li>
<li>重视工程师的生产力,超过其它大多数考虑因素</li>
<li>...</li>
</ul>
<p>我过去20年的经历塑造了对软件的偏见,
并使我形成了一些信念;
我试图将这些信念压缩为一个易于使用的列表,
希望你能发现她们的价值;</p>
<h2 id="建议清单"><a class="header" href="#建议清单">建议清单:</a></h2>
<h3 id="1-我仍然懂的不是太多"><a class="header" href="#1-我仍然懂的不是太多">1. 我仍然懂的不是太多</a></h3>
<p>&quot;你怎么不知道 BGP ?&quot;</p>
<p>&quot;你从来没听说过 Rust?&quot;</p>
<p>我们大多数人都被人这么说过,
而且可能听的太频繁了;
我们中许多人喜欢软件的原因就是因为我们是终身学习者, 在软件领域,
无论你从哪个方向看, 都有广阔的知识前景向各个方向发展,
而且每天都在扩展;
这意味着即便你在职业生涯中度过数十年,
但是, 和同样在看似相似的角色中度过数十年的人相比,
仍然存在巨大的知识差距;
越早意识到这点, 就能越早开始摆脱 &quot;顶替者综合症&quot; ,
转而乐于向他人学习和教导他人;</p>
<h3 id="2-软件最难的部分是构建正确的东西"><a class="header" href="#2-软件最难的部分是构建正确的东西">2. 软件最难的部分是构建正确的东西</a></h3>
<p>我知道在这点上算陈词滥调,
但是, 大多数软件工程师并不相信的原因是, 他们认为这在贬低他们的工作;
我个人认为这是无稽之谈；
相反,这突出了我们必须工作的环境本身复杂性和不合理性,
这故居了我们的挑战;
你可以设计出世界上技术上最令人印象深刻的东西,
然后, 却无人愿意使用;
这种事儿一直在发生;
设计软件主要是一种倾听活动,
我们经常不得不成为竕软件工程师, 部分通灵师, 以及部分人类学家;
投资在这个设计过程, 无论是通过专门的 UX 团队, 还是通过简单的自我教育,
都将带来巨大的回报;
因为, 你如何计算构建错误软件的真正成本?
这不仅仅是损失工程时间...</p>
<h3 id="3-最好的软件工程师像设计师一样思考"><a class="header" href="#3-最好的软件工程师像设计师一样思考">3. 最好的软件工程师像设计师一样思考</a></h3>
<p>伟大的软件工程师会思考他们代码的用户体验;
他们可能不会用各种术语来考虑,
而是考虑应该是外部API/编程API/用户界面/协议还是其它任何界面;
伟大的工程师会考虑谁将使用, 为什么要使用,如何使用,
以及这些对用户来说什么是最重要的;
牢记用户的需求, 确认是良好用户体验的核心;</p>
<h3 id="4-最好的代码是没有代码或是你不必维护的"><a class="header" href="#4-最好的代码是没有代码或是你不必维护的">4. 最好的代码是没有代码,或是你不必维护的</a></h3>
<p>我只想说: &quot;码农只能编码&quot;;
你问任何行业的人如何解决问题, 
他们都会在他们擅长的领域犯错误;
叫只是人性;
大多数软件工程师总是会在编写代码时出错,
尤其是当非技术解决方案不明朗时;
你不必维护的代码也是如此;
当很多轮子已经存在时,
工程团队很容易想要重新发明轮子;
这是一种平衡行为, 
有很多理由让你自己再来一遍,
但是, 要提防这种 &quot;没在此现实&quot;(“Not Invented Here”) 综合症;</p>
<h3 id="5-软件是达到目的的手段"><a class="header" href="#5-软件是达到目的的手段">5. 软件是达到目的的手段</a></h3>
<p>任何软件工程师的主要工作是交付价值;</p>
<p>很少有软件开发者理解这一点, 将其内化的就更少了;
真正将其内化后, 能导致解决问题的不同方式,
以及观察工具的不同方式;
如果真真的相信软件是从属于结果的,
你就会准备好找到真正&quot;适合的工具&quot;,
有时可能根本不是软件;</p>
<h3 id="6-有时你必须停止磨锯直接开始砍屎"><a class="header" href="#6-有时你必须停止磨锯直接开始砍屎">6. 有时你必须停止磨锯,直接开始砍屎</a></h3>
<p>有些人倾向于跳入问题, 并立即开始编写代码;
其它人往往想要研究和陷入硬件分析进而瘫痪;
在这些情况中,为自己设定一个截止日期,
然后, 开始探索解决方案;
当你开始解决问题时,你很快能学习到更多,
这也将引导你迭代到更好的解决方案;</p>
<h3 id="7-如果你不能很好的理解所有可能性-就无法设计出好的系统"><a class="header" href="#7-如果你不能很好的理解所有可能性-就无法设计出好的系统">7. 如果你不能很好的理解所有可能性, 就无法设计出好的系统</a></h3>
<p>这是我一直在努力解决的问题,
因为, 我的职责使我在软件工程的日常工作中越来越远;
峎上开发者生态是一项巨大的工作,
但是,了解什么是可能的至关重要;
如果你不了解给定生态中有什么是可能的,以及什么是可用的,
那么你将发现除了最简单的问题之外,
不可能设计出一个合理的解决方案来解决所有问题;
总而言之, 要警惕那些很长时间没有编写任何代码的架构专家;</p>
<h3 id="8-每个的了了的都很糟粕克服丫的"><a class="header" href="#8-每个的了了的都很糟粕克服丫的">8. 每个的了了的都很糟粕,克服丫的</a></h3>
<p>Bjarne Stroustrup 有句名言:
&quot;只有两种语言: 人们抱怨的语言, 和没人使用的语言&quot;;</p>
<p>这也可以拓展到大型系统;
没有&quot;正确&quot;的架构, 你永远无法偿还所有技术债务,
你永远无法设计出完美的界面,
你的测试总是太慢;
这不是永不让事情变得更好的借口,
而是一种给你观点的方式;
少担心优雅和完美;
相反, 努力持续改进并创建一个你的团队喜欢在其中工作,
并可以持续创造价值的宜人系统;</p>
<h3 id="9-无人问足为什么"><a class="header" href="#9-无人问足为什么">9. 无人问足&quot;为什么&quot;</a></h3>
<p>抓住任何机会质疑&quot;作事方式&quot;的假设和方法;
有新人加入嘛?
注意他们在哪里感到困惑以及他们在问什么问题;
有没有无意义新功能请求?
确保你了解目标以及是什么推动了对这一功能的渴望;
如果你没有得到明确的答案,
请继续问为什么, 直到你明白为止;</p>
<h3 id="10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员"><a class="header" href="#10-我们应该更专注于避免01x-程序员而不是寻找-10x-程序员">10. 我们应该更专注于避免0.1x 程序员,而不是寻找 10x 程序员</a></h3>
<p>10倍速程序员是一个愚蠢的神话;
某人可以在1天里生产出另外一位有能力/勤奋/有类似经验的程序员需要在2周以内生产代码的想法是愚蠢的;
我见过程序员编写10倍的代码,
然后, 你必须修复它10倍以上的次数;
某珍爱可以成为10倍程序员的唯一方法,
是将他们和 0.1 倍速程序员进行比较;
有人浪费时间, 不寻求反馈, 不测试代码,
不考虑边缘情况等等...</p>
<p>我们应该关心让 0.1 倍速程序员远离我们的团队,
而不是寻找神话般的 10 倍速程序员;</p>
<h3 id="11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见"><a class="header" href="#11-高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见">11. 高级工程师和下级工程师间最大的区别之一是他们已经形成了对事情应该如何发展的偏见</a></h3>
<p>没有什么比对他们的工具或是如何构建软件没有有意见的高级工程师更让我担心的事儿了;</p>
<p>我宁愿有人给有强烈的反对意见, 也不愿他们完全没有意见;
如果你正在使用你的工具,而且你还没有更多喜欢或是讨厌的情绪,
那么, 你需要更多体验;
你需要探索其它语言/库/范例;
没有什么比积极寻找其它人如何使用和你不同的工具和技术来完成任务更快提高技能的方法了;</p>
<h3 id="12-人们并不是真想创新"><a class="header" href="#12-人们并不是真想创新">12. 人们并不是真想创新</a></h3>
<p>人们经常谈论创新,
但是, 他们通常寻找的是廉价的胜利和新奇;
如果你在真正的创新, 并想改变人们作事的方式,
那么大多数情况下都会收到负面反馈;
如果你相信自己在作的事儿,
并知道确实会改善事情,
那么为自己的长期战斗作好准备;</p>
<h3 id="13-数据是你系统中最重要的部分"><a class="header" href="#13-数据是你系统中最重要的部分">13. 数据是你系统中最重要的部分</a></h3>
<p>我见过很多系统, 其中希望数据完备性是系统主要机制;
在这种系统中,
任何在黄金路径之外发生的事情,都会心产生部分脏数据;
将来处理这些数据将是一场噩梦;
请记住, 你的数据可能会比你的代码要长寿;
花精力保持数据秩序和清洁,从长远看会有好的回报;</p>
<h3 id="14-寻找技术鲨鱼"><a class="header" href="#14-寻找技术鲨鱼">14. 寻找技术鲨鱼</a></h3>
<p>仍然存在的旧技术是鲨鱼而不是恐龙;
他们解决问题能力如此之强,以至在技术世界不断发生的快速变化中幸存下来;
不要和这些技术打赌,
只有在有充分理由的情况下才负担它们;
这些工具不会华而不实,
也不会令人兴奋,
得是不是, 它们能在没有很多不眠之夜的情况下完成工作;</p>
<h3 id="15-还要把谦逊误认为无知"><a class="header" href="#15-还要把谦逊误认为无知">15. 还要把谦逊误认为无知</a></h3>
<p>有很多软件工程师除非被直接问到,
否则不会发表意见;
永远不要认为仅仅因为有人没有将意见扔到你面前,
他们就没有什么可以补充的;
有时, 最吵闹的人是我们最不想听的;
和周围人交谈, 寻求他们的反馈和建议;
你会庆幸你这么作了;</p>
<h3 id="16-软件工程师应该定期写作"><a class="header" href="#16-软件工程师应该定期写作">16. 软件工程师应该定期写作</a></h3>
<p>软件工程师应该定期写 blog/日记/文档,
通常作需要他们保持书面沟通技巧的事儿;
写作可以帮助你思考问题,
并帮助你能更有效的和团队以及未来的自己沟通;
良好的书面沟通是任何软件工程师都必须掌握的最重要技能之一;</p>
<h3 id="17-尽可能保持流程简洁"><a class="header" href="#17-尽可能保持流程简洁">17. 尽可能保持流程简洁</a></h3>
<p>现在每个人想想变得敏捷,
但是,&quot;敏捷&quot;就是以小块的方法构建事物/学习/然后迭代;
如果有人试图在其中塞入更多东西,
那么,他们可能只是在卖东西;
这并不是说人们不需要问责或是帮助以便用这种方式协作,
但是, 你有多少次听到你最喜欢的科技公司或是大型开源项目成员有吹嘘他们的 Scrum 流程有多NB?
保持精益过程,
直到你知道你需要更多;
相信你的团队,他们能交付成果;</p>
<h3 id="18-软件工程师和所有人一样需要有主人翁精神"><a class="header" href="#18-软件工程师和所有人一样需要有主人翁精神">18. 软件工程师和所有人一样,需要有主人翁精神</a></h3>
<p>如果你将某人从他们的工作成果小分离出来,
他们就会更彡关心他们的工作;
我认为这几乎是必然的;
这是跨职能团队作的如此出色,
以及 DevOps 变得如此流行的主要原因;
这不仅仅是关于交接和效率低下,
而是关于从头到尾拥有整个过程, 并且是直接的负责交付价值;
让一群充满激情的人完全拥有设计/构建和交付软件(或任何东西)的权利,
惊人的事情就会发生;</p>
<p>(译注: 当然, 得是有意义的事务, 为领导一些幻想去努力很难有什么主人翁精神能触发)</p>
<h3 id="19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值"><a class="header" href="#19-面试对于告诉某人将成为团队成员有多赞几乎毫无价值">19. 面试对于告诉某人将成为团队成员有多赞,几乎毫无价值</a></h3>
<p>面试最好花在了解某人是谁,
以及他们对特定专业领域的兴趣程度上;
试图推测他们将成为多么优秀的团队成员是徒劳的;
相信我,
一个人有多聪明或是多博学也不能很好的证明他们将成为一名优秀的团队成员;
没有人会在面试中告诉你他们不可靠/爱辱骂/自负或是从不准时参加会议;
人们可能会声称他们对这些事情有&quot;信号&quot;...
&quot;如果他们在第一面试时询问请假,那么他们永远不会去请假!&quot;
但是, 这些都是废话;
如果你使用这种信号, 只是在猜测并拒绝优秀的候选人;</p>
<h3 id="20-始终努力构建一个更小的系统"><a class="header" href="#20-始终努力构建一个更小的系统">20. 始终努力构建一个更小的系统</a></h3>
<p>有很多力量促使你预先构建更大的系统;
预算分配, 无法测定应该精减哪些功能,
希望提供系统的&quot;最佳版本&quot;;
所有,这些事情都非常有力的推动我们构建更多;
你应该阻止这个;
你在构建一个系统时学到了很多东西,
你最终将迭代到一个比你最初设计的系统更好的版本;
令人惊讶的必须,
这对太多数人来说是难以接受的;</p>
<h2 id="你的故事呢"><a class="header" href="#你的故事呢">你的故事呢?</a></h2>
<p>这是全部了, 20年的软件生涯提炼出来的的20条精辟断言;</p>
<p>如果有什么能引发你的共鸣,
我很很听听;
我也很想知道你在职业生源中积累的智慧并愿意分享出来;
请在评论中留言吧;</p>
<h2 id="refer-7"><a class="header" href="#refer-7">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<p>很有人不同意所有观点: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/#comment-142472">January 25, 2023 at 7:25 pm</a></p>
<h3 id="hard-disagree-with-most-of-the-20-items"><a class="header" href="#hard-disagree-with-most-of-the-20-items">Hard disagree with most of the 20 items.</a></h3>
<ol>
<li>
<p>Writing software is difficult, tedious and needs real work. No silver bullet libraries, no methodology, no framework, no IOT, no amount of unit tests will get the work done faster.</p>
</li>
<li>
<p>Developers collect tools, libraries and pet technologies and make projects go over their time and budget by doing it.</p>
</li>
<li>
<p>Code should encapsulate algorithms and not be structured other wise. Code should follow the business logic and be readable and match business requirements easily.</p>
</li>
<li>
<p>Forgetting history keeps the productivity and industry down. Microsoft re-discovering the same old technology which existed on 1960s mainframes for the 7th time just to sell products, trademark buzzwords, training, certification and everything is an anchor around the modern developer’s neck. Think file transfer -&gt; X12 -&gt; serial communication -&gt; raw socket packets -&gt; corba -&gt; xml soap -&gt; xml http -&gt; Rest JSON http -&gt; gRpc as a 50 year journey of rediscovering the same thing repeatedly, each not really that much better than the older technologies, wrapping mounds of interlarded crud on top of fragile, hard to program libraries and the square peg in a round hole mismatch.</p>
</li>
<li>
<p>Refusing to hold W3C and large tech companies accountable for not fixing web HTTP, HTML, CSS and JavaScript for 25+ years.
– How can I create a control which has HTML, CSS, JS which has encapsulated CSS, encapsulated HTML, encapsulated JS without a 10,000 file framework?
– How to match HTML DOM elements with JS without using quoted magic strings? Quoted magic strings were proven anti-productivity and anti-quality in the 1960s
– How to have a UI without the everything is a call back and function pointer? Function pointers with modern wrappings are just as bad as the 1060s computed jump to function tables</p>
</li>
<li>
<p>Forgetting that tech is a business with a 7 year hype cycle, with the new thing being embryonically hyped for 2 years by cutting edge bloggers, then 2 years by sales marketing of companies, then 3 years of disappointment for companies trying to implement it. Followed by, abandonment when the ROI does not work out. Resume driven development, just for business persons.
And yes, there’s a new hype every 2 years to waste time and money on</p>
</li>
<li>
<p>Not holding tech companies accountable when they release major products, .net core, which have less than a 5 year full support lifecycle. Long term support .net is under 3 years.
That is a forced upgrade every 3 years for every .net system just to pass the IT auditors at a large company</p>
</li>
<li>
<p>Devaluing your own worth and work as a developer by telling everyone that the proposed product/task is easy. Software dev is hard work, less than 1 of a 1000 people can even do it poorly.
I would not go to a brain surgeon that told everyone that what he does is easy.</p>
</li>
<li>
<p>Forgetting that software development is a hard, tedious, isolated job where people desiring lots of human interaction will rapidly leave the field by their own choice and lots of people not getting into the field by their own choice.</p>
</li>
<li>
<p>Not telling people that you as a developer have to say “No, it’s too expensive” or “No, it’s too risky” as a regular part of your job. Persons not developing software treating you poorly with career ending consequences just because you won’t accept the death march cross to bear of impossible requirements of an impossibly short deadline</p>
</li>
<li>
<p>Not helping your fellow developers out. Speak well of your co-developers, team, and industry. Don’t downplay the difficulty, complexity or contribution of software.</p>
</li>
<li>
<p>Not calling people out when they think that more data, metrics for everything will automatically solve problems. Ask for a business case, ask for the questions they want to answer (in written form), get the business case and questions they want to answer from the requestor, make sure they are approved before committing to a tight deadline</p>
</li>
<li>
<p>Not damaging the next developer on your project – too many technologies, framework of the month, just another nuget package, one more class, have another 3 patterns, data on disk, data in database structure and consistency is not important and, yes, this system will never receive/send upstream/downstream data</p>
</li>
<li>
<p>Accepting code without parameter checking, error handling or in-line comment documentation (<em>cough</em> vendor’s happy path ‘doc’ page or <em>cough</em> signature only documentation with no example code or error handling.)</p>
</li>
<li>
<p>Misguided acceptance that best practices are best and not just a short nicely sized blog entry. Best practices, in many cases, do not scale for large 1,000,000+ line of code systems and make maintenance harder.</p>
</li>
<li>
<p>Not challenging the ‘more technology is better’ approach</p>
</li>
</ol>
<h2 id="logging-8"><a class="header" href="#logging-8">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230201 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="希望一早知道的关键概念"><a class="header" href="#希望一早知道的关键概念">希望一早知道的关键概念</a></h1>
<p>原文: <a href="https://rauljordan.com/rust-concepts-i-wish-i-learned-earlier/">rauljordan::blog</a></p>
<h2 id="快译-1"><a class="header" href="#快译-1">快译</a></h2>
<p>过去一个月里, 我被 Rust 语言彻底迷住了,
因为,她在编写内存安全的现代程序方面具有独特的优势.
多年以来, 有几种语言已经成为工程师编写弹性后端软件的首选语言.
潮流已经从 JAVA/C++ 转向 Go 和 Rust,
她们结合了数十年编程语言理论来构建我们这个时代最需要的工具.</p>
<p>Rust 的地位不言则明.
作为最受一欢迎的语言, 连续7年度在著名 <code>stack overflow</code> 调查中排名第一!
最近还作为 Linux 内核的一部分发布 -- 这是除 C 之外任何语言之前都无法作到的壮举.
对我而言, 这门语言令人兴奋的地方在于,
她在软件构建艺术方面提供了一些真正新颖的东西.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;
use std::{collections::VecDeque, sync::Condvar, sync::Mutex};

fn main() {
    let queue = Mutex::new(VecDeque::new());

    thread::scope(|s| {
        let t = s.spawn(|| loop {
            let item = queue.lock().unwrap().pop_front();
            if let Some(item) = item {
                dbg!(item);
            } else {
                thread::park();
            }
        });

        for i in 0.. {
            queue.lock().unwrap().push_back(i);
            t.thread().unpark();
            thread::sleep(Duration::from_secs(1));
        }
    })
}</code></pre></pre>
<p>Rust 在整个系统编程中获得了令人难以置信的使用, 
也因难以学习而闻名. 尽管如此, 还是有很多优秀的 Rust 内容可以满足初学者和高级程序员的需求.
然而, 他们中太多人专注解释语言的核心机制和所有权概念, 而不是构建应用程序.</p>
<p>作为一名编写高并发程序并专注在系统编程的 Go 开发者, 
我在学习如何使用 Rust 构建真实程序的过程中遇到了很多障碍. 
也就是交织, 如果我将当前正在从事的工作移植到 Rust 中, 那么所有这些教程的效果如何呢?</p>
<p>此篇文章旨在介绍我进入 Rust 兔子洞的经历, 
以及我希望一些学习资源可以更好阐述的内容. 
对个人而言, 我无法通过简单的观看 youtube 视频来学习一门新语言, 
而是必须通过为自己寻找解决方案,犯错以及对过程感受谦卑来积累．</p>
<h3 id="关于参考"><a class="header" href="#关于参考">关于参考</a></h3>
<p>Rust 中有两种引用, 共享引用(也称为 <code>借用</code>)和可变引用(也称为<code>独占引用</code>).
通常这些被视为变量 x 上的 &amp;x 以及 &amp;mut x . 
一旦我开始将后者称为&quot;独家参考&quot;, 这两白间的区别就更有意义了.</p>
<p>Rust 的参考模型相当简单. 借款人可以根据需要拥有对某对象的尽可能多的共享引用, 
但是, 一次只能有一个独占引用. 
否则, 你可能会有很多调用者同时尝试对同一个值进行修改的囧境;
如果很多借用者也可以持有独占袭用, 
你将面临未定义行为风险, 
而安全的 Rust 则不允许这么折腾.</p>
<p>在学习 Rust 时, 都用 &amp;mut 独家参考可以节省很多时间:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo {
    x: u64,
}

impl Foo {
    /// Any type that borrows an instance of Foo can
    /// call this method, as it only requires a reference to Foo.
    pub fn total(&amp;self) -&gt; u64 {
        self.x
    }
    /// Only exclusive references to instances of Foo
    /// can call this method, as it requires Foo to be mutable.
    pub fn increase(&amp;mut self) {
        self.x += 1;
    }
}

let foo = Foo { x: 10 };
println!(&quot;{}&quot;, foo.total()) // WORKS.
foo.increase() // ERROR: Foo not declared as mut
<span class="boring">}</span></code></pre></pre>
<h3 id="双向引用是可以的"><a class="header" href="#双向引用是可以的">双向引用是可以的</a></h3>
<blockquote>
<p>Bidirectional references are possible</p>
</blockquote>
<p>在其它具有垃圾收集功能的语言中, 很容易定义图形数据结构或其它包含对某些子项引用的类型, 
并且这些引用可以包含对其父项的引用;
在 Rust 中, 如果不完全理解借用规则, 这是很难作到的;
但是, 仍然可以使用标准库提供的正法.</p>
<p>假设我们有一个名为 Node 的结构, 
包含一组对子节点的引用, 以及一个对父节点的引用; 
通常, Rust 会抱怨, 但是, 我们可以通过将父引用包装在称为 <code>弱指针</code> 的东西中来满足借用检查器的要求;
这种类型告诉 Rust 一个节点消失, 或者其子节点消失, 不应该意味着父节点也应该被删除;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::{Rc, Weak};

struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这为我们提供了构建双向引用的便利原语; 
然而, 我很快发现在 Rust 中构建图形数据真的很难, 
除非你真的知道自己在作什么, 考虑到一个人需要围绕有效建模数据来作大量的 <code>book-keeping</code> 工作以满足编译器.</p>
<p>(是也乎: 编译器作为 Rust 生态中最大的 BOSS 必须优先满足.)</p>
<h3 id="实施-deref-令代码更清晰"><a class="header" href="#实施-deref-令代码更清晰">实施 Deref 令代码更清晰</a></h3>
<blockquote>
<p>Implement Deref to make your code cleaner</p>
</blockquote>
<p>有时我们希望将包装器类型视之为其包含的内容;
对于常见的数据结构(比如 vec),智能指针(例如 Box) 甚至引用计数类型(类似 Rc 和 Arc) 都是如此;
标准库包含称为 Deref 和 DerefMut 的特征, 
她们将报时你告诉 Rust 应该如何取消引用一个类型;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Deref, DerefMut};

struct Example&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Deref for Example&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.value
    }
}

impl&lt;T&gt; DerefMut for Example&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.value
    }
}

let mut x = Example { value: 'a' };
*x = 'b';
assert_eq!('b', x.value);
<span class="boring">}</span></code></pre></pre>
<p>上述示例代码中, 我们可以将 <code>*x</code> 视为其基础值 <code>&quot;a&quot;</code>, 
甚至可以改变它, 因为, 我们定义了应该如何在借用或可变引用中取消引用的规则;
这很强大, 也是你无需担心在 Box 等智能指针中包装类型的原因;</p>
<p>值被装箱的事实是一个实现细节, 可以通过这些特征抽象出来;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    value: u64,
}
let mut foo = Box::new(Foo { value: 10 });

// Box implements DerefMut, so this will work fine!
*foo = Foo { value: 20 };
// Dot methods will work on foo because Box implements Deref.
// We do not have to worry about the implementation
// detail that Foo is boxed.
assert_eq!(20, foo.value);
<span class="boring">}</span></code></pre></pre>
<h3 id="小心实现-deref-类型方法"><a class="header" href="#小心实现-deref-类型方法">小心实现 Deref 类型方法</a></h3>
<blockquote>
<p>Be careful with methods on types that implement Deref</p>
</blockquote>
<p>有没有想过, 为什么像 <code>Arc::clone</code> 这类方法的存在, 
而我们只能对 Arc 值执行 <code>.clone()</code>?
原因和类型如何实现 Deref 有关, 
这是开发者应该警惕的事儿;</p>
<p>考虑以下示例, 我们正在尝试从标准库中实现我们自己版本的
多生产者/单一消费者(mpsc)通道:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex, Condvar};

pub struct Sender&lt;T&gt; {
    inner: Arc&lt;Inner&lt;T&gt;&gt;,
}

impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;mut self, t: T) {
        ...
    }
}

impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // ERROR: Does not know whether to clone Arc or inner!
            inner: self.inner.clone(),
        }
    }
}

struct Inner&lt;T&gt; {
    ...
}

impl&lt;T: Clone&gt; Clone for Inner&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>上述示例中, 我们有一个要在其上实现 Clone 特征的 Sender 类型;
该结构有一个名为 inner 的字段, 其类型为 <code>Arc&lt;Inner&lt;T&gt;&gt;</code> ;
回想一下 Arc 已经实现了 Clone 和 Deref ;
最重要的是, 我们的 Inner 还现实了 Clone ;
对于上面的代码, Rust 并不知道我们是要克隆 Arc 还是实际的内部值,
所以, 上面代码会失败;
在这种情况下, 我们可以使用 Arc 从 sync 包中提供的实际方法;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Clone&gt; Clone for Sender&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self {
            // Now Rust knows to use the Clone method of Arc instead of the
            // clone method of inner itself.
            inner: Arc::clone(&amp;self.inner),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="理解何时以及何时不用内部可变性"><a class="header" href="#理解何时以及何时不用内部可变性">理解何时以及何时不用内部可变性</a></h3>
<blockquote>
<p>Understand when and when not to use interior mutability</p>
</blockquote>
<p>有时, 你需要在代码中使用 Rc 或是 Arc 等结构, 
又或者实现包装一些数据结构, 然后, 又想要改变被包装的数据;
很快, 编译器就会告诉你, 内部可变性是不允许的, 乍看起来这很棘手;
然而, 有一些方法允许 Rust 中的内部可变性, 
甚至是由标准库提供的;</p>
<p>最简单的一种是 Cell, 她为你提供数据的内可变性;
也就是说, 嘦数据复制成本低, 
你就可以在 Rc 中改变数据;
你可以通过将数据包装在 <code>Rc&lt;Cell&lt;T&gt;&gt;</code> 中来实现这一点;
她提供了 get 和 set 方法,
甚至不需要被 mut , 因为, 她们是在底层复制数据的:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// impl&lt;T: Copy&gt; Cell&lt;T&gt;
pub fn get(&amp;self) -&gt; T

// impl&lt;T&gt; Cell&lt;T&gt;
pub fn set(&amp;self, val: T)
<span class="boring">}</span></code></pre></pre>
<p>其它类型, 比如 RefCell 有助于将某些借用检查移至运行时, 并跳过一些编译器的严格过滤;
然而, 这是有风险的, 因为, 如果没有完成借用检查, 就可能在运行时触发 panic ;
将编译器当成朋友, 你会获得回报;
通过跳过编译器检查, 或是将她们推迟到运行时, 
等于告诉编译器&quot;相信我 --- 我作的都是正确的&quot;;</p>
<p>而 std::cell 包甚至通过一个很有帮助的消息警告我们:</p>
<pre><code>
更常见的继承可变性, 其中必须具有唯一访问权限才能改变值,
这一语言元素是令 Rust 能强力推理指针别名, 静态防止崩溃错误的关键;
因此, 继续可变性是首选, 内部可变性是最后的手段;
由于 Cell 类型可以在不允许突变的地方启用突变, 
因此, 在某些情况中, 内部可变性也许是合适的, 甚至必须使用, 例如:

- 在不可变事物的&quot;内部&quot;引入可变性
- 逻辑不可变方法的实现细节
- 克隆的变异实现

</code></pre>
<h3 id="get-和-get-mut-方法是一回事儿"><a class="header" href="#get-和-get-mut-方法是一回事儿">get 和 get mut 方法是一回事儿</a></h3>
<blockquote>
<p>Get and get mut methods are a thing</p>
</blockquote>
<p>很多类型, 包含 vec 都实现了 get 与 get_mut 方法,
让你可以借用和改变结构中的元素
(前者只有在你有一个对集会的可变引用时才可能);
我花了一段时间, 才知道这些选项可用于许多数据结构,
她们通过更轻松的编写干净的代码, 帮助我的生活更轻松!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut [0, 1, 2];

if let Some(elem) = x.get_mut(1) {
    *elem = 42;
}
assert_eq!(x, &amp;[0, 42, 2]);
<span class="boring">}</span></code></pre></pre>
<h3 id="拥抱不安全但合理的代码"><a class="header" href="#拥抱不安全但合理的代码">拥抱不安全但合理的代码</a></h3>
<blockquote>
<p>Embrace unsafe but sound code</p>
</blockquote>
<p>作为一名 Go 开发者, &quot;unsafe&quot; 包总是感觉很不靠谱,
而且我很少接触;
然而, Rust 中 “unsafe” 的概念是完全不同的;
事实上, 很多标准库都使用 <code>“unsafe”</code> 来取得巨大成功!</p>
<p>这怎么可能? 尽管 Rust 使未定义的行为成为不可能,
但是, 这不适用于标记为 “unsafe” 的代码块;
相反, 编写 “unsafe” Rust 的开发者嘦保证其使用合理,
即可获得所有好处;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Example taken from the Rustonomicon
fn item_at_index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt; arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>嘦你能证明你的 API 是可靠的,
就接受 unsafe, 但是, 要避免逈你的消费者暴露 unsafe 函数,
除非是真正有保证的;
出于这个原因, 在 Rust 中,对你的包内部进行严格控制,
可以证明 unsafe 代码块是合理的了;</p>
<p>通常在性能绝对重要的情况下, 才使用 unsafe,
或者当你知道使用 unsafe 代码块是解决问题的简单方法,
并且可以证明代码的可靠性时;</p>
<p>(<code>是也乎:</code></p>
<p>安全和可靠分离, 那么, 什么是可靠呢?</p>
<p>)</p>
<h3 id="尽可能用-impl-类型作为参数而不是通用约束"><a class="header" href="#尽可能用-impl-类型作为参数而不是通用约束">尽可能用 impl 类型作为参数而不是通用约束</a></h3>
<p>这点来自 Golang, 我认为特征可以一直简单的作为函数参数来提供;
比如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Meower {
    fn meow(&amp;self);
}

struct Cat {}

impl Meower for Cat {
    fn meow(&amp;self) {
        println!(&quot;meow&quot;);
    }
}

// ERROR: Meower cannot be used as it does not have
// a size at compile time!
fn do_the_meow(meower: Meower) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>...但是,上述代码失败了,
因为, trait 对象在编译时没有 Rust 完成工作需要的内存尺寸;
我们可以通过添加 <code>&amp;dyn Meower</code> 来告诉编译器这是动态调整大小来绕过,
但是, 很快我了解到这不是 <code>rusty</code>/锈范儿 解决方案;
相反,开发者倾向于衖受特征约束的通用参数,
例如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow&lt;M: Meower&gt;(meower: M) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>...现在能通过编译了;
然而,随着函数越来越复杂, 如果我们还包括其它通用参数,
就可能会有一个非常难以阅读的函数声明;
在此示例中,如果我们只想用一次 meow,
那么, 实际上并不需要动用泛型;
我们甚至于并不关心 meow 的结果,
所以, 可以改写为这样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_the_meow(meower: &amp;impl Meower) {
    meower.meow();
}
<span class="boring">}</span></code></pre></pre>
<p>这样告诉编译器:&quot;我只想要实现 Meow 的东西&quot;;
当然,这正是我们需要的,
并且,首先不需要函数的通用返回类型时,
此模式会更加清晰;</p>
<h3 id="用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有"><a class="header" href="#用-iter-过程中想借用时-iter-mut-用以独占-refs而-into-iter-支持拥有">用 iter() 过程中想借用时, iter mut() 用以独占 refs,而 into iter() 支持拥有</a></h3>
<p>很多教程立即跳转到使用下面的 into_iter 方法来迭代 vectors/向量:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let items = vec![1, 2, 3, 4, 5];
for item in items.into_iter() {
    println!(&quot;{}&quot;, item);
}
<span class="boring">}</span></code></pre></pre>
<p>然而,当我们刚刚开始在结构中使用这个迭代器方法时,
很多初学者(包括作者自己)都碰壁了,例如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: Vec&lt;u32&gt;,
}

impl Foo {
    fn all_zeros(&amp;self) -&gt; bool {
        // ERROR: Cannot move out of self.bar!
        self.bar.into_iter().all(|x| x == 0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>并立即提示:</p>
<pre><code>    error[E0507]: cannot move out of `self.bar` which is behind a shared reference
       --&gt; src/main.rs:9:9
        |
    9   |         self.bar.into_iter().all(|x| x == 0)
        |         ^^^^^^^^ ----------- `self.bar` moved due to this method call
        |         |
        |         move occurs because `self.bar` has
        |         type `Vec&lt;u32&gt;`, which does not implement the `Copy` trait

</code></pre>
<p>作为菜鸟尝试了很多办法后, 才意识到 <code>.into_ter()</code> 取得了集合的所有权,
这不是我的目标所需要的;
相反, 在迭代器上还有另外两种有用的方法, 真希望当时能早点知道丫们;</p>
<p>第一个是 <code>.iter()</code> ,借用集合, 让你断言关于其值的东西,但是, 不拥有或是改变她们;
再有就是 <code>iter_mut()</code> 帮助你改变集合内部值,嘦你是唯一的exclusive reference/独占参考;</p>
<p>总之, 当你只需要借用时用 <code>.iter()</code>,
当你想要获得所有权时用 <code>.into_iter()</code>,
当你需要改变迭代对象的元素时用 <code>.iter_mut()</code>;</p>
<h3 id="phantom-数据不仅仅用以处理指向类型的原始指针"><a class="header" href="#phantom-数据不仅仅用以处理指向类型的原始指针">Phantom 数据不仅仅用以处理指向类型的原始指针</a></h3>
<p>当你第一次遇到 Phantom data/幻数据时,
一定感觉很奇怪,但是, 很快就会成为一种告诉编译器&quot;拥有&quot;某个值的好方式,
尽管只有一个指向她的原始指针;
例如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Foo&lt;'a, T: 'a&gt; {
    bar: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这儿告诉编译器 Foo 拥有 T,
尽管只有一个指向她的原始指针;
这对于需要处理原始指针和使用 unsafe Rust 的应用程序很有帮助;</p>
<p>但是, 也可以是一种告诉编译器你的类型还没实现 Send 或是 Sync 特征的方法!
你可以使用 PhantomData 包装以下类型,并在你的结构中使用她们,
来作为一种方式告诉编译器你的结构即不是 Send 也不是 Sync;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type PhantomUnsync = PhantomData&lt;Cell&lt;()&gt;&gt;;
pub type PhantomUnsend = PhantomData&lt;MutexGuard&lt;'static, ()&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="用-rayon-实现并行增量"><a class="header" href="#用-rayon-实现并行增量">用 rayon 实现并行增量</a></h3>
<p>有时, 你希望在遍历集会时并行化工作,
但是, 在处理线程和确保类型可以安全的跨线程发送时却碰壁了;
有时, 如果额外的样板文件令你的代码几乎不可读,那就已经不值得了;</p>
<p>相反, 有一个名为 Rayon 很赞的包, 已经提供了以无缝方式并行化计算的上好工具;
例如,假设我们有一个计算数组平方和的函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>由于乘法和加法的性质, 上述代码绝对可以并行化,
Rayon 通过让我们自动访问数组等集会的&quot;并行迭代器&quot;,
使并行化变得微不足道;
这是几乎零样板的代码;
而且也完全不影响可读性:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Importing rayon prelude is what gives us access to .par_iter on arrays.
use rayon::prelude::*;

fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    // We can use par_iter on our array to let rayon
    // handle the parallelization and reconciliation of
    // results at the end.
    input.par_iter()
            .map(|i| i * i)
            .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>工程中如果自己要构造各种内部库,
也值得给出这种使用界面,
和以往使用内置库的代码完全兼容,
只是在关键节点处替换为自己魔改/加强过的...
)</p>
<h3 id="开发-rust-库时理解-拓展特征-的概念"><a class="header" href="#开发-rust-库时理解-拓展特征-的概念">开发 Rust 库时理解 拓展特征 的概念</a></h3>
<p>那么 Rayon 是如何以如此干净的方式完成上述工作的呢?
答案在于&quot;拓展特征&quot;,
这些特征可以定义为对其它特征的拓展,
例如 Iterator;
也就是说,我们可以逈通常实现 Itertor 特征的项追加其它有用的函数,
但是, 她们只有在特性范畴以内时才可用,
比如通过将其导入文件中;</p>
<p>这种方式非常好,因为,这些特征只有在你在项目中导入拓展特征时才可用,
并提供了一种使用干净的 API 拓展通用集合和类型的好方法,
开发者可以像使用普通 API 一样轻松的使用这些 API;
由于 Rayon 的拓展特征,
使用并行迭代器就像在 Rust 中使用普通迭代器一样简单;</p>
<p>事实上,这有一个信息量很大的演讲,解释了如何使用 拓展特征 来开发一个在迭代器上提供进度条的库;</p>
<p>(<code>是也乎</code>:</p>
<p><a href="https://www.youtube.com/watch?v=bnnacleqg6k">&quot;Type-Driven API Design in Rust&quot; by Will Crichton - YouTube</a></p>
<p>配套看看 Rayon 官方对自己实现原理的嗯哼: <a href="https://github.com/rayon-rs/rayon/tree/master/src/iter/plumbing">rayon/src/iter/plumbing at master · rayon-rs/rayon</a>
以及专门的解析文章: <a href="https://developers.redhat.com/articles/2023/01/30/run-app-under-openshift-service-mesh">How Rust supports Rayon's data parallelism | Red Hat Developer</a></p>
<p>大约可以感受到 Rust 世界的任性了...
)</p>
<h3 id="拥抱-option-和-result-类型的一元性"><a class="header" href="#拥抱-option-和-result-类型的一元性">拥抱 Option 和 Result 类型的一元性</a></h3>
<p>使用 Option 和 Result 之后,
人们会很快看到<code>.unwrap()</code> 将值从她们移出,
如果 Option 和 Result 是共享引用(比如 struct)的一部分,
就将导致失败;
然而,有时我们想要的只是断言 Option 匹配内部的值或获取对其内部的引用;
有很多方法可以作到这点,
但是, 还有一种方式能不用离开 Option 领域:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_five(x: Option&lt;i32&gt;) -&gt; bool {
    // Contains can just check if the Option has what we want.
    x.contains(&amp;5)
}
<span class="boring">}</span></code></pre></pre>
<p>另一个示例是我们想要用 None 值替换 Option 内数据,
也就是和某些结构交互时;
我们可以用指令式编程的方式来编写,
并按照以下方式详细完成:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    data: Option&lt;T&gt;,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    // Takes the value of data and leaves None in its place.
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.data.is_none() {
            return None;
        }
        let value = self.data.unwrap();
        self.data = None;
        value
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然而, Option 有一些非常酷的属性,
因为, 她们的基本性质是定义了有用的方法,
可以让我们的生源更加轻松;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Takes the value of data and leaves None in its place.
fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.data.take()
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 中的 Option 以函数式编程语言中相同的范例为模型,
属于更广泛的数据类型类别, 称为 Monad;
不用深入理解 Monad 是什么, 而嘦将其视为数据的包装器,
我们可以在不需要从中取出东西的情况下对其进行操作;
比如, 想象一个将两个 Option 内部值相加并返回一个 Option 的函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if x.is_none() || y.is_none() {
        return None;
    }
    return Some(x.unwrap() + y.unwrap());
}
<span class="boring">}</span></code></pre></pre>
<p>上述代码看起来有点点笨拙,因为,需要执行 none 检验,
而且我们必须从两个 Option 中提取值并从中构建一个新 Option 就很囧;
然而, 由于 Option 的特殊属性,
我们可以作的更好!
这是我们可以获得的:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: Option&lt;i32&gt;, y: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    x.zip(y).map(|(a, b)| a+b)
}
<span class="boring">}</span></code></pre></pre>
<p>可以对 option 使用 zip 和 map ,
就像我们可以处理数组和向量一样;
此属性也存在于 Result 类型中,
甚至存在于诸如 <code>Future</code> 类型之类事物中;
如果你对为什么这么作感到好奇,
请继续挖掘 Monad 的更多信息 -&gt; <a href="https://stackoverflow.com/questions/2704652/monad-in-plain-english-for-the-oop-programmer-with-no-fp-background">functional programming - Monad in plain English? (For the OOP programmer with no FP background) - Stack Overflow</a></p>
<p>接受 Option 和 Result 类型的一元性质,
不要到处使用 unwrap 和 if x.is_none() {} else ;
本身就包含了很多有用的方法,
你可以在标准库中阅读这些方法;</p>
<p>(<code>是也乎:</code></p>
<p>所以, 标准库的通读是一个基本功了,
不过, 相比 Python 等其它语言的官方文档,
docs.rs 实在太麻了点儿,还要习惯一下;</p>
<p>)</p>
<h3 id="了解-drop-应该如何针对不同数据结构实现"><a class="header" href="#了解-drop-应该如何针对不同数据结构实现">了解 Drop 应该如何针对不同数据结构实现</a></h3>
<p>标准库将 Drop 特性描述为:</p>
<p>当不再需要某个值时, Rust 将对该值运行&quot;析构函数&quot;;
不再需要某个值最常见方式是超出作用域;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>在 Rust 中编写数据结构时, Drop 是至关重要的;
人们必须有一种合理的方法来处理一旦不再需要内存时如何丢弃(安全的);
使用引用计数类型可以报时你克服这些障碍,
但是, 这并不总是足够的;
例如,编写自定义链表或是编写使用通道的结构时,通常要实现自定义版本的 Drop;
当你看到标准库实际如何执行时,
实现 Drop 比并看起来容易的多:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// That's it!
fn drop&lt;T&gt;(t: T) {}
<span class="boring">}</span></code></pre></pre>
<p>巧妙利用失去作用域时销毁的规则,
<code>std::mem::drop</code> 有一个空函数体!</p>
<p>这是一个技巧, 你可以在自己的自定义 Drop 实现中使用,
嘦你涵盖所有基类?即可;</p>
<h3 id="真的对借用检查员很气-那就用不可变数据结构"><a class="header" href="#真的对借用检查员很气-那就用不可变数据结构">真的对借用检查员很气? 那就用不可变数据结构</a></h3>
<p>函数式程序员喜欢说全局的/可变的状态是万恶之源,
如果可以避免,那毛还要使用呢?
多亏了 Rust 的函数式结构,
我们才能构建从一开始就不可能突变的结构结构!
当你需要编写类似在 Haskell/OCaml 或其它语言中看到的纯粹函数式代码时,
这尤其有用;</p>
<p>通过链接列表综合教程中的示例,
我们可以看到如何构建一个不可变列表,其中节点有引用计数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }
    ...
<span class="boring">}</span></code></pre></pre>
<p>这就很赞,因为,其行为类似于函数式数据结构,
在函数式数据结构中,
人们不会通过追加前缀来修改列表,
而是通过以新元素作为其头部和现有列表作为尾部来构建列表完成新构建;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    [head] ++ tail
<span class="boring">}</span></code></pre></pre>
<p>请注意,上述方法都不需要 mut, 因为,我们的数据结构是不可变的!
这在内存上也是非常高效的,因为,该结构是引用计数的,
这意味着如果此数据结构上有多个调用者,
我们不会浪费不必要的资源来复制节点的底层内存;</p>
<p>Rust 中的纯函数代码很简洁,
但是,多数时候,需要尾递归来了把用我快这种方式实现的高性能代码；
而且，要小心，毕竟 Rust 编译器不保证尾调用优化；
值得进一步挖掘更多信息 -&gt; <a href="https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust">When is tail recursion guaranteed in Rust? - Stack Overflow</a></p>
<p>(<code>是也乎:</code></p>
<p>这就尴尬了, 只是个看起来很美的思路,
毕竟 Rust 不是纯函数语言,
递归并不是第一公民;</p>
<p>所以, 这种场景中,还是老实和 借用管理员 好好商量吧...</p>
<p>)</p>
<h3 id="traits-篮有助减少重复"><a class="header" href="#traits-篮有助减少重复">traits 篮有助减少重复</a></h3>
<p>有时,可能希望通过很多不同的特征来约束泛型参数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T: Copy + Clone + Ord + Bar + Baz + Nyan&gt; {
    vals: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>但是,一旦你开始编写 impl 语句,
或是当你有多个通用参数时,
这很快就会失控;
相反你可溶性定义一个整体特征, 使代码更加 DRY;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Fooer: Copy + Clone + Ord + Bar + Baz + Nyan {}

struct Foo&lt;F: Fooer&gt; {
    vals: Vec&lt;F&gt;,
}

impl&lt;F: Fooer&gt; Foo&lt;F&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<p>traits 篮可以帮助减少重复，
但是，不要让其变得过大；
在很多情况中，
让一个类型需要如此多的约束可能会产生坏味道,
因为,你创建的抽象太大了;
相反,如果你发现约束无缘无故的变得太大,
请传入具体类型;
然而,某些应用和远又可能受益于 blanket traits/特征篮,
例如旨在提供尽可能通用的 API 库;</p>
<h3 id="match-语句本质上很灵活和结构化的"><a class="header" href="#match-语句本质上很灵活和结构化的">Match 语句本质上很灵活和结构化的</a></h3>
<p>例如,可以将值作为元组组合在一起并执行以下操作,而不是嵌套匹配语句:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player_outcome(player: &amp;Move, opp: &amp;Move) -&gt; Outcome {
    use Move::*;
    use Outcome::*;
    match (player, opp) {
        // Rock moves.
        (Rock, Rock) =&gt; Draw,
        (Rock, Paper) =&gt; Lose,
        (Rock, Scissors) =&gt; Win,
        // Paper moves.
        (Paper, Rock) =&gt; Win,
        (Paper, Paper) =&gt; Draw,
        (Paper, Scissors) =&gt; Lose,
        // Scissor moves.
        (Scissors, Rock) =&gt; Lose,
        (Scissors, Paper) =&gt; Win,
        (Scissors, Scissors) =&gt; Draw,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个示例足以说明为什么模型匹配比指令式语言中的 switch 语句更强大,
而且, 在劳模内部值方面可以作的更多.</p>
<h3 id="如果匹配对象是有限且已知的嫑使用-_--子句"><a class="header" href="#如果匹配对象是有限且已知的嫑使用-_--子句">如果匹配对象是有限且已知的,嫑使用 _ =&gt; 子句</a></h3>
<p>例如,我们有个枚举:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
    Nyan,
    Zab,
    Azb,
    Bza,
}
<span class="boring">}</span></code></pre></pre>
<p>在编写 match 语句时,如果可能的话, 应该匹配枚举的所有类型,而不是求助于 catch-all 子句:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match f {
    Bar =&gt; { ... },
    Baz =&gt; { ... },
    Nyan =&gt; { ... },
    Zab =&gt; { ... },
    Azb =&gt; { ... },
    Bza =&gt; { ... },
}
<span class="boring">}</span></code></pre></pre>
<p>这对代码维护非常有帮助,因为,如果枚举的原始编写者逈其追加更多变体,
如果我们忘记在匹配语句中处理新变体, 功能将无法编译;</p>
<h3 id="match-保护条款也很强大"><a class="header" href="#match-保护条款也很强大">Match 保护条款也很强大</a></h3>
<p>当你有未知或是可能无限数量的匹配项时(例如数字范围),
匹配守卫就很棒;
然而, 如果你的范围不能被守卫完全包含时,
将迫使你使用一个包罗万象的 <code>_ =&gt;</code>,
这在编写可维护代码时可能就是一个缺点;</p>
<p>Rust 书中典型示例如下:</p>
<pre><pre class="playground"><code class="language-rust">enum Temperature {
    Celsius(i32),
    Fahrenheit(i32),
}

fn main() {
    let temperature = Temperature::Celsius(35);
    match temperature {
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        Temperature::Celsius(t) =&gt; println!(&quot;{}C is below 30 Celsius&quot;, t),
        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
    }
}</code></pre></pre>
<h3 id="需要搞乱原始汇编嘛-有一个宏"><a class="header" href="#需要搞乱原始汇编嘛-有一个宏">需要搞乱原始汇编嘛? 有一个宏!</a></h3>
<p>core asm 提供了一个闳, 可以让你在 Rust 中编写内联汇编语句,
这在折腾一些花哨的事情时很有帮助,
比如直接拦截 CPU 的堆栈,
或是想要实现高级优化;</p>
<p>这是一个示例,我们使用内联汇编通过简单的将堆栈指针移动到用来欺骗处理器的堆栈来执行我们的函数!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::arch::asm;

const MAX_DEPTH: isize = 48;
const STACK_SIZE: usize = 1024 * 1024 * 2;

#[derive(Debug, Default)]
#[repr(C)]
struct StackContext {
    rsp: u64,
}

fn nyan() -&gt; ! {
    println!(&quot;nyan nyan nyan&quot;);
    loop {}
}

pub fn move_to_nyan() {
    let mut ctx = StackContext::default();
    let mut stack = vec![0u8; MAX as usize];
    unsafe {
        let stack_bottom = stack.as_mut_ptr().offset(MAX_DEPTH);
        let aligned = (stack_bottom as usize &amp; !15) as *mut u8;
        std::ptr::write(aligned.offset(-16) as *mut u64, nyan as u64);
        ctx.rsp = aligned.offset(-16) as u64;
        switch_stack_to_fn(&amp;mut ctx);
    }
}

unsafe fn switch_stack_to_fn(new: *const StackContext) {
    asm!(
        &quot;mov rsp, [{0} + 0x00]&quot;,
        &quot;ret&quot;,
        in(reg) new,
    )
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>所以说, 无法嵌入内联 汇编代码 的语言, 都不算系统语言?</p>
<p>等等, Python 好象也可以哪...
)</p>
<h3 id="使用-criterion-对代码及其吞吐量进行基准测试"><a class="header" href="#使用-criterion-对代码及其吞吐量进行基准测试">使用 Criterion 对代码及其吞吐量进行基准测试</a></h3>
<p>用来对 Rust 代码进行基准测试的 Criterion 是一项了不起的工程作品;
能帮助你使用图形/回归分析和其它奇怪的工具来访问令人敬畏的基准测试功能;
甚至可以用来衡量函数的不同维度,例如时间和吞吐量;
又比如, 我们可以看到在不同的直方图中,使用标准库的迭代器方法构造/获取和收集原始字节的速度有多快;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter;

use criterion::BenchmarkId;
use criterion::Criterion;
use criterion::Throughput;
use criterion::{criterion_group, criterion_main};

fn from_elem(c: &amp;mut Criterion) {
    static KB: usize = 1024;

    let mut group = c.benchmark_group(&quot;from_elem&quot;);
    for size in [KB, 2 * KB, 4 * KB, 8 * KB, 16 * KB].iter() {
        group.throughput(Throughput::Bytes(*size as u64));
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &amp;size| {
            b.iter(|| iter::repeat(0u8).take(size).collect::&lt;Vec&lt;_&gt;&gt;());
        });
    }
    group.finish();
}

criterion_group!(benches, from_elem);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<p>将以下条目追加到项目的 Cargo,toml 文件中,
就可以用 cargo bench 运行了:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.3&quot;

[[bench]]
name = &quot;BENCH_NAME&quot;
harness = false
</code></pre>
<p>criterion 不仅可以向你展示非常棒的图表和描述性信息,
而且,还能记住基准测试运行的先前结果,
告诉你性能回归状态;
在这种情况中,我在运行基准测试的同时, 还能用计算机作很多其它事儿,
所以, 也能自然的通报从上次测量后退化了多少;
总之,非常的COOL!</p>
<pre><code>    Found 11 outliers among 100 measurements (11.00%)
      2 (2.00%) low mild
      4 (4.00%) high mild
      5 (5.00%) high severe
    from_elem/8192          time:   [79.816 ns 79.866 ns 79.913 ns]
                            thrpt:  [95.471 GiB/s 95.528 GiB/s 95.587 GiB/s]
                     change:
                            time:   [+7.3168% +7.9223% +8.4362%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-7.7799% -7.3407% -6.8180%]
                            Performance has regressed.
    Found 3 outliers among 100 measurements (3.00%)
      2 (2.00%) high mild
      1 (1.00%) high severe
    from_elem/16384         time:   [107.22 ns 107.28 ns 107.34 ns]
                            thrpt:  [142.15 GiB/s 142.23 GiB/s 142.31 GiB/s]
                     change:
                            time:   [+3.1408% +3.4311% +3.7094%] (p = 0.00 &lt; 0.05)
                            thrpt:  [-3.5767% -3.3173% -3.0451%]
                            Performance has regressed.
</code></pre>
<h3 id="通过阅读标准库来理解关键概念"><a class="header" href="#通过阅读标准库来理解关键概念">通过阅读标准库来理解关键概念!</a></h3>
<p>我喜欢徜徉在标准库中,尤其是 std::rc, std::iter, and std::collections;
以下是我自己从中学习到的一些很赞的技巧:</p>
<ul>
<li>vec 是如何切实实现的</li>
<li>通过 std::cell 和 std::rc 中的不同方法, 实现内部可变性的方式</li>
<li>如何在 std::sync 中实现通道</li>
<li>std::sync::Arc 的魔力</li>
<li>了解 Rust 作者对开发对应库时,如何作出设计决策的详尽解释</li>
</ul>
<p>有希望这篇文章能为进入 Rust 并遇到一些障碍的人们提供可用信息;
期待更多 Rust 内容能推出,
尤其是关键更高级主题的...</p>
<h3 id="shoutout"><a class="header" href="#shoutout">Shoutout</a></h3>
<p>感谢 Offchain Labs 同事 Rachel 和 Lee Bousfield 对这门语言的广泛了解;
他们的一些技巧启发了这篇文章;</p>
<h2 id="refer-8"><a class="header" href="#refer-8">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<ul>
<li><a href="http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/">Rust Bug Minimization Patterns - The {pnk}f(eli)x Blog</a></li>
<li><a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></li>
<li><a href="https://github.com/sger/RustBooks#advanced-books">sger/RustBooks: List of Rust books</a>
<ul>
<li><a href="https://veykril.github.io/tlborm/decl-macros/macros2.html">Macros 2.0 - The Little Book of Rust Macros</a></li>
<li>...</li>
</ul>
</li>
</ul>
<h2 id="logging-9"><a class="header" href="#logging-9">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230120 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧"><a class="header" href="#技巧">技巧</a></h1>
<blockquote>
<p>tips...重要也不重要</p>
</blockquote>
<h2 id="background-7"><a class="header" href="#background-7">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>刚刚开始感觉哪儿哪儿都要有技巧, 其实不一定...</p>
<h2 id="goal-5"><a class="header" href="#goal-5">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<p>将一头合格 Rustaceans 值得记忆的基本技巧,
收集到 42% 左右...</p>
<h2 id="trace-5"><a class="header" href="#trace-5">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<p>???</p>
<h2 id="refer-9"><a class="header" href="#refer-9">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-10"><a class="header" href="#logging-10">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-运算符重载六件趣事"><a class="header" href="#rust-运算符重载六件趣事">Rust 运算符重载六件趣事</a></h1>
<p>原文: <a href="https://wishawa.github.io/posts/fun-rust-operators/">Six fun things to do with Rust operator overloading | Wisha Wanichwecharungruang</a></p>
<p><img src="https://wishawa.github.io/posts/fun-rust-operators/dot-product-pooh.jpg" alt="dot-product-pooh" /></p>
<h2 id="快译-2"><a class="header" href="#快译-2">快译</a></h2>
<h3 id="c-输入出"><a class="header" href="#c-输入出">C++ 输入/出</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stdin().read_line(&amp;mut buffer).unwrap();
println!(&quot;Hello I am {name}!!!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>可以重载 cin 和 count 上的移位运算符来达成:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cin &gt;&gt; &amp;mut buffer;
cout &lt;&lt; &quot;Hello I am &quot; &lt;&lt; name &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>看起来意义更加不明了了?
)</p>
<h3 id="可变函数"><a class="header" href="#可变函数">可变函数</a></h3>
<p>想替代</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::cmp::max(x, y);
[w, x, y, z].into_iter().max();
<span class="boring">}</span></code></pre></pre>
<p>可以搞成:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// max+ is like std::cmp::max but better
// it supports &gt;2 arguments
max+(x, y);
max+(w, x, y, z);
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>内置标准库太丰富了...简直必须要有一个信仰过程</p>
<p>)</p>
<h3 id="更简洁的构建器"><a class="header" href="#更简洁的构建器">更简洁的构建器</a></h3>
<p>这是一个更严重的问题;
构建器模式有时涉及大量重复的方法调用;
以 warp web 框架的这种用法为例:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
    .and(warp::path::param())
    .and(warp::header(&quot;user-agent&quot;))
    .map(|param: String, agent: String| {
        format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
    });
<span class="boring">}</span></code></pre></pre>
<p>如果 API 看起来像这样呢?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hi = warp::path(&quot;hello&quot;)
	+	warp::path::param()
	+	warp::header(&quot;user-agent&quot;)
	&gt;&gt;	|param: String, agent: String| {
			format!(&quot;Hello {}, whose agent is {}&quot;, param, agent)
		};
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎:</code></p>
<p>等等, 这就是语法糖了吧?
)</p>
<h3 id="中缀函数"><a class="header" href="#中缀函数">中缀函数</a></h3>
<p>想替代:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.pow(y);
dot_product(a, b);
a.cross(b.cross(c).cross(d))
<span class="boring">}</span></code></pre></pre>
<p>我们可以这么来:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x ^pow^ y;
a *dot* b;
a *cross* (b *cross* c *cross* d);
<span class="boring">}</span></code></pre></pre>
<p>很多人就想要这个!</p>
<p>(<code>是也乎:</code></p>
<p>嗯哼? 的确流畅很多哪...
)</p>
<h3 id="doublefish"><a class="header" href="#doublefish">Doublefish</a></h3>
<p>std::mem 提供有这些功能:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val(&amp;value);
<span class="boring">}</span></code></pre></pre>
<p>Turbofish 爱好者会喜欢 size_of,
但是对 size_of_val 没什么感觉;
所以, 我们可以自行改造出新版本的 size_of_val ,
看起来更象 turbofishy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>size_of::&lt;T&gt;();
size_of_val&lt;&lt;&amp;value&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h3 id="join-和-race"><a class="header" href="#join-和-race">Join 和 Race</a></h3>
<p>特性组合器可能具有短路行为能力;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// quit if any of the 3 errors
(fut1, fut2, fut3).try_join().await;

// quit if any of the 3 succeeds
(fut4, fut5, fut6).race_ok().await;
<span class="boring">}</span></code></pre></pre>
<p>可以通过 &amp; 和 | 在形式上表达出这点:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(TryJoin &gt;&gt; fut1 &amp; fut2 &amp; fut3).await;
(RaceOk &gt;&gt; fut4 | fut5 | fut6).await;
<span class="boring">}</span></code></pre></pre>
<p>(<code>是也乎</code>:</p>
<p>这是从形式上和语义同步了.
)</p>
<h2 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h2>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/10golkq">Discuss this on Reddit</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=71da59351b0988249a69014e6b191353">Playground</a> containing the implementations behind some of the code shown here</li>
<li><a href="https://doc.rust-lang.org/std/ops/index.html">std::ops docs</a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">Rust operators precedence table</a></li>
</ul>
<h2 id="refer-10"><a class="header" href="#refer-10">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-11"><a class="header" href="#logging-11">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>230212 ZQ v1 done</li>
<li>230125 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-超越面向对象第1部分"><a class="header" href="#rust-超越面向对象第1部分">Rust 超越面向对象,第1部分</a></h1>
<p>原文: <a href="https://www.thecodedmessage.com/posts/oop-1-encapsulation/">Rust Is Beyond Object-Oriented, Part 1: Intro and Encapsulation :: The Coded Message</a></p>
<h2 id="快译-3"><a class="header" href="#快译-3">快译</a></h2>
<p>是的, Rust 不是一种 OOP 编程语言;</p>
<p>Rust 可能看起来像一种 OOP 编程语言:
类型可以和 &quot;“methods&quot; 关联,
可以是 &quot;intrinsic&quot; 的或是通过 &quot;traits&quot;;
通常可以使用 C++ 或是 Java 风格的 OOP 语法调用方式:
map.insert(key, value) 或 foo.clone();
就像在 OOP 语言中一样,
此语法涉及放置在调用者的 <code>.</code> 中, 而在被调用者中称为 self;</p>
<p>但请不要误会: 尽管 Rust 可能借用了一些技巧/术语和语法,
但是, Rust 并不是一种面向对象的编程语言;
面向对象编程的三大支柱理念: 封装/多态/继承;
其中, Rust 完全否决了 继承,
因此, 永远不可能成为&quot;真正的&quot; OOP 语言;
不过, 即便对于封装和多态, Rust 实现的方式也和 OOP 语言不同 --- 稍后将对此进行更加详细的介绍;</p>
<p>这一切都让很多程序员感到惊讶以及无措;
我在 Reddit 上看到 Rust 新手询问如何按字面意思实现 OOP 设计模式,
试图获得像“shapes” 或是 “vehicles”这种&quot;类层次结构&quot;,
使用作为&quot;Rust 版本继承&quot;的 traits --- 换句话说, 
试图解决他们想象中的问题, 
因为, 他们致力于 OOP 方法, 并通过构建人为的 OOP 示例来尝试了解他们期待的应该存在的另外一个版本 Rust;</p>
<p>这对很多人来说是一个绊脚石;
我经常看到 Rust 新手和怀疑论者在互联网上提到&quot;缺乏OOP&quot;,
这是 Rust 难以适应/不合适他们的关键原因,
甚至是 Rust 永远不会流行的原因;
对于那些在 OOP 的高度来学习编程的人来说 --- 当像 C 和 ML 那样完美的语言都必须变成 Object-C 和 OCaML 这种面向对象的语言 --- 
对非 OOP 语言的大量炒作感觉就不太香了;</p>
<p>这也不是一个容易的调整;
如此多的程序猿以明确的面向对象的方式学习软件设计和体系结构;
我看到一个又一个问题,
一个初级或中级 Rust 程序员想要作一个面向对象的事儿,
并想要一个字面上的 Rust 等价物;
通常, 这些都是经典的 &quot;XY 问题&quot; (原文:<a href="https://xyproblem.info/">XY problem</a>, 酷壳有精采的翻译:<a href="https://coolshell.cn/articles/10804.html">X-Y Problem | 酷 壳 - CoolShell</a>)案例, 他们很难调头用更 Rusty 的方式解决问题;</p>
<p>这其实都不是 Rust 的错;
答案还是要我们去调整,
虽然不容易;
我们要成为更好的程序员, 不仅精通多种语言,
而且要精通不同的编程范式;</p>
<p>而且, 作为一种范式, OOP 实际上非常平庸 --- 以至于我写了一整篇文章来解释为什么,
以及为什么 Rust 的方法更好;</p>
<h3 id="oop-ideology"><a class="header" href="#oop-ideology">OOP Ideology</a></h3>
<p>Look, I get it. I used to drink the OOP Kool-Aid myself. I remember how it was billed to us: not as just a set of code organization practices, but a revolution in programming. The OOP way was held up as more intuitive, especially to non-programmers, because it would align better with how we think of the natural world.</p>
<p>For an archetypical example of this marketing, here is an excerpt from the first public article about OOP in a popular magazine (Byte Magazine, in 1981):</p>
<hr />
<blockquote>
<p>Many people who have no idea how a computer works find the idea of object-oriented programming quite natural. In contrast, many people who have experience with computers initially think there is something strange about object oriented systems.</p>
</blockquote>
<hr />
<p>It was pretty easy to buy into, as well. Of course, our everyday life doesn’t have anything like subroutines or variables – or, to the extent that it does, we don’t think about them explicitly! But it does have objects that we can interact with, each with its own capabilities. How could it not be more intuitive?</p>
<p>It’s very compelling pseudo-cognitive science, light on research, heavy on really persuasive rationales. The objects can be thought of as “agents,” almost as people, and so you could leverage your social skills towards it instead of just analytical thinking (never mind that objects act nothing like people, and actually substantially dumber in a way that still requires analytical thinking). Or, you can think of objects and classes as an almost-platonic representation of the world of forms itself, making it philosophically compelling.</p>
<p>And oh, how I bought in, especially in my wanton and reckless youth. I personally soaked up the connection between OOP and Platonic philosophy. I delved deep into meta-object protocols, and the fact that in Smalltalk every class had to have a metaclass. The concept of the Smalltalk code Metaclass class felt almost mystical to me, as the notion that any value could be organized in the same hierarchy, with Object at its root.</p>
<p>I remember reading in a book that OOP-style polymorphism made if-else statements redundant, and therefore we should strive to ultimately only use OOP-style polymorphism. Somehow, instead of putting me off, this excited me at the time. I was even more excited when I learned that Smalltalk in fact does this (if you ignored implementation details that optimize away some of this abstraction): In Smalltalk, the concept of if-then-else is implemented via methods like ifTrue: and ifFalse: and ifTrue:ifFalse: on the single-instance True and False classes, with their global objects, true and false.</p>
<p>As a more mature programmer, exposed to the less ideological OOP of C++ and the alternative of functional programming in Haskell, my positions softened, and then shifted dramatically, and now I am barely a fan of OOP at all, especially as its best ideas have been carried on to a newer synthesis in Haskell and Rust. I’ve realized that this hype about new programmers is typical for any paradigm; any new programming paradigm is more intuitive for a newbie than it is for someone who’s a veteran programmer in a different paradigm. The same thing is said for functional programming. The same thing is even said for Rust. It really doesn’t have that much to do with whether a paradigm is better.</p>
<p>As for if statements being fully replaceable by polymorphism, well, it’s easy to come up with a set of primitives that are Turing-complete. You can simulate if statements with polymorphism, true. You can also simulate while loops with recursion, or recursion with while loops and an explicit stack. You can simulate if statements with while loops.</p>
<p>None of these facts make such substitutions a good idea. Different features exist in a programming language for different situations, and making them distinct is actually a good thing, in moderation.</p>
<p>After all, the point of programming is to write programs, not to make proofs about Turing-completeness, do philosophy, or write conceptual poetry.</p>
<h3 id="practicality"><a class="header" href="#practicality">Practicality</a></h3>
<p>So, in this blog series, I intend to evaluate OOP in practical terms, as a programmer with experience in what makes programming languages cognitively more manageable or easy to do abstraction in. I will do it in terms of my experience solving actual programming problems – I see it as a bad sign that many examples of how OOP abstractions work only make sense in really advanced programs or with contrived examples about different types of shapes or animals in a zoo.</p>
<p>And unlike most introductions to OOP, I will not primarily be focusing on how OOP compares to pre-OOP programming languages. I will instead be comparing to Rust, which takes many of the good ideas from OOP, and perhaps also to functional programming languages like Haskell. These programming languages have taken some of OOP’s good ideas, but transformed them in a way that fixes some of their flaws and moves them beyond what can reasonably be called OOP.</p>
<p>I will organize this comparison according to the three traditional pillars of object-oriented programming: encapsulation, polymorphism, and inheritance, with this first article focusing on encapsulation. For each pillar, I will discuss how OOP defines it, what equivalents or substitutes exist outside of the OOP world, and how these compare for practical ease and power of programming.</p>
<p>But before I jump in, I want to talk a second about a use case that turns much of this on its head: graphical user interfaces or GUIs. Especially before the era of the browser, writing GUI programs to run directly on desktop (or laptop) computers was a huge part of what programmers did. A lot of early development of OOP was done in tandem with research into graphical user interfaces at Xerox PARC, and OOP is uniquely well-suited for that use case. For this reason, the GUI deserves special consideration.</p>
<p>For example, it is common for people to emulate OOP in other programming languages. Gtk+ is a huge example of this, implementing OOP as a series of macros and conventions in C. This is done for many reasons, including familiarity with OOP designs and a desire to create some kind of run-time polymorphism. But in my experience, this is most common when implementing a GUI framework.</p>
<p>In this series of articles, we will primarily focus on applying OOP to other use cases, but we will also discuss GUIs as appropriate. In this introductory section, I will just point out that GUI frameworks are clearly possible outside traditional OOP designs and programming languages, and even in Rust. Sometimes, they work by completely different mechanisms, like the functional-reactive programming mostly pioneered in Haskell, which I personally prefer to traditional OOP-based programming and for which traditional OOP features would not be helpful.</p>
<p>Now, without further ado, let us compare OOP to Rust and other post-OOP programming languages, pillar by pillar, from a pragmatic perspective. For the rest of this first post, we will focus on encapsulation.</p>
<h3 id="first-pillar-encapsulation"><a class="header" href="#first-pillar-encapsulation">First Pillar: Encapsulation</a></h3>
<p>In object-oriented programming, encapsulation is bound up with the idea of a class, the fundamental layer of abstraction in object-oriented programming. Each class contains a layout for some data in a record format, that is, a data structure where each instance contains a set number of fields. Individual instances of the record type are known as “objects.” Each class also contains code that is tightly paired to that record type, organized into procedures called methods. The idea is then that all of the fields will only be accessible from inside the methods, either by the conventions of OOP ideology or by the enforced rules of the programming language.</p>
<p>The fundamental benefit here is that the interface, which is how the code interacts with other code, or what you have to understand to use the code, is much simpler than the implementation, which are the more fluidly changing details of how the code actually accomplishes its job.</p>
<p>But of course, lots of programming languages have abstractions like this. Any program longer than a dozen lines has too many parts to keep in your brain all at once, and so all remotely modern programming languages have ways of dividing a program into smaller components, as a way to manage the complexity, so that the interface is simpler than the implementation, whether enforced by the programming language or a matter of the “honor system.” So in a broader sense of the word, all modern programming languages have some version of encapsulation.</p>
<p>One simple form of encapsulation – one that most object-oriented programming languages maintain as a layer within the class – is procedures, also known as functions, subroutines, or (as OOP calls them) methods. Rather than allow any line of code to jump to any other line of code, modern programming languages tend to group blocks of code together into procedures, and you can then change the contents of the procedure without affecting the outside code, and change the outside code without affecting the procedure, as long as they follow the same interface and contract.</p>
<p>The contract is usually at least partially a human-level convention. There’s not usually much stopping you from taking a procedure that is supposed to process some data and instead making it instead loop indefinitely or crash the program. But some of it, like the separation of the procedure from the rest of the program, and in many cases the number and types of values it is allowed to accept and return in an invocation, will be enforced by the programming language.</p>
<p>For example, variables declared inside the procedure are usually local, and there’s generally no way to reference them outside the procedure. The inputs and outputs are usually listed in a signature at the top of the procedure. Normally, outside code can only enter the procedure on its first line, rather than on an arbitrary line half-way through. In some programming languages – including Rust – procedures can even contain other procedures, which can only be called within the outer procedure.</p>
<p>But of course, modern programs are often more complicated than a mere handful of procedures. And so, modern programming languages (and again, the word “modern” here is being used in a very loose way) have another layer of encapsulated abstraction: modules.</p>
<p>Modules will generally contain a group of procedures, some externally accessible, and some not. And in non-duck typed languages, they will generally define a number of aggregate types, again some externally accessible, and some not. It is generally even possible to expose these types abstractly, so the existence of a type is accessible to the rest of the program, but not the record fields, or even the fact that it is a record type. Even C has this ability in its module system – C++ did not introduce it, just added an additional, orthogonal level of field-by-field access controls.</p>
<p>Seen from my pragmatic point of view, class-based encapsulation is not some special insight of OOP, but a specialized – or rather, tightly restricted – form of module. In an OOP programming language, we have this notion of a class, which is a special form of module (sometimes the only supported form, or sometimes even layered underneath a completely different, more traditional notion of module, for extra confusion). It’s just that, for a “class,” there can only generally be one primary type defined, which shares a name with the module itself, and where the fields of that type are given special protection against access by code outside the class.</p>
<p>Of course, there are other differences between a class and a module, but these have to do with the other pillars, and we will get to them later. For right now, we will just discuss the idea of a “class” as it relates to encapsulation – where a class is just a special module with one privileged, abstracted type.</p>
<p>And this is a reasonable way to write a module, but it’s not as special as object-oriented programming makes it out to be (especially once we discuss alternative approaches to the other pillars, but again, more later). There are some situations where a module doesn’t have any record type that it defines, which is awkward in programming languages like Java, where you have to define an empty record type anyway and still make a “class.” There are also situations in which a module defines multiple publically accessible types that are tightly entangled – and where the encapsulation between those types that OOP style would encourage you to do is more of a hinderance than a help.</p>
<p>Fundamentally, being able to hide the fields of a record from other modules is important, which is why even C supports it. It is even essential for implementing safe abstractions over unsafe features in Rust, such as for collections, where raw pointers have invariants in combination with other fields in the same record. But it is not new to OOP, and it is simply not the best choice for every possible type.</p>
<p>As evidence of this, in Java and Smalltalk, and to a lesser extent even in C++ or Python, the insistence on a one-type-per-class style of encapsulation means that you get these boilerplate methods like setFoo and getFoo. These methods do nothing but serve as field accessors for something that is fundamentally a dumb record type. In theory, this helps you if you want to change what happens when these fields are set or read, but in practice, the fact that they are raw field accessors is part of the contract. If they, for example, instead made a network call rather than just returning a value, that would strongly value the principle of surprise for such simply named methods.</p>
<p>It is far simpler to say:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Point {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
<span class="boring">}</span></code></pre></pre>
<p>… than the Java idiomatic “JavaBean” equivalent from when I was a Java programmer (Java has apparently changed since then, but this is representative of many OOP programming languages including Smalltalk and many books on how to program):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>class Point {
    private double x;
    private double y;
    private double z;

    double getX() {
        return x;
    }

    double setX(double x) {
        this.x = x;
    }

    double getY() {
        return y;
    }

    double setY(double y) {
        this.y = y;
    }

    double getZ() {
        return z;
    }

    double setZ(double z) {
        this.z = z;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Such data types generally don’t use any of the other features that OOP classes get, such as polymorphism or inheritance. To use such features in such “JavaBean” classes would also violate the principle of least surprise. The “class” concept is overkill for these record types.</p>
<p>And of course, a Java developer (or Smalltalk, or C#) will say that by accessing the fields indirectly through these getter and setter methods, that they are future-proofing the class, in case the design changes (and in fact I was reminded to add this paragraph when someone on Reddit made exactly this point). But I find this disingenuous, or at least misguided – it is often used for structures internal to a portion of the program, where the far more reasonable thing to do would be to change the fields openly to all users of the structure. It is also extremely difficult to think of an unsurprising thing for these methods to do besides literally set or get a field, as the method name implies – making a network call, for example, would be a shocking surprise for a get or set method and therefore a violation of at least the implicit contract. In my time programming object-oriented programming languages, I never once saw a situation where it was appropriate for a getter or setter to do anything but literally get or set the field.</p>
<p>If code does change to require the getter or setter to do something else, I would rather change the name of the method to reflect what else it does, rather than pretend that’s somehow not a breaking change. fetchZFromNetwork or setAndValidateZ seem more appropriate than a getZ or setZ that does something more than the simple field access that we assume a setter or getter does. OOP’s insistence that every type should be its own code abstraction boundary is often absurd when applied to these lightweight aggregate types. These sorts of getters and setters are used to protect an abstraction boundary that shouldn’t exist and just gets in the way, and future-proof against implementation changes that shouldn’t be made without also changing the interface.</p>
<p>Setters and getters, in short, are an anti-pattern. If you intend to create an abstraction besides “data structure,” where validation or network calls or anything else beyond raw field accesses would be appropriate, then these get and set names are the wrong names for that abstraction.</p>
<p>Edit 2023-02-13 to add this paragraph: To be clear, these objections apply to properties as well. It’s not the syntactic inconvenience that I object to, but the entire notion that replacing field accesses with code transparently is a good thing to strive for, or an important possibility to leave open. I should hope that foo.bar = 3 would never make a network call in Rust! And what if it had to be async? It should be clear if I’m calling a function. Rust is about explicitness.</p>
<p>The get and set functions, in reality, are only used as wrappers to satisfy the constraints of object-oriented ideology. The future-proofing they purportedly provide is an illusion. If you provide “JavaBean” style types, or types with properties, over an abstraction boundary, you are in practice just as locked in as if you’d provided raw field access – the changes you are most likely to want to make to those structures would not allow shifting the getters and setters to maintain compatibility. Leveraging this future-proofing is likely to be completely impossible for the changes you’d want to make, and at best it would involve a horrendous hack.</p>
<p>Rust might seem to be the same as OOP languages in all of this; it superficially looks like it has something very similar to classes. You can define functions associated with a given type – and they are even called methods! Like OOP methods, they syntactically privilege taking values of that type (or references to those values) as the first argument, called the special name self. You even mark fields of a record type (called struct in Rust) as public or (by default) private, encouraging private fields just like in an object-oriented programming language.</p>
<p>According to this pillar, Rust seems pretty close to being OOP. And that’s a fair assessment, for this pillar, and an intentional choice to make Rust programming more comfortable to people used to the everyday syntax of OOP programming in C++ (or Java, or JavaScript).</p>
<p>But the similarity is only skin-deep. Encapsulation is the least distinct pillar of OOP (after all, all modern programming languages have some form of it), and the implementation in Rust is not bound with the type. When you declare a field private in Rust (by not specifying pub), that doesn’t mean private to its methods, that means private to the module. A module can provide multiple types, and any function in that module, whether a “method” of that type or not, can access all of the fields defined in that type. Passing around records is encouraged when appropriate, rather than discouraged to the point that accessors are forced instead, even in tightly-bound related code.</p>
<p>This is the first sign we see that Rust, in spite of its superficial syntax, is not an OOP programming language.</p>
<h3 id="future-posts"><a class="header" href="#future-posts">Future Posts</a></h3>
<p>And at this point I’m going to have to pause for today.</p>
<p>Of course, encapsulation isn’t the only fancy thing OOP-style classes can do. If it were, classes wouldn’t have enamored so many people: it would simply be obvious to everyone that classes were nothing more than glorified modules, and methods nothing more than glorified procedures.</p>
<p>In the next posts of this series, we will discuss the other features associated with OOP, the two remaining traditional pillars of OOP, polymorphism and inheritance, analyze them from a practical point of view, and see how Rust compares with OOP as it comes to those pillars.</p>
<p>Next up will be polymorphism!</p>
<h2 id="logging-12"><a class="header" href="#logging-12">logging</a></h2>
<ul>
<li>230220 ZQ re-start</li>
<li>230215 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-超越面向对象第2部分"><a class="header" href="#rust-超越面向对象第2部分">Rust 超越面向对象,第2部分</a></h1>
<p>原文:<a href="https://www.thecodedmessage.com/posts/oop-2-polymorphism/">Rust Is Beyond Object-Oriented, Part 2: Polymorphism :: The Coded Message</a></p>
<h2 id="快译-4"><a class="header" href="#快译-4">快译</a></h2>
<p>在这篇文章中, 通过讨论 OOP 三大传统支柱中的第二个: 多态,
继续系列文章:关于 Rust 和传统 OOP 范式的不同;</p>
<p>In this post, I continue my series on how Rust differs from the traditional object-oriented programming paradigm by discussing the second of the three traditional pillars of OOP: polymorphism.</p>
<p>Polymorphism is an especially big topic in object-oriented programming, perhaps the most important of its three pillars. Several books could be (and have been) written on what polymorphism is, how various programming languages have implemented it (both within the OOP world and outside of it – yes, polymorphism exists outside of OOP), how to use it effectively, and when not to use it. Books could be written on how to use the Rust version of it alone.</p>
<p>Unfortunately this is just a blog post, so I cannot cover polymorphism in as much detail or variety as I want to. I shall instead focus specifically on how Rust differs from the OOP conceptualization. I will start by describing how it works in OOP, and then discuss how to accomplish the same goals in Rust.</p>
<p>In OOP, polymorphism is everything. It tries to take all decision-making (or as much decision-making as possible) and unite it in a common narrow mechanism: run-time polymorphism. But unfortunately, it’s not just any run-time polymorphism, but a specific, narrow form of run-time polymorphism, constrained by OOP philosophy and by details of how the implementations typically work:</p>
<ul>
<li>It requires indirection: Every object must typically be stored on the heap for run-time polymorphism to work, as the different “run-time types” have different sizes. This encourages the aliasing of mutable objects. Not only that, but to actually call a method, it must go through three layers of indirection: dereferencing the object reference, then dereferencing the class pointer or “vtable” pointer, and then doing an indirect function call.</li>
<li>It precludes optimization: Beyond the intrinsic cost of an indirect function call, the fact that the call is indirect means that inlining is impossible. Often, the polymorphic methods are small or even trivial, such as returning a constant, setting a field, or re-arranging the parameters and calling another method, so inlining would be useful. Inlining is also important to allow optimizations to cross the inlining boundary.</li>
<li>It is polymorphic in one parameter only: The special receiver parameter, called self or this, is the only parameter through which run-time polymorphism is typically possible. Polymorphism on other parameters can be simulated with helper methods in those types, which is awkward, and return-type polymorphism is impossible.</li>
<li>Each value is independently polymorphic: In run-time polymorphism, there is often no way to say that all the elements of a collection are of some type T that all implement the same interface, or to say that two parameters to a function are the same type but what that type is should be determined at run-time.</li>
<li>It is entangled with other OOP features: In C++, runtime polymorphism is tightly coupled with inheritance. In many OOP programming languages, it is only available for class types, which as I discussed in my previous post are a constrained form of modules.</li>
</ul>
<p>I could write an entire blog post about each of these constraints – perhaps I will someday.</p>
<p>But in spite of all these constraints, it is seen as the preferred way of doing decision-making in OOP languages, and as especially intuitive and accesible. Programmers are trained to reach for this tool whenever feasible, whether or not it is the best tool for the decision at hand, even if there is no current need for it to be a run-time decision. Some programming languages, such as Smalltalk, even collapsed “if-then” logic and loops into this one oddly specific decision-making structure, implementing them via polymorphic methods like ifTrue:ifFalse that would be implemented differently in the True and False classes (and therefore on the true and false objects).</p>
<p>To be clear, having a mechanism of vtable-based runtime polymorphism isn’t a bad thing per se – Rust even has one (similar, but not quite identical, to the OOP version described above). But the Rust version is used in the relatively rare situations where that mechanism is the best fit, among a whole palette of mechanisms. In OOP, the elevation of this tightly constrained and unperformant form of decision making above all others, and the philosophical assertion that using it is the best way and most intuitive way to express program flow and business logic, is a problem.</p>
<p>It turns out that programming is much more ergonomic when you choose the tool most appropriate for the situation at hand – and OOP run-time polymorphism is only occasionally the actual tool for the jobs it is often asked to do.</p>
<p>So let’s look at 4 alternatives in Rust that can be used when OOP uses run-time polymorphism.</p>
<h3 id="alternative-0-enum"><a class="header" href="#alternative-0-enum">Alternative #0: enum</a></h3>
<p>Not only are there other forms of polymorphism that have strictly fewer constraints (such as Haskell’s typeclasses) or a different set of trade-offs (such as Rust’s traits, heavily based on Haskell typeclasses), there is another decision-making systems in Rust and Haskell, namely algebraic data types (ADTs), or sum types, that also take over many of the applications of OOP-style polymorphism.</p>
<p>In Rust, these are known as enums. enums in many programming language are lists of constants to be stored in integer-sized types, sometimes implemented in a typesafe fashion (like in Java), sometimes not (like in C), sometimes with either option available (like in C++ with the distinction between enum and enum class).</p>
<p>Rust enums support this familiar use case, with type-safety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Visibility {
    Visible,
    Invisible,
}
<span class="boring">}</span></code></pre></pre>
<p>But they also support additional fields associated with each option, creating what in type theory is known as a “sum type,” but it is better known among C or C++ programmers as a “tagged union” – the difference being that in Rust, the compiler is aware of and enforces the tag. Here’s some examples of some enum declarations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum UserId {
    Username(String),
    Anonymous(IpAddress),
    // ^^ This isn't supposed to be a real network type,
    // just an example.
}

let user1 = User::Username(&quot;foo&quot;.to_string());
let user2 = User::Anonymous(parse_ip(&quot;127.0.0.1&quot;)?);

pub enum HostIdentifier {
    Dns(DomainName),
    Ipv4Addr(Ipv4Addr),
    Ipv6Addr(Ipv6Addr),
}

pub enum Location {
    Nowhere,
    Address(Address),
    Coordinates {
        lat: f64,
        long: f64,
    }
}

let loc1 = Location::Nowhere;
let loc2 = Location::Coordinates {
    lat: 80.0,
    long: 40.0,
};
<span class="boring">}</span></code></pre></pre>
<p>What do these tagged unions have to do with polymorphism, you may ask? Well, most OOP languages don’t have good syntax for these sum types, but they do have powerful mechanisms for run-time polymorphism, and so you’ll see run-time polymorphism used for situations where Rust enums would actually be just as well-suited (and I will argue, better suited): when there’s a few options for how to store a value, but those options contain different details.</p>
<p>For example, here’s one way to represent the UserId type in Java using inheritance and run-time polymorphism – how I would’ve done it when I was a student (putting each class in a different file):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>class UserId {
}

class Username extends UserId {
    private String username;
    public Username(String username) {
        this.username = username;
    }

    // ... getters, setters, etc.
}

class AnonymousUser extends UserId {
    private Ipv4Address ipAddress;
    
    // ... constructor, getters, setters, etc.
}

UserId user1 = new Username(&quot;foo&quot;);
UserId user2 = new AnonymousUser(new Ipv4Address(&quot;127.0.0.1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Importantly, just as in the enum example, we can put user1 and user2 in variables of the same type, and can pass them to the same kinds of functions, and in general do the same operations on them.</p>
<p>Now, these OOP-style classes look super-light to the point of being silly, but that’s mostly because we haven’t added any real operational code to this situation – just data and structure and a bit of variable definitions and boilerplate. Let’s consider what happens if we actually do anything with user IDs.</p>
<p>For example, we might want to determine whether they’re an administrator. In our hypothetical, let’s say anonymous users are never administrators, and users with usernames are only administrators if the username begins with the string admin_.</p>
<p>The doctrinally approved object-oriented way of doing that is to add a method, e.g. isAdministrator. In order for this method to work, we have to add it to all three classes, the base class and the two child classes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>class UserId {
    // ...
    public abstract bool isAdministrator();
}

class Username extends UserId {
    // ...
    public bool isAdministrator() {
        return username.startsWith(&quot;admin_&quot;);
    }
}

class AnonymousUser extends UserId {
    // ...
    public bool isAdminstrator() {
        return false;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>So, in order to add this simple operation, this simple capability to this type in Java, we have to go to three classes, which will be stored in three files. Each of them contains a method that does something simple, but nowhere can the entire logic be seen of who is and isn’t an administrator – something that someone might naturally ask.</p>
<p>Rust would use match for such an operation, putting all the information about it in one place:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_administrator(user: &amp;UserId) -&gt; bool {
    match user {
        UserId::Username(name) =&gt; name.starts_with(&quot;admin_&quot;),
        UserId::AnonymousUser(_) =&gt; false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This yields a more complicated individual function, but it has all the logic explicitly right there. Having the logic be explicit, instead of implicit in an inheritance hierarchy, cuts against an OOP precept where methods should be simple and polymorphism used to express the logic implicitly. But that doesn’t help guarantee anything, just sweeps it under the rug: It turns out that hiding the complexity makes it harder to grapple with, not easier.</p>
<p>Let’s go through another example. We’ve had this UserId code for a while, and you’re tasked with writing a new web front-end for this system. You need some way of displaying the user information in HTML, either a link to a user profile (in the case of a named user) or a stringification of the IP address in red (in the case of an anonymous user). So you decide to add a new operation for this small family of types, toHTML, which outputs your new front-end’s specialized DOM type. (Maybe the Java’s compiled to WebAssembly, I’m not sure. The details don’t matter.)</p>
<p>You submit a pull request to the maintainer of the UserId class hierarchy, deep in a core library of the backend. And then they reject it.</p>
<p>They have pretty good reasons, actually, you grudgingly admit. They’re saying it’s an absurd separation of concerns. Besides, the company can’t have this core library handling types from your front-end.</p>
<p>So, you sigh, and write the equivalent of a Rust match expression, but in Java (please pardon my absurd hypothetical HTML library):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Html userIdToHtml(UserId userId) {
    if (userId instanceof Username) {
        Username username = (Username)userId;
        String usernameString = username.getUsername();
        Url url = ProfileHandler.getProfileForUsername(usernameString);
        return Link.createTextLink(url, username.getUsername());
    } else if (userId instanceof AnonymousUser) {
        AnonymousUser anonymousUser = (AnonymousUser)userId;
        return Span.createColoredText(anonymousUser.getIp().formatString(), &quot;red&quot;);
    } else {
        throw new RuntimeException(&quot;IDK, man&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And this code your boss rejects upon code review, saying you used the instanceof anti-pattern, but then later they grudgingly accept it after you make them argue with the maintainer of the core library that wouldn’t accept your other patch.</p>
<p>But look at how ugly that instanceof code is! No wonder Java programmers consider it an anti-pattern! But in this situation, it’s the most reasonable thing, really the only possible thing besides implementing the observer pattern or the visitor pattern or something else that just amounts to infrastructure to fake an instanceof with inversion of control.</p>
<p>Having operations implemented by adding a method to every subclass makes sense when the set of operations is bounded (or close to it) and the number of subclasses of the class might grow in unanticipated ways. But just as often, the number of operations will grow in unanticipated ways, while the number of subclasses is bounded (or close to it).</p>
<p>For the latter situation, which is more common than OOP advocates would imagine, Rust enums – and sum types in general – are perfect. Once you’ve gotten used to them, you find yourself using them all the time.</p>
<p>I will say for the record that it isn’t this bad in all object-oriented programming languages. In some, you can write arbitrary class-method combinations in any order, and so you could write all three implementations in one place if you so chose. Smalltalk traditionally lets you navigate the codebase in a special browser, where you can see either a list of methods implemented by a class, or a list of classes that accept a given “message,” as Smalltalk calls it, so you can have your cake and eat it too.</p>
<h3 id="alternative-1-closures"><a class="header" href="#alternative-1-closures">Alternative #1: Closures</a></h3>
<p>Sometimes, an OOP interface or polymorphic decision only involves one actual operation. In such a situation, a closure can just be used instead.</p>
<p>I don’t want to spend too much time on this, because most OOP programmers are already aware of this, and have been since their OOP languages have caught up with functional languages and gotten syntax for lambdas – Java in Java 8, C++ in C++11. Silly one-method interfaces like Java’s Comparator are therefore – fortunately – mostly a thing of the past.</p>
<p>Also, closures in Rust technically involve traits, and so are implemented using the same mechanism as the next two alternatives, so one could also argue that this isn’t really a separate option in Rust. In my mind, however, lambdas, closures, and the FnMut/FnOnce/Fn traits are special enough aesthetically and situationally that it deserved a little bit of time.</p>
<p>And so I’ll take the little bit of time to just say this: If you find yourself writing a trait (or a Java interface or a C++ class) with exactly one method, please consider whether you should instead be using some sort of closure or lambda type. Only you can prevent overengineering.</p>
<h3 id="alternative-2-polymorphism-with-traits"><a class="header" href="#alternative-2-polymorphism-with-traits">Alternative #2: Polymorphism with Traits</a></h3>
<p>Just like Rust has a version of encapsulation more flexible and more powerful than the OOP notion of classes, as I discuss in the previous post, Rust has a more powerful version of polymorphism than OOP posits: traits.</p>
<p>Traits are like interfaces from Java (or an all-abstract superclass in C++), but without most of the constraints that I discuss at the beginning of the blog post. They have neither the semantic constraints or the performance constraints. Traits are heavily inspired in semantics and principle by Haskell’s typeclasses, and in syntax and implementation by C++’s templates. C++ programmers can think of them as templates with concepts (except done right, baked into the programming language from the get-go, and without having to deal with all the code that doesn’t use it).</p>
<p>Let’s start with the semantics: What can you do with traits that you can’t do with pure OOP, even if you throw all the indirection in the world at it? Well, in pure OOP terms, there’s no way you can write an interface like Rust Eq and Ord, given greatly oversimplified definitions here (the real definitions of Eq and Ord extend other classes that allow partial equivalence and orderings between different types, but like these simplified definitions, the Rust standard library version of non-partial Eq and Ord do cover equivalence and ordering between values of the same type):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Eq {
    fn eq(self, other: &amp;Self) -&gt; bool;
}

pub enum Ordering {
    Less,
    Equal,
    Greater,
}

trait Ord: Eq {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p>See what’s happening? Like in an OOP-style interface, the methods take a “receiver” type, a self parameter, of the Self type – that is, of whatever concrete type implements the trait (technically here a reference to Self or &amp;Self). But unlike in an OOP-style interface, they also take another argument of &amp;Self type. In order to implement Eq and Ord, a type T provides a function that takes two references to T. That’s meant literally: two references to T, not one reference to T and one reference to T or any subclass (such a thing doesn’t exist in Rust), not one reference to T and one reference to any other value that implements Eq, but two bona-fide non-heterogeneous references to the same concrete type, that the function can then compare for equality (or ordering).</p>
<p>This is important, because we want to use this to implement methods like sort:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec&lt;T&gt; {
    pub fn sort(&amp;mut self) where T: Ord {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>OOP-style polymorphism is ideal for heterogeneous containers, where each element has its own runtime type and its own implementation of the interfaces. But sort doesn’t work like that. You can’t sort a collection like [3, &quot;Hello&quot;, true]; there’s no reasonable ordering across all types.</p>
<p>Instead, sort operates on homogeneous containers. All the elements have to match in type, so that they can be mutually compared. They don’t each need to have different implementations of the operations.</p>
<p>Nevertheless, sort is still polymorphic. A sorting algorithm is the same for integers or strings, but comparing integers is a completely different operation than comparing strings. The sorting algorithm needs a way of invoking an operation on its items – the comparison operation – differently for different types, while still having the same overall structure of code.</p>
<p>This can be done by injecting a comparison function, but many types have an intrinsic, default ordering, and sort should default to it. Thus, polymorphism – but not an OOP-friendly variety.</p>
<p>See the contrivance Java goes through to define sort:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static &lt;T extends Comparable&lt;? super T&gt;&gt; 
void sort(List&lt;T&gt; list)
<span class="boring">}</span></code></pre></pre>
<p>There is no simple trait that can require T to be comparable to other Ts, for T to be ordered. Instead, as far as the programming language is concerned, the idea that T is comparable to itself, rather than to any other random type, is only articulated as an accident to this method. Nothing is stopping someone from implementing the Comparable interface in an inconsistent way, like having Integer implement Comparable<String>.</p>
<p>Additionally, when it actually looks up the implementation of Comparable, it decides what implementation to use based on the first argument of any comparison, not based on the type. Normally, they will all be the same type, but theoretically, this list could be heterogeneous, as long as all the objects “extend” T, and they could implement Comparable differently. The computer has to do extra work to indulge this possibility, even though it would certainly be a mistake.</p>
<p>As we’re now drifting outside of the realm of semantics, and into the realm of performance, let’s discuss the performance implementations of this fully.</p>
<p>The Java sort method, as we mentioned, requires every item in the collection to be a full object type, which means that instead of storing the values directly in the array, the values are stored in the heap, and references are stored in the array. This is unnecessary with a traits-based approach – the values can live directly in the array.</p>
<p>This means that different arrays will have different element sizes, so this has to be handled by a trait as well. And it is: The size of the values is also parameterized via the Sized trait. The size does have to be consistent among all the items of the array, but this is enforceable because we can express that all the elements are actually the exact same type – unlike Java’s List<T> which only expresses that they’re of type T or some subtype of T.</p>
<p>Rust’s sort method could have been implemented by passing the size information (from the Sized trait) and the ordering function (from the Ord trait) at runtime as an integer value and a function pointer. This is how typeclasses work in Haskell, which was the inspiration for Rust traits. This would still be more efficient than the Java, as there would be a single ordering function, rather than a different indirect lookup for every left side of the comparison, allowing indirect branch prediction to work in the processor.</p>
<p>But Rust goes even further than that, and implements its traits instead via monomorphization. This is similar to C++ template instantiation, but semantically better constrained. The premise is that while sort is only one method semantically, in the outputted, compiled code, a different version of sort is outputted for every type T that it is called with.</p>
<p>C++ templates create infamously bad error messages and are difficult to reason about, because they are essentially macros, and awkward ones. Even Rust cannot create great error messages with its macro system. But also, writing them requires expertise, and means that the programmer is forgoing many of the benefits of the type system – templates are often called, in my opinion rightly so, a form of compile time duck-typing. For these reasons, template programming in C++ is often considered more advanced (read as harder and less convenient rather than more powerful) than OOP-style polymorphism.</p>
<p>In Rust, however, traits provide an organized and more coherent way of accessing similar technology, getting the performance benefits of templates while still giving the structure of a solid type system.</p>
<h3 id="alternative-3-dynamic-trait-objects"><a class="header" href="#alternative-3-dynamic-trait-objects">Alternative #3: Dynamic Trait Objects</a></h3>
<p>Sometimes, however, you do need full run-time polymorphism. You have the opposite of the scenario with the enum: You have a closed set of operations that can be performed on a value, but what those operations actually do will change dynamically in a way that cannot be bounded ahead of time.</p>
<p>In such situations, Rust has you covered with the dyn keyword. Please don’t overuse it, though. In almost all situations where I’ve thought it might be appropriate, static polymorphism combined with other design elements have worked out better.</p>
<p>Legitimate use cases for dyn tend to come up in situations involving inversion of control, where a framework library takes on a main loop, and the client code says how to handle various events. In network programming, the framework library says how to juggle all the sockets and register them with the operating system, but the application needs to say what to actually do with the data. In GUI programming, the framework code can say what widget was being clicked on, but very different things happen if that widget is a button versus a text box versus a custom widget you invented for this particular app.</p>
<p>Now, you don’t strictly need run-time polymorphism for this. You could use closures (or even raw function pointers) instead, creating struct of closures (or function pointers) if multiple operations are called for – which amounts to basically doing what dyn does the hard way by hand. For example, I fully expected tokio to use Rust’s run-time polymorphism feature internally to handle this inversion of control in task scheduling. Instead, for what I imagine are performance reasons, tokio implements dyn by hand, even calling its struct of function pointers Vtable.</p>
<p>But dyn does all of this work for you, for your trait. The only requirement is that your trait be object-safe, and the list of requirements may seem familiar, especially when it comes to the requirements for an associated function (e.g. a method) to be “dispatchable”:</p>
<hr />
<ul>
<li>Not have any type parameters (although lifetime parameters are allowed),</li>
<li>Be a method that does not use Self except in the type of the receiver.</li>
<li>Have a receiver with one of the following types:
<ul>
<li>&amp;Self (i.e. &amp;self)</li>
<li>&amp;mut Self (i.e &amp;mut self)</li>
<li>Box<Self></li>
<li>Rc<Self></li>
<li>Arc<Self></li>
<li>Pin<P> where P is one of the types above</li>
</ul>
</li>
<li>Does not have a where Self: Sized bound (receiver type of Self (i.e. self) implies this).</li>
</ul>
<hr />
<p>That is to say, it can be polymorphic in exactly one parameter, and that parameter must be by reference – more or less the exact requirements for methods to support run-time polymorphism in OOP.</p>
<p>This is of course because dyn uses almost exactly the same mechanism as OOP to implement run-time polymorphism: the “vtable.” Box<dyn Foo> really contains two pointers rather than one, one to the object in question, and the pointer to the “vtable,” the automatically-generated structure of function pointers for that type. The one-parameter requirement is because that is the parameter whose vtable is used to look up which concrete implementation of a method to call, and the indirection requirement is because the concrete type might be different sizes, with the size only known at run-time.</p>
<p>To be clear, these are limitations on one particular implementation strategy for run-time polymorphism. Alternative strategies exist that fully decouple the vtable from individual values of the type, as in Haskell.</p>
<p>There are still a few advantages of Rust’s version of run-time polymorphism with traits as opposed to OOP-style interfaces.</p>
<p>Performance-wise, it’s something done alongside a type, rather than intrinsic to the type. Normal values don’t store a vtable, spreading the cost of this throughout the program, but rather, the vtables are only referenced when a dyn pointer is created. If you never create a dyn pointer to a value of a given type, that type’s vtable doesn’t even have to be created. Certainly, you don’t have 8 bytes of extra gunk in every allocation for all the vtable pointers! This also means there’s one fewer level of indirection.</p>
<p>Semantically, it’s also a good thing that it’s just one option among many, and that it’s not the strongly preferred option that the entire programming language is trying to push you towards. Often, even usually, static polymorphism, enums, or even just good old-fashioned closures more accurately represent the problem at hand, and should be used instead.</p>
<p>Finally, the fact that run-time and static polymorphism in Rust both use traits makes it easier to transition from one system to another. If you find yourself using dyn for a trait, you don’t have to use it everywhere that trait is used. You can use the mechanisms of static polymorphism (like type parameters and impl Trait) instead, freely mixing and matching with the same traits.</p>
<p>Unlike in C++, you don’t have to learn two completely different sets of syntax for concepts vs parent classes, and vastly different semantics. Really, in Rust, dynamic polymorphism is just a special case of static polymorphism, and the only differences are the things that actually are different.</p>
<h2 id="logging-13"><a class="header" href="#logging-13">logging</a></h2>
<ul>
<li>230215 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-和默认参数"><a class="header" href="#rust-和默认参数">Rust 和默认参数</a></h1>
<p>原文: <a href="https://www.thecodedmessage.com/posts/default-params/">Rust and Default Parameters :: The Coded Message</a></p>
<blockquote>
<p>快译</p>
</blockquote>
<p>Rust 不支持函数声明中的默认参数;
而且和很多语言不同, 无法通过函数重载来模拟;
这让很多来自其它编程语言的 Rustacean 新人感到沮丧,
所以, 就想解释一下为什么这其实是件好事儿,
以及,如果使用默认 trait 和结构更新语法来实现类似的效果;</p>
<p>默认参数(和函数重载)不是面向对象编程的一部分,
但是,又是许多 Rustaceans 新人原先编程语言的共同特征;
因此, 这篇文章在某些方面和我正在进行的关于 Rust 如何不是面向对象的系列文章相吻合,
故而, 被标准为这个系列的文章;
还受到 Reddit 中对我第一篇 OOP 相关贴子回复的启发;</p>
<h2 id="默认秋粮是如何工作咯比如-c"><a class="header" href="#默认秋粮是如何工作咯比如-c">默认秋粮是如何工作咯(比如 C++)</a></h2>
<p>在开始讨论为什么 Rust 没有默认参数以及我们可以折腾什么之前,
得先聊明白什么是默认参数以及在哪些情况下有用;</p>
<p>假设你有一个带有很多参数的函数,
比如(以 Reddit 回复中的示例)在 GUI 中创建一个窗口:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible)

auto handle = createWindow(10, 30, false); // Create invisible window
auto handle2 = createWindow(100, 500, true); // Create visible window
</code></pre>
<p>现在, 假设你准备创建的大多数窗口都是可见的,
并且,你不想让程序员负担必须指定窗口是否可见的担心 --- 甚至于不想明确的考虑这事儿 --- 在正常情况下,
在支持默认参数的编程语言中,你可以为可见性提供默认值:</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true)

auto handle = createWindow(10, 30, false); // Create invisible window!

auto handle2 = createWindow(100, 500, true); // Create visible window!

auto handle3 = createWindow(100, 500); // Also create visible window!
auto handle4 = createWindow(100, 500); // Most of the time, that's what
auto handle5 = createWindow(100, 500); // you want, so why have to say it?
Default parameters can also be simulated with function overloading for programming languages where function overloading is available but default parameters are not:

WindowHandle createWindow(int width, int height, bool visible);

WindowHandle createWindow(int width, int height) {
    return createWindow(width, height, true);
}
</code></pre>
<p>Rust 也没有函数重载,这是个复杂的多的问题,
但是, 很多相同的论点都适用这个习惯用法的理解;</p>
<h2 id="默认参数的好处和坏处"><a class="header" href="#默认参数的好处和坏处">默认参数的好处(和坏处)</a></h2>
<p>默认值很好,这种风格的默认参数是实现并从中获益的一种方式;</p>
<p>默认值是好的,因为,她们坚持 DRY 原则 --- 不要重复自己(Don’t Repeat Yourself);
如果我们没有默认值, 就不得不重复那些实际上对理解代码没有帮助的参数;
如果最佳默认秋粮的更改方式楼主更新代码的最佳方法是继续使用默认值--- 也许因为最佳实践发生了变化 ---
我们将不得不更新每个调用, 而不是只要更改一处, 定义了默认参数那里;</p>
<p>默认徝很好,因为,她们减少了程序员的认知负担;
程序员必须一次性在大脑中保留大量信息,
而默认设置通过不强迫在无关场景时要考虑额外的细节来帮助程序员---这是太多数默认设置的常见作用场景;</p>
<p>默认秋粮也使代码更加简洁,
因此, 很受欢迎;
但是,这不是专有的特殊价值;
我相信 DRY 原则很重要, 这通常意味着更加简洁的代码,
但是,考虑到现代编辑器和 IDE, 以及现代人劝为把不用又和阅读速度的期待,
适度的冗长以能换取其它好处(比如, 清晰度和明确性),
我还是完全可以接受的;
相信默认参数,因为这是在 C++ 和 Python 中实现的,
在清晰度和明确性方面付出了巨大的代价,
因此,简洁性并不是证明她们合理的充分理由;</p>
<p>在这种情况中, 让我特别困扰的是代码中的不清晰之处,
在于代码的读者不知道可能还有更多的参数;
没有暗示可能还有其它秋粮;
如果维护者想更改其中一个调用以便创建不可见的窗口,
领导作用可能没有意识到应该先检验 create_window 的文档:
毕竟, 似乎只接受两个参数,
而且也没有任何远程反应针对不可见窗口;</p>
<p>幸运的是, Rust 具有替代特性,
使我们能在不牺牲明确性和清晰性的情况下,
也获得认知负荷和 DRy 的好处;</p>
<h2 id="rust-中的默认值-默认-trait"><a class="header" href="#rust-中的默认值-默认-trait">Rust 中的默认值: 默认 trait</a></h2>
<p>Rust 不允许使用默认参数,
而是允许你使用 Default trait 有选择的为你的类型指定默认值;</p>
<p>是这样工作的:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz,
}

impl Default for Foo {
    fn default() -&gt; Self {
        Foo::Bar
    }
}
<span class="boring">}</span></code></pre></pre>
<p>或是, 使用更加简洁的 派生/derive 语法编写:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum Foo {
    #[default]
    Bar,

    Baz,
}
<span class="boring">}</span></code></pre></pre>
<p>一旦定义了这个默认值,
Foo::default() 或是(在类型明确的上下文中) Default::default() 就可以代表 Foo::Bar ;</p>
<p>如果你习惯为你的函数参数重用现有类型,
这可能看起来比不用更加糟糕;
毕竟, 我们默认的参数是 bool 类型的,
孤儿规则(在 Rust 的 trait 相关章节有解释) 禁止我们在 bool 上定义默认 trait ---
正如我在上面提及的, Default 允许你对类型定义默认值;
即便,我们可以为 bool 设置默认值也是一件过于强大的事儿,
无法仅仅为这个函数参数提供默认值!
毕竟, 其它一些函数也可能有一个具有不同默认值的 bool 类型参数;</p>
<p>但是,如果在 Rust 中考虑, 这更加有意义 --- 甚至是惯用的和首选的 --- 为配置和函数参数等等创建自定义类型;
毕竟, 如果你不查实文档, 可能不清楚 true 的含义;
甚至于不清楚和可见性有什么关系,
更不用说很容易将 true 当参数时意味着不可见窗口是可见的;</p>
<p>在 Rust 中,我们更加愿意为这一情况定义一个新类型, 一个列出可见性选项的枚举---如果创建一个新的可见性选项,
这才有所帮助;
在这个枚举上, 声明一个默认值才是合理的:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum WindowVisibility {
    #[default]
    Visible,

    Invisible,
}
<span class="boring">}</span></code></pre></pre>
<p>是的, 这比我们的原始代码有些冗长, 但更清晰,
而且不乏 DRY ;
简洁本身并不是一种价值;
明确的列出选项比隐式选项更可取;</p>
<p>然后, 当我们调用该函数时, 可以这么使用默认值:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_window(width: u32, height: u32, visibility: WindowVisibility) -&gt; WindowHandle;

let handle = create_window(10, 30, WindowVisibility::Invisible);
let handle2 = create_window(100, 500, WindowVisibility::Visible);

let handle3 = create_window(100, 500, WindowVisibility::default());
let handle4 = create_window(100, 500, WindowVisibility::default());
let handle5 = create_window(100, 500, Default::default()); // 也允许
<span class="boring">}</span></code></pre></pre>
<p>正如承诺的那样, 这样冗长些, 同样 DRY,
但是, 更加明确和清晰; (无歧义)</p>
<p>注意: 我使用独立函数只是为了举例;
实际上, 这个特定函数很可能是类型内部方法的一部分,
例如 WindowHandle::new 或是 WindowHandle::create_window;</p>
<h3 id="rust-中默认值缩放-结构更新语法"><a class="header" href="#rust-中默认值缩放-结构更新语法">Rust 中默认值缩放: 结构更新语法</a></h3>
<p>所以, 这对于一个默认值来说形式上更好;
但是,拓展性并不好;
如果我们想在我们的窗口创建函数中追加另外3个参数怎么办?
在 C++ 中, 可以可以为她们提供默认值,
调用者甚至不需要更新(参数仅用来示例, 并不代表在创建窗口):</p>
<pre><code class="language-C++">WindowHandle createWindow(int width, int height, bool visible = true,
                          WindowStyle windowStyle = WindowStyle::Standard,
                          int z_position = -1,
                          bool autoclose = false);

createWindow(100, 500); // Still works identically
createWindow(100, 500, false); // Also still works
createWindow(100, 500, false, WindowStyle::Standard, 2, true); // Specify everything
</code></pre>
<p>这是一个有用的功能;
在 Rust 中,使用目前讨论的技术,
无论参数有多少,我们都必须重复编写 Default::default() ;
这是 DRY 违规行为, 会干挠追加新参数的能力;</p>
<p>但是, 此功能也存在缺陷;
你现在已经限制自己在左侧指定参数,
以便在右侧追加参数;
在调用 createWindow 最后一个示例中, 我们通过显式指定一个值来违反 DRY,
当时我们可能想使用默认值,但是,该值不可用, 因为,我们想为以后的参数覆盖默认值;</p>
<p>幸运的是, Rust 也有这种版本;
正如我们只是为了这个函数调用而创建了一个枚举一样,
在 Rust 中为这种配置参数创建结构也是惯用的;
该结构看起来像这样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowConfig {
    pub width: u32,
    pub height: u32,
    pub visibility: WindowVisibility,
    pub window_style: WindowStyle,
    pub z_position: i32,
    pub autoclose: AutoclosePolicy,
}
<span class="boring">}</span></code></pre></pre>
<p>然后, 我们就可以为整个结构指定 Default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for WindowConfig {
    fn default() -&gt; Self {
        Self {
            width: 100,
            height: 100,
            visibility: WindowVisibility::Visible,
            window_style: WindowStyle::Standard,
            z_position: -1,
            autoclose: AutoclosePolicy::Disable,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>现在, 似乎使用起来很乏味;
你可能想象得这么使用:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = WindowConfig::default();
config.width = 500;
config.z_position = 2;
config.autoclose = AutoclosePolicy::Enable;
let handle = create_window(config);
<span class="boring">}</span></code></pre></pre>
<p>我认为即便是这样也比默认秋粮可取,
因为,这样是明确的;
然而, Rust 有一个专门为这种情况设计的语法结构:
struct update syntax ;
有了这,我们获得的东西和默认参数非常相似,
但是,更冗长/明确/灵活:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = create_window(WindowConfig {
    width: 500,
    z_position: 2,
    autoclose: AutoclosePolicy::Enable,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<p>不像 C++ 风格的言论参数,
我们可以完全覆盖我们想要的默认值;
同样明确的是,
如果我们愿意, 甚至可以修改其它参数,
而不需强制维护开发者检查文档;</p>
<p>除此之外, 这样允许定义其它默认值集;
除了 WindowConfig::default 之渑, 可能还有另外一组用来创建对话框的配置参数,
例如: like WindowConfig::dialog() 或是 WindowConfig::default_dialog ;
程序员通常在创建不可见窗口, 或是高度相同的窗口应用,
可能会定义自己的默认设置, config::app_local_default_window_config();
这些不会通过 Default 特性来调解,
但是, Default 只是一个 trait ,
而 Default::default() 是一个方法调用;
你可以改为调用自己的方法,
并仍然使用此<code>结构更新语法</code>;</p>
<p>所以,现在我们在 Rust 中有一个习惯用语系统来替换默认参数;
这和 DRY 一样,
并且同样减少了认知负荷;
更加重要的是, 这样作并没有牺牲对到底发生了什么的明确性与清晰性 --- 一个给定的函数总是采用相同数量的参数,
这是 Rust 维护开发者可以(并且正在)依赖的不变量;</p>
<h3 id="构建器模式"><a class="header" href="#构建器模式">构建器模式</a></h3>
<p>在这点上, Rustacean 老手们应该能注意到还没讨论一种通用的 Rust 方法来设计这些配置结构,
即:  <code>构建器模式</code> (Builder Pattern);</p>
<p>这是有原因的: 我不喜欢丫的;
(译按: 千金婎买我愿意, 没错...)
我个人更加喜欢使用 Default 和 struct update 语法,
其它人可能会使用  <code>构建器模式</code>  ;
我认为这种模型不够明确, 而且由于在非 OOP 编程语言方面有很多经验,
所以,我觉得这是一种没有问题的解决方案, 主要成果只是令代码看起来更加 OOP 而已;</p>
<p>不过, 这也是 Rust 中常用的模式, 一般使用 <code>构建器模式</code> 的 crate,
因而值得熟悉之;
这和以往的概念相同:
使用充满参数的结构, 将配置发送到 构建函数或是函数调用;
有时这种会被称为 WindowBuilder 而不是 WindowConfig;</p>
<p>但是, 不直接使用结构更新语法, 而是添加了一堆辅助方法来执行结构更新:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>或者, 正如想指出的那样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn height(self, height: u32) -&gt; Self {
        Self {
            height,
            ..self
        }
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>有时, 枚举被拆分为多个更新方法:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn autoclose_enable(mut self) -&gt; Self {
        self
        self.autoclose = AutoclosePolicy::Enable;
    }

    fn autoclose_disable(mut self) -&gt; Self {
        self.autoclose = AutoclosePolicy::Disable;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然后, 通常并不是调用例如: window constructor,
你调用在构建器上定义的构建方法
(此时,已经对影响设计的无偿 OOP 哲学感到畏缩)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WindowBuilder {
    fn build(self) {
        window_create(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>其实,不用 struct update 语法,
而是将对这些方法调用链接在一起:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = WindowBuilder::new()
    .width(500)
    .z_position(2)
    .autoclose_enable()
    .build();
<span class="boring">}</span></code></pre></pre>
<p>我仍然更加喜欢这个, 而不是默认参数,
但是, 同时也感觉有点俗气;
我不喜欢被迫使用像 构建器 这样的抽象&quot;对象&quot;来思考,
也不喜欢这种风格中更直观的假设;
为什么 &quot;构建器&quot; 是作某件事儿的对象?
为什么它比&quot;配置&quot;结构更受欢迎?
OOP 程序员是否意识到在现实生活中, 绝大多数对象根本不作任何事儿,
当然, 也不会构建其它对象?</p>
<p>但是, 对于熟悉 OOP 习惯用法的人来说,
这可能更可取;
这是一个普通选择的选项, 因此, 至少识别这种模式很重要;</p>
<h2 id="结论和应用"><a class="header" href="#结论和应用">结论和应用</a></h2>
<p>Rust 有很多不同于其它语言的习惯;
我经常看到新的 Rustacean 提议为 Rust 添加默认参数和其它类似的功能,
而这些新 Rustacean 感到困惑的是, 
领导作用感受到的强烈要求在更大的 Rust 社区中并没有被广泛感受到;</p>
<p>通常, 这和默认参数类似;
有实现相同目标的替代习语, 嘦这些目标符合 Rust 的价值观:
在此场景中, DRYness 并减少开发者认知负担;
根据 Rusty 的价值观, 她们在其它方面也是更好的解决方案: 额外的明确性值得多点冗长代码;</p>
<p>所以, 我希望这可以作为一个案例研究来报时大家理解,
通常总是有 Rusty 的方法来实现 OOP 领域流行功能目标,
以及, 为什么 Rustacean 更加喜欢这些方案而不是盲目的积累新功能;</p>
<h2 id="logging-14"><a class="header" href="#logging-14">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230220 ZQ v0 DONE</li>
<li>230212 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="笔记"><a class="header" href="#笔记">笔记</a></h1>
<blockquote>
<p>logging</p>
</blockquote>
<h2 id="background-8"><a class="header" href="#background-8">background</a></h2>
<blockquote>
<p>无奈背景</p>
</blockquote>
<p>任何自学都需要探索+内省, 同时来, 否则, 很容易不知道在折腾什么...</p>
<h2 id="goal-6"><a class="header" href="#goal-6">goal</a></h2>
<blockquote>
<p>必要目标</p>
</blockquote>
<ul>
<li>是谁?</li>
<li>在哪?</li>
<li>去哪?</li>
</ul>
<p>随时嗯哼明白...</p>
<h2 id="trace-6"><a class="header" href="#trace-6">trace</a></h2>
<blockquote>
<p>具体推进</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
基本环境</li>
<li><input disabled="" type="checkbox"/>
基本语法</li>
<li><input disabled="" type="checkbox"/>
基本 std</li>
<li><input disabled="" type="checkbox"/>
基本项目结构</li>
<li><input disabled="" type="checkbox"/>
基本经典工程</li>
<li><input disabled="" type="checkbox"/>
基本...习惯们?</li>
</ul>
<h2 id="refer-11"><a class="header" href="#refer-11">refer.</a></h2>
<blockquote>
<p>关键参考</p>
</blockquote>
<h2 id="logging-15"><a class="header" href="#logging-15">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>221023 ZQ init.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-丑句法"><a class="header" href="#rust-丑句法">Rust 丑句法</a></h1>
<p>原文: <a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html#Rust-s-Ugly-Syntax">Rust's Ugly Syntax</a></p>
<h2 id="快译-5"><a class="header" href="#快译-5">快译</a></h2>
<p>大家抱怨 Rust 的语法;
不过,俺想大多数时候,
当人们认为在对 Rust 语法有疑问时,
实际上在反抗对应语义;
在这篇有点儿异想天开的文章中,
俺将尝试理清这两点;</p>
<p>先从一个丑陋的语法示例开始:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}</span></code></pre></pre>
<p>此函数读取给定二进制文件内容;
这是直接从标准库中提取的, 所以, 不算是稻草人式无用示例;
而且,至少对俺来说, 这绝对不算漂亮;</p>
<p>让我们想象一下,如果 Rust 有更好的语法, 这个函数应该是什么样儿;
如果和真正的编程语言有任何相似之处, 无论真假, 纯属试合!</p>
<p>从 Rs++ 开始:</p>
<pre><code class="language-c++">template&lt;std::HasConstReference&lt;std::Path&gt; P&gt;
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
std::read(P path) {
    return read_(path.as_reference());
}

static
std::io::outcome&lt;std::vector&lt;uint8_t&gt;&gt;
read_(&amp;auto const std::Path path) {
    auto file = try std::File::open(path);
    std::vector bytes;
    try file.read_to_end(&amp;bytes);
    return okey(bytes);
}
</code></pre>
<p>Rhodes 变体:</p>
<pre><code class="language-ruby">public io.Result&lt;ArrayList&lt;Byte&gt;&gt; read&lt;P extends ReferencingFinal&lt;Path&gt;&gt;(
        P path) {
    return myRead(path.get_final_reference());
}

private io.Result&lt;ArrayList&lt;Byte&gt;&gt; myRead(
        final reference lifetime var Path path) {
    var file = try File.open(path);
    ArrayList&lt;Byte&gt; bytes = ArrayList.new();
    try file.readToEnd(borrow bytes);
    return Success(bytes);
}
</code></pre>
<p>经典 RhodesScript:</p>
<pre><code class="language-js">public function read&lt;P extends IncludingRef&lt;Path&gt;&gt;(
    path: P,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    return myRead(path.included_ref());
}

private function myRead(
    path: &amp;const Path,
): io.Result&lt;Array&lt;byte&gt;&gt; {
    let file = try File.open(path);
    Array&lt;byte&gt; bytes = Array.new()
    try file.readToEnd(&amp;bytes)
    return Ok(bytes);
}
</code></pre>
<p>响尾蛇/Rattlesnake:</p>
<pre><code class="language-python">def read[P: Refing[Path]](path: P): io.Result[List[byte]]:
    def inner(path: @Path): io.Result[List[byte]]:
        file := try File.open(path)
        bytes := List.new()
        try file.read_to_end(@: bytes)
        return Ok(bytes)
    return inner(path.ref)
</code></pre>
<p>以及, CrabML:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>read :: 'p  ref_of =&gt; 'p -&gt; u8 vec io.either.t
let read p =
  let
    inner :: &amp;path -&gt; u8 vec.t io.either.t
    inner p =
      let mut file = try (File.open p) in
      let mut bytes = vec.new () in
      try (file.read_to_end (&amp;mut bytes)); Right bytes
  in
    ref_op p |&gt; inner
;;
<span class="boring">}</span></code></pre></pre>
<p>作为一个稍微严肃和有用的练习,
让我们作相反的尝试--保留 Rust 语法,
但是, 尝试简化语义直到最终结果, 看会是什么样儿;</p>
<p>这是我们的起点:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}
<span class="boring">}</span></code></pre></pre>
<p>这时, 最大的噪音源是嵌套函数;
动机有点儿深奥;
外部函数是通用的,而内部不是;
使用编译模式,这意味着外部函数和用户代码一起编译,
而嵌的将优化;
相比之下, 内部函数是在编译 std 本身时编译的,
从而节省了编译用户代码的时间;
简化这一点(损失一些性能)的一种方法,
说是泛型函数总是单独编译,
但是,能在幕后接受一个额外的运行时秋粮, 可以描述物理维度上的输入参数;</p>
<p>这样我们获得:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path.as_ref())?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>下个噪音元素是 <code>&lt;P: AsRef&lt;Path&gt;&gt;</code> 约束;
这是必需的,因为 Rust 喜欢将内存中字节的物理布局作为接口公开,
特别是对可以带来性能的情况;
特殊的, Path 的含义并不是文件路径的某种抽象,
这里只是字面意义上内存中的一堆连续字节;
所以, 我们需要 AsRef 来将其和任何能够表示这种字节片的抽象一起工作;
但是, 如果我们不关心性能,
就可以要求所有接口都相当抽象,并通过虚函数调用进行调解,
而不是直接访问内存;
那么, 我们就不需要 AsRef 这堆东西了:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Vec::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>这样简化后,我们实际上也可以摆脱 <code>Vec&lt;u8&gt;</code> -- 如果我们不再使用泛型来表达语言本身的高效可增长字节数组;
我们必须使用运行时提供的一些不透明字节类型:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: &amp;Path) -&gt; io::Result&lt;Bytes&gt; {
  let mut file = File::open(path)?;
  let mut bytes = Bytes::new();
  file.read_to_end(&amp;mut bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>从技术上讲,我们仍然随身携带所有权和备用系统,
但是,由于无法直接控制类型的内存布局,
就无法带来巨大的性能优势;
仍然有助于避免 GC,防止迭代器失效,
并静态检验非线程安全代码是否实际上没有跨线程使用;
不过, 如果我们只切换到 GC, 我们可以轻松摆脱那些 &amp;指针;
我们甚至于不需要太担心并发性--因为,我们的对象是单独分配的,而且总是在指针后面,
我们可以通过注意到指针大小,
无论是否在 x86 系统上都是原子操作来消除数据竞争;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; io::Result&lt;Bytes&gt; {
  let file = File::open(path)?;
  let bytes = Bytes::new();
  file.read_to_end(bytes)?;
  Ok(bytes)
}
<span class="boring">}</span></code></pre></pre>
<p>最后,我们在这对错误的处理过于迂腐 -- 我们并仅要关注返回类型失败的可能,
甚至于要用 ? 来突出指示任何可能失败的特定表达式;
完全不考虑错误处理,
让一些顶层处理程序来处理:
(比如: try { } catch (...) { /* intentionally empty */ })</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read(path: Path) -&gt; Bytes {
  let file = File::open(path);
  let bytes = Bytes::new();
  file.read_to_end(bytes);
  bytes
}
<span class="boring">}</span></code></pre></pre>
<p>现在是否好多了?</p>
<h2 id="ps"><a class="header" href="#ps">PS:</a></h2>
<p>的确是篇奇想, 这样简化后, 几乎就是 多了一些控制符号的 Python 了,
又或是根本可以视为 TypeScript 了;
当然, 如果有这种低效版 Rust 多数程序员还是愿意使用的;
就象当年 CoffeeScript 的尝试;</p>
<h2 id="logging-16"><a class="header" href="#logging-16">logging</a></h2>
<blockquote>
<p>版本记要</p>
</blockquote>
<ul>
<li>..</li>
<li>230206 ZQ init.</li>
</ul>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->


                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">

        </nav>

    </div>




    <script>
        window.playground_copyable = true;
    </script>


    <script src="elasticlunr.min.js" charset="utf-8"></script>
    <script src="mark.min.js" charset="utf-8"></script>
    <script src="searcher.js" charset="utf-8"></script>

    <script src="clipboard.min.js" charset="utf-8"></script>
    <script src="highlight.js" charset="utf-8"></script>
    <script src="book.js" charset="utf-8"></script>

    <!-- Custom JS scripts -->

    <script>
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>

    <hr />

    <p style="text-align:center">

        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议"
                style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
        本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可;-)

    </p>
    <hr />

    <script src="https://utteranc.es/client.js" repo="zhrust/comments" issue-term="pathname" label="✨💬✨"
        theme="github-light" crossorigin="anonymous" async>
        </script>

</body>

</html>