<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>be Rustaceans ~ 成锈纪</title><link>https://rs.101.so</link><description>~ 汇集 大妈/Zoom.Quiet 学习/实践/探索/... Rust 世界锈迹, 一起成为 Rustacean 吧...</description><generator>my_rss_generator</generator><item><title>rustlings_94.md</title><link>https://rs.101.so//101/rustlings_94</link><pubDate>Thu, 30 Mar 2023 11:59:15 +0800</pubDate><content:encoded><![CDATA[# rustlings:94

## background
> conversions/as_ref_mut.rs

AsRef and AsMut allow for cheap reference-to-reference conversions.

Read more about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html

and https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.


## goal
> 必要目标

快速通过

## trace
> 具体推进

还是要在 GPT 的辅助下掠过:

核心问题是完成函数:

```rust
fn num_sq<T>(arg: &mut T) {
    // TODO: Implement the function body.
    ???
}

// 对应的测试

    #[test]
    fn mult_box() {
        let mut num: Box<u32> = Box::new(3);
        num_sq(&mut num);
        assert_eq!(*num, 9);
    }

```

看起来就是对 arg 进行自乘而已

但是照猫画虎才发现:

```rust
fn num_sq<T>(arg: &mut T)
    where T: std::ops::Mul<Output = T> + std::ops::MulAssign + Copy
{
    let square = *arg * *arg;
    *arg *= *arg;
    *arg = square;
}
```

这样触发一系列问题:
```

error[E0277]: cannot multiply `Box<u32>` by `Box<u32>`
  --> exercises/conversions/as_ref_mut.rs:86:16
   |
86 |         num_sq(&mut num);
   |         ------ ^^^^^^^^ no implementation for `Box<u32> * Box<u32>`
   |         |
   |         required by a bound introduced by this call
   |
   = help: the trait `Mul` is not implemented for `Box<u32>`
note: required by a bound in `num_sq`
  --> exercises/conversions/as_ref_mut.rs:47:14
   |
46 | fn num_sq<T>(arg: &mut T)
   |    ------ required by a bound in this
47 |     where T: std::ops::Mul<Output = T> + std::ops::MulAssign + Copy
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `num_sq`

error[E0277]: cannot multiply-assign `Box<u32>` by `Box<u32>`
  --> exercises/conversions/as_ref_mut.rs:86:16
   |
86 |         num_sq(&mut num);
   |         ------ ^^^^^^^^ no implementation for `Box<u32> *= Box<u32>`
   |         |
   |         required by a bound introduced by this call
   |
   = help: the trait `MulAssign` is not implemented for `Box<u32>`
note: required by a bound in `num_sq`
  --> exercises/conversions/as_ref_mut.rs:47:42
   |
46 | fn num_sq<T>(arg: &mut T)
   |    ------ required by a bound in this
47 |     where T: std::ops::Mul<Output = T> + std::ops::MulAssign + Copy
   |                                          ^^^^^^^^^^^^^^^^^^^ required by this bound in `num_sq`

error[E0277]: the trait bound `Box<u32>: Copy` is not satisfied
  --> exercises/conversions/as_ref_mut.rs:86:16
   |
86 |         num_sq(&mut num);
   |         ------ ^^^^^^^^ the trait `Copy` is not implemented for `Box<u32>`
   |         |
   |         required by a bound introduced by this call
   |
note: required by a bound in `num_sq`
  --> exercises/conversions/as_ref_mut.rs:47:64
   |
46 | fn num_sq<T>(arg: &mut T)
   |    ------ required by a bound in this
47 |     where T: std::ops::Mul<Output = T> + std::ops::MulAssign + Copy
   |                                                                ^^^^ required by this bound in `num_sq`

error: aborting due to 3 previous errors

```

因为 Box<T> 类型没有实现 std::ops::Mul 和 std::ops::MulAssign trait。你可以使用 Deref trait 来解引用 Box<T> 类型的值，然后再对值进行乘法运算和赋值操作。

建议修改后的代码:

```rust
fn num_sq<T>(arg: &mut T)
where
    T: std::ops::Deref<Target = u32> + std::ops::DerefMut,
{
    let square = **arg * **arg;
    **arg = square;
}
```

在这个版本的代码中，T 类型必须实现 std::ops::Deref 和 std::ops::DerefMut trait，这样就可以使用解引用操作符 * 来获取 Box<T> 类型内部的值，并进行乘法运算和赋值操作了。

值得注意的是，在这个版本的代码中，我们不需要显式地实现 Copy trait，因为 u32 类型已经实现了 Copy trait，而 T 类型需要实现 Deref<Target = u32> trait，所以也就具有了 Copy trait 的能力。

而以上提示是换了3种姿势, 才诱使 GPT 给出的,
之前绕的方向更加无解...


所以, 这也只能是一个特殊场景,
如果是自己实现的话, 一定要使用对应合理的内置类型, 不折腾.


## refer.
> 关键参考

[学习 Rust - Rust 程序设计语言](https://github.com/rust-lang/rustlings/)


## logging
> 版本记要

- ..
- 230330 ZQ init.



```
          _~--^~_
      \) /  ◴ ◵  \ ()
        '_   ▽   _'
        | '--#--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```

]]></content:encoded></item><item><title>rustlings.md</title><link>https://rs.101.so//101/rustlings</link><pubDate>Thu, 30 Mar 2023 11:52:07 +0800</pubDate><content:encoded><![CDATA[# rustlings

## background
必刷的官方原创

[rust-lang/rustlings: Small exercises to get you used to reading and writing Rust code!](https://github.com/rust-lang/rustlings)

## goal
> 必要目标

当前 94 个练习至少过一遍;

毕竟是官方大佬亲自设计的, 涵盖了所有关键概念和日常情景;
和其它练习不同的是:

- rustlings 基于调试, 而不是从头构建
- 这对进入一个已经有 rust 工程的团队来说, 更加重要
- 也就是说, 在已经有海量现存可参考代码的时代
    - 从0..1 的构建原创工程
    - 没有从 1..n 的快速组建应用, 来的普遍
    - 那么, 如何根据 rustc 的提示抓住当前代码主要问题所在并高速完成决策和解决
    - 才是更加重要的能力/素质...

## trace
> 具体推进

- 230228 clone 开始
- 230330 全部完成...

完成时:

![done](https://ipic.zoomquiet.top/2023-03-30-zshot%202023-03-30%2011.44.04.jpg)



## refer.
> 关键参考

[学习 Rust - Rust 程序设计语言](https://github.com/rust-lang/rustlings/)


## logging
> 版本记要

- ..
- 230330 ZQ init.



```
          _~∽+^~_
      \) /  ◷ ?  \ ()
        '_   ⎵   _'
        / '--∽--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```

]]></content:encoded></item><item><title>clear_explanation_rust_modele_system.md</title><link>https://rs.101.so//tip/clear_explanation_rust_modele_system</link><pubDate>Sat, 25 Mar 2023 21:27:05 +0800</pubDate><content:encoded><![CDATA[# 清晰解释Rust模块系统
> tips...重要也不重要

原文: [Clear explanation of Rust’s module system](https://www.sheshbabu.com/posts/rust-module-system/)

## 快译
Rust 的模块系统出奇的混乱,给初学者带来了很多挫败感;

在这篇文章中, 我将使用实际案例来解释模块系统,
以便清楚的了解其工作原理,
并可以立即开始在你的项目中应用起来;

由于 Rust 的模块系统非常独特,
我请求读者以开放的心态阅读这篇文章,
不要将其和其它语言的模块运作方式进行比较;

先使用这个文件结构来模拟一个真实世界的项目:


```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
    └── user_model.rs
```

以下这些是我们想使用自己不同模块的不同方式:

- 同级引用
- 引用下级
- 跨目录引用兄弟目录/模块

![rust-module-system-1](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-1.png)


这三个例子足以营利 Rust 的模块系统是如何工作的;


(`译按`: 其实, 这只是最基础的, 
这种目录结构是人工创建, 还是工具创建, 其实也是个问题,
毕竟, Rust 还支持内部库, 工作空间 ...等等代码管理姿势...)


------


### 示例 1

先从第一个姿势开始 --- `importing config.rs in main.rs`

```rust
// main.rs
fn main() {
  println!("main");
}

// config.rs
fn print_config() {
  println!("config");
}
```


第一个最常犯的错误就是因为我们有了 config.rs, health_route.rs 
等等文件,
就以为文件就是模块,我们可以从其它文件导入;

这是我们看到的(文件系统树)和编译器实际看到的(模块树):

![system-2](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-2.png)

令人惊讶的是,
编译器只看到 crate 模块,
这就是我们的 main.rs 文件;
这是因为,我们需要在 Rust 中显式构建模块树 --- 文件树到模块树之间没有隐式映射;

(译按: 和 Ruby 们包含大量多模内隐式猜想相反, Rust 只相信代码, 不主动猜想开发者的任何可能;)


> 我们需要在 Rust 中显式构建模块树, 这儿没有隐式映射到文件系统

要将文件追加到模块树, 我们需要使用 mod 关键字将该文件声明为子模块;
接下来让入门感到困惑的是, 你可能假设我们在同一文件中将一个文件声明为模块;
但是,我们需要在不同的文件中声明!
由于我们在模块树中只有 main.rs,
所以,让我们将 config.rd 声明为 main.rs 中的子模块;


> mod 关键字用来声明一个子模块


mod 关键字的语法如下:

`mod my_module;`


在此,编译器在同一目录中查找 my_module.rs 或是 my_module/mod.rs ;

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  └── my_module.rs
```

或是:

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  └─┬ my_module
    └── mod.rs
```

由于 main.rs 和 config.rs 在同一目录中,
我们可以如下声明 config 模块:

```rust
// main.rs
+ mod config;

fn main() {
+ config::print_config();
  println!("main");
}

// config.rs
fn print_config() {
  println!("config");
}
```

我们使用 :: 语法访问对应 print_config 函数;

这是当前模块树的样子:

![system-3](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-3.png)

我们已经成功声明了 config 模块!
但是,这不足以调用 config.rs 中的 print_config 函数;
默认情况中, Rust 中的几乎所有内容都是私有的,
我们需要使用 pub 关键字令其公开:

> pub 关键字令自己公开

```rust
// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}

// config.rs
- fn print_config() {
+ pub fn print_config() {
  println!("config");
}
```

现在已经生效;
我们已经成功调用了一个在不同文件中定义的函数!

------

### 示例 2

让我们尝试从 main.rs 中调用 routes/health_route.rs 中定义的 print_health_route 函数;

```rust
// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}

// routes/health_route.rs
fn print_health_route() {
  println!("health_route");
}

```

正如我们之前讨论的,
我们只能同同一目录中的 my_module.rs 或是 my_module/mod.rs 使用 mod 关键字;

因此, 为了从 main.rs 中调用 routes/health_route.rs 中的函数,
我们需要作到以下:

- 创建一个名为 routes/mod.rs 的文件,
- 并在 main.rs 中声明 子模块路由,
- 然后,在 routes/mod.rs 中声明 health_route 子模块并公开;
- 最后, 在 health_route.rs 中公开对应函数;

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
+ │ ├── mod.rs
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
    └── user_model.rs
```

对应代码:

```rust
// main.rs
mod config;
+ mod routes;

fn main() {
+ routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}

// routes/mod.rs
+ pub mod health_route;

// routes/health_route.rs
- fn print_health_route() {
+ pub fn print_health_route() {
  println!("health_route");
}
```
现在模块树应该如下:


![system-4](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-4.png)


我们现在可以调用一个目录中定义的函数了;


------


### 示例 3

现在尝试这个调用路径 `main.rs => routes/user_route.rs => models/user_model.rs`


```rust
// main.rs
mod config;
mod routes;

fn main() {
  routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}

// routes/user_route.rs
fn print_user_route() {
  println!("user_route");
}

// models/user_model.rs
fn print_user_model() {
  println!("user_model");
}
```

我们想从 main 中调用来者 print_user_route 的 print_user_model 函数;

我们先进行和之前类似的增补:
声明子模块, 公开了函数, 并追加 mod.rs ...


```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
  │ ├── mod.rs
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
+   ├── mod.rs
    └── user_model.rs
```

```rust
// main.rs
mod config;
mod routes;
+ mod models;

fn main() {
  routes::health_route::print_health_route();
+ routes::user_route::print_user_route();
  config::print_config();
  println!("main");
}

// routes/mod.rs
pub mod health_route;
+ pub mod user_route;

// routes/user_route.rs
- fn print_user_route() {
+ pub fn print_user_route() {
  println!("user_route");
}

// models/mod.rs
+ pub mod user_model;

// models/user_model.rs
- fn print_user_model() {
+ pub fn print_user_model() {
  println!("user_model");
}

```

现在模块树应该像变样:

![module-system-5.](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-5.png)


等等, 我们实际上并没有从 print_user_route 调用 print_user_model !
到目前为止, 我们只调用了 main.rs 中其它模块中定义的函数,
我们如何从其它文件中调用呢?

如果检阅当前模块树,
print_user_model 函数位于 crate::models::user_model 路径中;
因此,为了在不是 main.rs 的文件中使用模块,
我们应该考虑在模块树中触达该模块所需要的路径;

```rust
// routes/user_route.rs
pub fn print_user_route() {
+ crate::models::user_model::print_user_model();
  println!("user_route");
}

```

我们已经从一个不是 main.rs 的文件中成功的调用了一个文件中定义的函数;

(`译按:` 这是使用绝对路径形式, 另外还有相对路径形式...)


------


### super

如果我们的文件组织有很多目录深度,
则完全限定名将变得太长;
假设出于某种原因,
我们想从 print_user_route 调用 print_health_route;
分别位于 crate::routes::health_route 和 crate::routes::user_route 路径中;

我们可以使用完全限定名称
crate::routes::health_route::print_health_route() 来调用,
但是, 我们也可以使用查对路径 super::health_route::print_health_route();
注意, 我们使用 super 来引用父挖掘范围;


> 模块路径中的 super 关键字指的是父作用域

```rust
pub fn print_user_route() {
  crate::routes::health_route::print_health_route();
  // can also be called using
  super::health_route::print_health_route();

  println!("user_route");
}

```


------


### use

前述示例中智囊把完全限定名甚至相对名称都很乏味;
为了缩短名称,
我们可以使用 use 关键字将路径绑定到新名称或是别名;


> use 关键字用以缩短模块路径

```rust
pub fn print_user_route() {
  crate::models::user_model::print_user_model();
  println!("user_route");
}

```

上面的代码可以重构为:

```rust
use crate::models::user_model::print_user_model;

pub fn print_user_route() {
  print_user_model();
  println!("user_route");
}

```

除了使用原有名称 print_user_model,
我们也可以将其绑定为其它名称:


```rust
use crate::models::user_model::print_user_model as log_user_model;

pub fn print_user_route() {
  log_user_model();
  println!("user_route");
}

```


------

### 外部模块

更加时 Cargo.toml 的依赖项可以全局用于项目内所有模块;
我们不需要显式导入或是声明任何东西来启用;

> 外部依赖项对项目内所有模块全局可用


例如, 假设我们将 rand crate 追加到我们的项目中;
就可以直接在代码用使用:

```rust
pub fn print_health_route() {
  let random_number: u8 = rand::random();
  println!("{}", random_number);
  println!("health_route");
}

```
也可以使用 use 来缩短路径:


```rust
use rand::random;

pub fn print_health_route() {
  let random_number: u8 = random();
  println!("{}", random_number);
  println!("health_route");
}

```

------

### 小结

- 模块系统是显示的
    - 并没和文件系统 1:1 映射
- 我们在其父文件中又不能一个文件模块, 而不是在其自身中
- mod 关键字用以声明子模块
- 我们需要将函数/结构等等显式声明为公共的,以便可以在其它模块中引用
- pub 关键字令事务公开
- use 关键字用来缩短模块路径
- 我们不需要显式声明第3方模块


(译按: 没有提及新版本的子模块目录名同名文件约定, 这样不用形成太多 mod.rs 在不同目录中;
另外, 如何利用子 crate 或是子库, 以及 workspace 等等更多, 更加灵活, 
可以用来管理更大工程的模块约定, 也没有阐述...
这都值得继续探索...)


## refer.

[常见问题解答 · Rust 程序设计语言](https://prev.rust-lang.org/zh-CN/faq.html#modules-and-crates)

- [第九章 - 项目的结构和管理 - Rust 语言之旅 - Let's go on an adventure!](https://tourofrust.com/104_zh-cn.html)
- [使用包、Crate 和模块管理不断增长的项目 - Rust 程序设计语言 简体中文版](https://kaisery.github.io/trpl-zh-cn/ch07-01-packages-and-crates.html)
- [包和模块 - Rust语言圣经(Rust Course)](https://course.rs/basic/crate-module/intro.html)
- [文件分层 - 通过例子学 Rust 中文版](https://rustwiki.org/zh-CN/rust-by-example/mod/split.html)





```
         _~^*∽~_
     \/ /  # ◵  \ (/
       '_   ⩌   _'
       | '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>chat_for_or_itertools.md</title><link>https://rs.101.so//101/chat_for_or_itertools</link><pubDate>Fri, 24 Mar 2023 16:33:18 +0800</pubDate><content:encoded><![CDATA[# 用迭代简化嵌套循环
> 学伴ChatGPT, chatting for debugging ...

## background
> exercises 第81题?


[Rectangles in Rust on Exercism](https://exercism.org/tracks/rust/exercises/rectangles)

```
   +--+
  ++  |
+-++--+
|  |  |
+--+--+
```

要求完成代码, 可以从同类似上述 ASCII 字符串中数出6个矩形来

## goal

完成合理概念摸查...

## trace

好容易折腾出一个可以通过所有 test 的代码:

```rust

pub fn count(lines: &[&str]) -> u32 {
    let chars = lines
            .iter()
            .map(|l| l.as_bytes())
            .collect::<Vec<_>>();
    let width = lines
            .get(0)
            .map(|l| l.len())
            .unwrap_or_default();
    let height = lines.len();


    let mut count = 0;
    for top in 0..height
    {
        for left in 0..width
        {
            for bottom in top+1..height
            {
                for right in left+1..width
                {
                    if chars[top][left] == b'+'
                        && chars[top][right] == b'+'
                        && chars[bottom][left] == b'+'
                        && chars[bottom][right] == b'+'
                        && (top+1..bottom).all(|i| {
                            matches!(
                                (chars[i][left], chars[i][right]),
                                (b'|'| b'+', b'|'| b'+')
                            )})
                        && (left+1..right).all(|j| {
                            matches!(
                                (chars[top][j], chars[bottom][j]),
                                (b'-'| b'+', b'-'| b'+')
                            )})
                    {
                        count += 1;
                    }
                }
            }
        }
    }
    count 

}
```

一看就很JS, 圈复杂度不小, 应该 Rusty 一些,就开始尝试:

> Q:可以运行, 但是, 嵌套太多 for 循环了,如何改进?

> A: 这段 Rust 代码实现了一个计算 ASCII 图中矩形数量的函数。函数输入是一个字符串数组，每个字符串表示 ASCII 图的一行。函数通过检查每个可能的矩形来计算矩形数量。

原始代码中，函数使用了四层嵌套的循环来检查每个矩形。这种实现方式难以理解和维护，也可能不太高效。为了改进代码，可以使用 itertools 库中的 combinations 方法，将嵌套的循环转换为使用迭代器的方式进行迭代。

新的代码使用了迭代器和高阶函数，使得代码更加简洁和易于理解。首先，它使用 combinations 方法生成了所有行和列的索引的组合，然后使用 flat_map 将生成的嵌套迭代器展开为一个单一的元组迭代器。然后，使用 filter_map 过滤掉不是矩形的元组，最后使用 sum 方法统计矩形的数量。

这种实现方式相比原始代码减少了循环嵌套的层数，并且使用了更加高级的 Rust 特性，可以提高代码的可读性和性能。

```rust
use itertools::Itertools;

pub fn count(lines: &[&str]) -> u32 {
    let chars = lines
        .iter()
        .map(|l| l.as_bytes())
        .collect::<Vec<_>>();
    let width = lines.get(0).map(|l| l.len()).unwrap_or_default();
    let height = lines.len();

    (2..height)
        .combinations(2)
        .flat_map(|(top, bottom)| {
            (2..width)
                .combinations(2)
                .map(move |(left, right)| (top, bottom, left, right))
        })
        .filter_map(|(top, bottom, left, right)| {
            if chars[top][left] == b'+'
                && chars[top][right] == b'+'
                && chars[bottom][left] == b'+'
                && chars[bottom][right] == b'+'
                && (top + 1..bottom)
                    .all(|i| matches!((chars[i][left], chars[i][right]), (b'|' | b'+', b'|' | b'+')))
                && (left + 1..right)
                    .all(|j| matches!((chars[top][j], chars[bottom][j]), (b'-' | b'+', b'-' | b'+')))
            {
                Some(1)
            } else {
                None
            }
        })
        .sum()
}

```

> A: 报错: error[E0308]: mismatched types

```rust
  --> src/lib.rs:50:20
   |
50 |         .flat_map(|(top, bottom)| {
   |                    ^^^^^^^^^^^^-
   |                    |           |
   |                    |           expected due to this
   |                    expected struct `Vec`, found tuple
   |
   = note: expected struct `Vec<usize>`
               found tuple `(_, _)`

error[E0308]: mismatched types
  --> src/lib.rs:53:28
   |
53 |                 .map(move |(left, right)| (top, bottom, left, right))
   |                            ^^^^^^^^^^^^-
   |                            |           |
   |                            |           expected due to this
   |                            expected struct `Vec`, found tuple
   |
   = note: expected struct `Vec<usize>`
               found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rectangles` due to 2 previous errors
```

> A: 这个错误表明，你的代码在尝试使用一个包含元组的迭代器作为 flat_map 方法的输出，但是该方法期望的是一个包含整数的 Vec 结构体。类似的错误也出现在 map 方法的调用中。

这个错误可能是由于 flat_map 方法的输出类型和后续的调用期望的类型不匹配导致的。具体来说，由于 flat_map 方法返回的是一个元组的迭代器，而不是一个包含整数的 Vec，所以后续的调用无法使用该迭代器的元素。

要解决这个问题，你可以在 flat_map 和 map 方法中使用闭包来将元组转换为 Vec，或者在后续的调用中使用元组的解构方式来获取迭代器中的元素。例如，你可以修改 flat_map 和 map 方法的调用如下：

```rust
.flat_map(|(top, bottom)| {
    (0..width).combinations(2).map(move |c| (top, bottom, c[0], c[1])).collect::<Vec<_>>()
})
.filter_map(|(top, bottom, left, right)| {
    if chars[top][left] == b'+'
        && chars[top][right] == b'+'
        && chars[bottom][left] == b'+'
        && chars[bottom][right] == b'+'
        && (top+1..bottom).all(|i| {
            matches!(
                (chars[i][left], chars[i][right]),
                (b'|'| b'+', b'|'| b'+')
            )})
        && (left+1..right).all(|j| {
            matches!(
                (chars[top][j], chars[bottom][j]),
                (b'-'| b'+', b'-'| b'+')
            )})
    {
        Some(1)
    } else {
        None
    }
})
```

这些修改将确保 flat_map 和 map 方法返回的是一个包含整数的 Vec，这样就可以在后续的调用中使用了。

> A: 还是报错: error[E0308]: mismatched types

```rust
  --> src/lib.rs:50:20
   |
50 |         .flat_map(|(top, bottom)| {
   |                    ^^^^^^^^^^^^-
   |                    |           |
   |                    |           expected due to this
   |                    expected struct `Vec`, found tuple
   |
   = note: expected struct `Vec<usize>`
               found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rectangles` due to previous error

```

> A: 根据错误提示，似乎我们在flat_map操作中需要返回一个类型为Vec的对象，但我们返回的是一个元组。这个错误可能是由于我们尝试将元组（(usize, usize)）解构为两个参数而引起的。

我们可以尝试在flat_map中直接返回一个Vec，而不是一个元组。我们可以使用into_iter()方法将元组中的元素转换为迭代器，并使用collect()方法将它们收集到一个Vec中，如下所示：

```rust
let rects = (0..height - 1).into_iter()
        .flat_map(|top| {
            (top + 1..height).into_iter()
                .map(move |bottom| (top, bottom))
        })
        .flat_map(|(top, bottom)| {
            (0..width - 1).into_iter()
                .flat_map(move |left| {
                    (left + 1..width).into_iter()
                        .map(move |right| (top, bottom, left, right))
                })
        })
        .collect::<Vec<_>>();
```

这里，我们首先使用into_iter()将一个区间（0..height-1）转换为一个迭代器。然后，我们使用flat_map将每个元素（top）映射到一个迭代器，其中每个元素都是一个二元组，表示从当前top到最后一行的所有可能的矩形的底部行。我们将top传递给move闭包，以便在之后的操作中使用它。

接下来，我们使用into_iter()将一个区间（top+1..height）转换为另一个迭代器，并使用map将每个元素（bottom）映射到一个二元组，表示当前矩形的顶部行和底部行。我们使用move将top捕获到闭包中。

然后，我们使用into_iter()将一个区间（0..width-1）转换为另一个迭代器，并使用flat_map将每个元素（left）映射到一个迭代器，其中每个元素都是一个四元组，表示当前矩形的左上角和右下角的坐标。我们将top、bottom和left传递给move闭包，以便在之后的操作中使用它们。

最后，我们使用into_iter()将一个区间（left+1..width）转换为另一个迭代器，并使用map将每个元素（right）映射到一个四元组，表示当前矩形的左上角和右下角的坐标。我们将top、bottom、left和right传递给move闭包，以便在之后的操作中使用它们。

最后，我们使用collect()方法将所有四元组收集到一个Vec中。我们使用::<Vec<_>>来指定要收集

>> 接下来 ChatGPT 就开始轴了,死活绕不出修改一个不相关的地方,触发相同问题, 再次建议相同代码...

换了个模型, 重启对话获得不同回答:

> A: 该错误是因为代码尝试将一个由两个元素组成的元组映射成一个 Vec<usize>，这是不能直接转换的。

要解决这个问题，你需要使用 map 方法中的 unwrap 方法将元组解包，然后将两个元素放入 Vec 中。例如，你可以这样修改代码：

```rust
let pairs_of_rows = rows.windows(2);
let rectangles = pairs_of_rows.flat_map(|pair| {
    let (top, bottom) = pair.unwrap();  // 解构元组
    (0..columns).map(move |column| {
        (top[column], bottom[column])  // 返回一个元组
    })
}).filter(|&(top, bottom)| {
    top < bottom
}).map(|(top, bottom)| {
    vec![top, bottom]  // 在这里创建一个包含两个元素的 Vec
}).collect::<Vec<_>>();  // 将所有 Vec 组合成一个 Vec

```
这样就能避免类型不匹配的错误了。

> Q: 如果对应代码原先是这样的,应该如何修改? 

```rust
    (2..height)
        .combinations(2)
        .map(|(top, bottom)| vec![top, bottom])
```

> A: 原先的代码使用了 itertools::Itertools trait 中的 combinations 方法来选择两个不同的行，得到一个包含两个元素的元组 (top, bottom)，然后通过 map 将其转换为一个 Vec，其中 Vec 包含两个 usize 类型的元素 top 和 bottom。然而，combinations 方法返回的元组是不同于独立的元素的，所以不能直接将其转换为 Vec。

你可以通过使用 map 和 collect 方法来解决这个问题。具体来说，你可以在 map 中解构元组 (top, bottom)，并将它们插入新的 Vec 中，然后再将这些 Vec 收集到一个大的 Vec 中。例如：

```rust
let pairs_of_rows = (2..height)
    .combinations(2)
    .map(|pair| {
        let (top, bottom) = (pair[0], pair[1]); // 解构元组
        vec![top, bottom] // 返回一个包含两个元素的 Vec
    })
    .collect::<Vec<_>>(); // 将所有 Vec 组合成一个 Vec
```
这应该能帮助你将原来的代码转换为一个可以在 Rust 中正确运行的版本。


------
>> 终于打开了思路, 然后获得没有报错的代码:

```rust

    (2..height)
        .combinations(2)
        .map(|pair| {
            let (top, bottom) = (pair[0], pair[1]); // 解构元组
            vec![top, bottom].into_iter() // 返回一个包含两个元素的 Vec
        })
        .flat_map(|mut tb| {
            //let top = tb[0];
            //let bottom = tb[1];
            let top = tb.nth(0).unwrap();
            let bottom = tb.nth(0).unwrap();
            (0..width)
                .combinations(2)
                .map(move |c| (top, bottom, c[0], c[1]))
                .collect::<Vec<_>>()
                .into_iter()
        })
        .filter_map(|(top, bottom, left, right)| {
            if chars[top][left] == b'+'
                && chars[top][right] == b'+'
                && chars[bottom][left] == b'+'
                && chars[bottom][right] == b'+'
                && (top + 1..bottom).all(|i| {
                    matches!(
                        (chars[i][left], chars[i][right]),
                        (b'|' | b'+', b'|' | b'+')
                    )
                })
                && (left + 1..right).all(|j| {
                    matches!(
                        (chars[top][j], chars[bottom][j]),
                        (b'-' | b'+', b'-' | b'+')
                    )
                })
            {
                Some(1)
            } else {
                None
            }
        })
        .sum::<u32>()
```

可惜问题了,这个看起来非常 Rusty 的代码, 无法通过所有 test,
多数案例并没有清点明白所有矩形...

所以....代码复杂不怕, 就怕人看不明白, 难以调试...

## refer.
> 其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...

以及将自己伪装成一个认真又很笨的学员,
GPT 们就可以无限耐心的反复回答所有问题, 当然, 得配套自行检验以及官方文档证实:


- [itertools - Rust](https://docs.rs/itertools/0.10.5/itertools/#crate-features)
    - [Combinations in itertools::structs - Rust](https://docs.rs/itertools/0.10.5/itertools/structs/struct.Combinations.html)
- ...

所以, rust 是故意不折腾复杂的内建模块, 专注提高编译器能力,
其它的各种创新实用 crate 都给社区折腾了...?

```
     _~∽~-~_
 \/ /  - ◵  \ \/
   '_   V   _'
   / '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item></channel></rss>