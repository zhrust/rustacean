<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>be Rustaceans ~ 成锈纪</title><link>https://rs.101.so</link><description>~ 汇集 大妈/Zoom.Quiet 学习/实践/探索/... Rust 世界锈迹, 一起成为 Rustacean 吧...</description><generator>my_rss_generator</generator><item><title>chat_heap_stack.md</title><link>https://rs.101.so//101/chat_heap_stack</link><pubDate>Fri, 24 Mar 2023 11:28:53 +0800</pubDate><content:encoded><![CDATA[# 可变/不可变引用态度
> 学伴ChatGPT, chatting for debugging ...

## background
> 李明 coding到灯火阑珊 2023-03-24 06:00

[Rust开发人员经常犯的5个常见错误](https://mp.weixin.qq.com/s/KXfCHeFuLvK8PHAkA5QJmA)

## goal

完成合理概念摸查...

## trace

> Q: rust 代码:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        // 这一行将导致编译错误
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}

```

为什么出错?如何修改? 以及如何理解?

> A:该程序出错是因为 string2 的生命周期比 result 的生命周期短，而 result 是一个指向 string2 中的引用，因此在 string2 离开作用域后，result 指向的内存已经被释放，这会导致未定义的行为。

为了解决这个问题，我们需要让 result 的生命周期比 string2 的生命周期更长。有多种方法可以实现这一点，以下是其中的一种：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    let string2 = String::from("xyz");
    result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);
}
```
在这个修改后的程序中，我们将 string2 的声明移到了 result 的声明之前，并且不再使用一个代码块来限制 string2 的作用域。这意味着 string2 和 result 的生命周期相同，因此 result 仍然有效。

该程序的代码使用了 Rust 的生命周期注释 'a 来告诉编译器 longest 函数的返回值的生命周期应该与 x 和 y 的生命周期相同。

简单地说，程序中的修改让 string2 和 result 具有相同的生命周期，从而解决了问题。

> Q: let string2 = "xyz"; 是否也可以解决相同的问题? 为什么?

> A:是的，如果将 string2 的类型从 String 改为字符串字面量 &str，则程序就可以正确编译和运行。修改后的程序如下：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

字符串字面量在编译时就已经存在于程序的二进制文件中，因此它们的生命周期与程序的生命周期相同，而不需要在堆上分配内存。这意味着它们的生命周期与其他在程序中定义的变量的生命周期相同，因此在使用字符串字面量时不需要担心生命周期的问题。

所以使用字符串字面量作为参数传递给 longest 函数是安全的，因为它们的生命周期已经在编译时确定了，并且与函数中的其他变量的生命周期相同。

> Q: 那么, 为什么 longest() 一定要指定参数的生命周期? 没有其它更加简洁的形式了嘛?

> A: 在 Rust 中，str 是一个字符串 slice 类型，它是一个不可变的、固定长度的引用类型。由于 str 引用的是存储在堆上的字符串数据，因此它的生命周期必须是由该字符串的所有权来决定的。

在 longest() 函数中，x 和 y 的类型是 &'a str，这表示它们是指向某个字符串数据的引用，它们的生命周期被限制为 'a，即函数的生命周期。这是必要的，因为函数的返回值也是一个对字符串数据的引用，它的生命周期必须是在函数返回后才能开始的，而且必须与参数的生命周期相关联，以避免悬垂引用的问题。

如果我们将参数类型改为 str，那么就无法控制它们引用的字符串的生命周期，因为它们不是引用类型。如果我们试图通过将 string1 和 string2 的值进行 clone 来传递它们的副本，这样可能会导致堆分配的额外开销和性能问题，因为这需要为每个字符串分配一个新的内存块，并在函数调用结束后释放这些内存块。

因此，在 longest() 函数中，最好使用字符串 slice 类型 &str，并在调用函数时传递指向原始字符串的引用，以确保在不需要分配额外内存的情况下正确处理字符串。

> Q: 明白了, 如果不考虑性能, 使用 clone 也是可以的

> A: 是的，如果不考虑性能问题，你可以通过使用 clone() 方法来创建传递给 longest() 函数的字符串的拷贝。这将使每个字符串都在堆上分配新的内存，并使 longest() 函数能够接受 String 类型的参数。

例如，可以使用下面的代码来调用 longest() 函数，使用 clone() 方法创建了 string1 和 string2 的副本：

```rust

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);

    // Create clones of the strings and pass them to longest()
    let string3 = string1.clone();
    let string4 = string2.clone();
    let result2 = longest(string3.as_str(), string4.as_str());
    println!("The longest string is {}", result2);
}

```
注意，这种方法可能会产生性能问题，因为每次调用 clone() 方法都会分配新的内存并复制字符串的内容。因此，如果性能是一个问题，最好避免使用 clone() 方法来创建字符串的副本。


> Q: 明白了, 那么 堆与栈的本质区别是什么? 为什么 rust 对栈这么信任, 对堆却很警惕?

> A: 在计算机科学中，堆和栈都是内存中用于存储程序数据的数据结构。它们之间的本质区别在于它们的内存分配方式和数据存储的生命周期。

栈是一种先进后出的数据结构，它使用固定大小的内存块来存储程序数据。当一个函数被调用时，该函数的参数、局部变量和返回地址等数据将被存储在栈帧中。当函数返回时，该栈帧将被弹出，其中存储的数据也将被销毁。由于栈内存的分配和释放是由程序自动进行的，因此它们的效率非常高。

堆是一种动态的数据结构，它使用不连续的内存块来存储程序数据。堆内存的分配和释放是由程序员手动管理的，它们的效率相对较低。由于堆内存的生命周期不像栈那样易于确定，因此在使用堆内存时需要注意内存泄漏和悬垂指针等问题。

在 Rust 中，栈上的数据是可以直接在栈帧中进行分配和释放的，因此 Rust 对栈的管理非常信任。但是，由于堆上的数据需要手动管理，因此在 Rust 中对堆的管理要更加警惕，以避免内存泄漏和悬垂指针等问题。因此，在 Rust 中使用堆内存时，必须遵循所有权规则，以确保每个值都有且只有一个所有者，并在所有者超出作用域时自动释放其内存。这也是 Rust 中所有权系统的核心概念。


> Q: 那么, rust 内建数据类型中, 哪些是栈, 哪些是堆?

> A: 在 Rust 中，内建数据类型可以分为两类：栈上分配的值和堆上分配的值。

以下是一些常见的栈上分配的值：

- 所有基本数据类型（例如整数、布尔值和浮点数）
- 数组和元组（当它们包含栈上分配的值时）
- 函数和闭包

以下是一些常见的堆上分配的值：

- 所有标准库集合类型，例如 Vec、String 和 HashMap 等
- Box 智能指针和 Rc 引用计数指针
- 闭包（如果它们捕获了堆上分配的值）


需要注意的是，Rust 中的**所有类型都可以在堆上分配，只要使用堆分配器**（如 Box、Vec 或者 String）即可。但是，所有权系统确保这些堆上分配的值仍然遵循所有权规则，以确保内存安全。


> Q: 明白了, 也就是说 String::from("xyz") 是堆上内存, 但是, "xyz" 是栈上内存,
那么, 为什么都是生成不可变字符串, 为什么 Rust 要构建出堆上字符串 String::from("xyz") ?
问题是 String::from("xyz")  有什么比 "xyz" 的好处?


> A: 是的，您的理解是正确的。"xyz" 是一个编译时常量，分配在程序的栈上，它是一个静态分配的不可变字符串。而 String::from("xyz") 是在运行时动态分配的堆上的一个不可变字符串。

Rust 之所以提供 String 类型，是因为它具有以下一些优点：

- 动态长度：在堆上分配一个字符串，它的长度可以在运行时根据需要动态增加或减少，这是栈上分配的静态字符串所不能做到的。
- 丰富的字符串处理功能：String 类型提供了各种字符串处理功能，例如拼接、切割、查找、替换等。
- UTF-8 编码：Rust 中的字符串类型都是基于 UTF-8 编码的，这意味着它们可以表示世界上几乎所有语言中的字符，包括非拉丁字符集，而不会出现编码问题。


但是，由于动态分配内存涉及到堆的使用，这会带来一些额外的开销和复杂性。因此，在编写 Rust 代码时，应该尽可能地使用栈上分配的数据类型来避免堆分配的开销。仅当需要动态长度或其他特殊功能时，才应该使用堆上分配的类型。


## refer.
> 其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...

以及将自己伪装成一个认真又很笨的学员,
GPT 们就可以无限耐心的反复回答所有问题, 当然, 得配套自行检验以及官方文档证实:


- [什么是所有权？ - Rust 程序设计语言 简体中文版](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap)
- [生命周期基础 - Rust By Practice( Rust 练习实践 )](https://zh.practice.rs/lifetime/basic.html)
- [字符串：str和String - Rust入门秘籍](https://rust-book.junmajinlong.com/ch3/04_str_string.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F)
- [理解Rust内存管理 - Rust入门秘籍](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - [堆空间和栈空间 - Rust入门秘籍](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - ...
- [使用Box<T> 指向堆上数据 - Rust 程序设计语言 简体中文版](https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE)


```
     _~`|~~_
 \/ /  = →  \ ()
   '_   ∧   _'
   / '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>clear_explanation_rust_modele_system.md</title><link>https://rs.101.so//tip/clear_explanation_rust_modele_system</link><pubDate>Wed, 22 Mar 2023 00:51:38 +0800</pubDate><content:encoded><![CDATA[# 清晰解释Rust模块系统
> tips...重要也不重要

原文: [Clear explanation of Rust’s module system](https://www.sheshbabu.com/posts/rust-module-system/)

## 快译



Rust’s module system is surprisingly confusing and causes a lot of frustration for beginners.

In this post, I’ll explain the module system using practical examples so you get a clear understanding of how it works and can immediately start applying this in your projects.

Since Rust’s module system is quite unique, I request the reader to read this post with an open mind and resist comparing it with how modules work in other languages.

Let’s use this file structure to simulate a real world project:

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
    └── user_model.rs
```

These are the different ways we should be able to consume our modules:

![rust-module-system-1](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-1.png)


These 3 examples should be sufficient to explain how Rust’s module system works.

------


### Example 1
Let’s start with the first example - importing config.rs in main.rs.

// main.rs
fn main() {
  println!("main");
}
// config.rs
fn print_config() {
  println!("config");
}
The first mistake that everyone makes is just because we have files like config.rs, health_route.rs etc, we think that these files are modules and we can import them from other files.

Here’s what we see (file system tree) and what the compiler sees (module tree):



Surprisingly, the compiler only sees the crate module which is our main.rs file. This is because we need to explicitly build the module tree in Rust - there’s no implicit mapping between file system tree to module tree.

We need to explicitly build the module tree in Rust, there’s no implicit mapping to file system

To add a file to the module tree, we need to declare that file as a submodule using the mod keyword. The next thing that confuses people is that you would assume we declare a file as module in the same file. But we need to declare this in a different file! Since we only have main.rs in the module tree, let’s declare config.rs as a submodule in main.rs.

The mod keyword declares a submodule

The mod keyword has this syntax:

mod my_module;
Here, the compiler looks for my_module.rs or my_module/mod.rs in the same directory.

my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  └── my_module.rs

or

my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  └─┬ my_module
    └── mod.rs
Since main.rs and config.rs are in the same directory, let’s declare the config module as follows:

// main.rs
+ mod config;

fn main() {
+ config::print_config();
  println!("main");
}
// config.rs
fn print_config() {
  println!("config");
}
We’re accessing the print_config function using the :: syntax.

Here’s how the module tree looks like:



We’ve successfully declared the config module! But this is not sufficient to be able to call the print_config function inside config.rs. Almost everything in Rust is private by default, we need to make the function public using the pub keyword:

The pub keyword makes things public

// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// config.rs
- fn print_config() {
+ pub fn print_config() {
  println!("config");
}
Now, this works. We’ve successfully called a function defined in a different file!

------


### Example 2
Let’s try calling the print_health_route function defined in routes/health_route.rs from main.rs.

// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// routes/health_route.rs
fn print_health_route() {
  println!("health_route");
}
As we discussed earlier, we can use the mod keyword only for my_module.rs or my_module/mod.rs in the same directory.

So in order to call functions inside routes/health_route.rs from main.rs, we need to do the following things:

Create a file named routes/mod.rs and declare the routes submodule in main.rs
Declare the health_route submodule in routes/mod.rs and make it public
Make the functions inside health_route.rs public
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
+ │ ├── mod.rs
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
    └── user_model.rs
// main.rs
mod config;
+ mod routes;

fn main() {
+ routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/mod.rs
+ pub mod health_route;
// routes/health_route.rs
- fn print_health_route() {
+ pub fn print_health_route() {
  println!("health_route");
}
Here’s how the module tree looks like:



We can now call a function defined in a file inside a folder.

------


### Example 3
Let’s try calling from main.rs => routes/user_route.rs => models/user_model.rs

// main.rs
mod config;
mod routes;

fn main() {
  routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/user_route.rs
fn print_user_route() {
  println!("user_route");
}
// models/user_model.rs
fn print_user_model() {
  println!("user_model");
}
We want to call the function print_user_model from print_user_route from main.

Let’s make the same changes as before - declaring submodules, making functions public and adding the mod.rs file.

my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
  │ ├── mod.rs
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
+   ├── mod.rs
    └── user_model.rs
// main.rs
mod config;
mod routes;
+ mod models;

fn main() {
  routes::health_route::print_health_route();
+ routes::user_route::print_user_route();
  config::print_config();
  println!("main");
}
// routes/mod.rs
pub mod health_route;
+ pub mod user_route;
// routes/user_route.rs
- fn print_user_route() {
+ pub fn print_user_route() {
  println!("user_route");
}
// models/mod.rs
+ pub mod user_model;
// models/user_model.rs
- fn print_user_model() {
+ pub fn print_user_model() {
  println!("user_model");
}
Here’s how the module tree looks like:



Wait, we haven’t actually called print_user_model from print_user_route! So far, we’ve only called the functions defined in other modules from main.rs, how do we do that from other files?

If we look at our module tree, the print_user_model function sits in the crate::models::user_model path. So in order to use a module in files that are not main.rs, we should think in terms of the path necessary to reach that module in the module tree.

// routes/user_route.rs
pub fn print_user_route() {
+ crate::models::user_model::print_user_model();
  println!("user_route");
}
We’ve successfully called a function defined in a file from a file that’s not main.rs.

------


### super
The fully qualified name gets too lengthy if our file organization is multiple directories deep. Let’s say for whatever reason, we want to call print_health_route from print_user_route. These are under the paths crate::routes::health_route and crate::routes::user_route respectively.

We can call it by using the fully qualified name crate::routes::health_route::print_health_route() but we can also use a relative path super::health_route::print_health_route();. Notice that we’ve used super to refer to the parent scope.

The super keyword in module path refers to the parent scope

pub fn print_user_route() {
  crate::routes::health_route::print_health_route();
  // can also be called using
  super::health_route::print_health_route();

  println!("user_route");
}

------


### use
It would be tedious to use the fully qualified name or even the relative name in the above examples. In order to shorten the names, we can use the use keyword to bind the path to a new name or alias.

The use keyword is used to shorten the module path

pub fn print_user_route() {
  crate::models::user_model::print_user_model();
  println!("user_route");
}
The above code can be refactored as:

use crate::models::user_model::print_user_model;

pub fn print_user_route() {
  print_user_model();
  println!("user_route");
}
Instead of using the name print_user_model, we can also alias it to something else:

use crate::models::user_model::print_user_model as log_user_model;

pub fn print_user_route() {
  log_user_model();
  println!("user_route");
}

------

### External modules
Dependencies added to Cargo.toml are available globally to all modules inside the project. We don’t need to explicitly import or declare anything to use a dependency.

External dependencies are globally available to all modules inside a project

For example, let’s say we added the rand crate to our project. We can use it in our code directly as:

pub fn print_health_route() {
  let random_number: u8 = rand::random();
  println!("{}", random_number);
  println!("health_route");
}
We can also use use to shorten the path:

use rand::random;

pub fn print_health_route() {
  let random_number: u8 = random();
  println!("{}", random_number);
  println!("health_route");
}

------

### Summary
The module system is explicit - there’s no 1:1 mapping with file system
We declare a file as module in its parent, not in itself
The mod keyword is used to declare submodules
We need to explicitly declare functions, structs etc as public so they can be consumed in other modules
The pub keyword makes things public
The use keyword is used to shorten the module path
We don’t need to explicitly declare 3rd party modules
Thanks for reading! Feel free to follow me in Twitter for more posts like this :)





```
         _~^*∽~_
     \/ /  # ◵  \ (/
       '_   ⩌   _'
       | '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>past_ampersand-driven_development.md</title><link>https://rs.101.so//101/past_ampersand-driven_development</link><pubDate>Wed, 22 Mar 2023 00:47:58 +0800</pubDate><content:encoded><![CDATA[# 克服 "& 驱动开发"
原文: [Getting Past “Ampersand-Driven Development” in Rust - Blog](https://fiberplane.com/blog/getting-past-ampersand-driven-development-in-rust)

## background

[RR23W10 - 锈周刊 -> Weekly :: China<Rustaceans>](https://weekly.rs.101.so/abt/index.html) 中发现好文,
译来细读....

## 快译
> A little mental model for ownership and borrowing

所有权和借用的小小心智模型.

我是在一次 [Tad Lispy](https://www.youtube.com/watch?v=lsnksAMpUvM)
的演讲中听到 "& 符号驱动开发"这词儿的,
非常精确的捕捉到了很多 Rust 新人开发时,
下意识的随机插入 & 符号来安抚编译的行为.

此文, 描述了我想向 Rust 新手解释的一个心智模型，
涉及 &,&mut,所有权, Rcs 和 Arcs 之间的区别;
我希望你或是其它有抱负的 Rustacean 们对此感觉有用.

### 引用 (&variable)

让我们从 & 符号开始,
真是个可怕的符号;
在 Rust 中随处可见 --- 如果你首次尝试编写一些 Rust 代码,
可能不到 10 分钟,
Rust 编译器就会烦人的或是有用的告诉你,
在哪儿需要放置一个 &;

想象一下,我们有个计算字符串长度的简单函数;
此函数需要查阅字符串;
但是, 需要所有权进行修改嘛?不;
当长度函数完成时,我们应该从内存中删除字符串嘛? 也不需要;
这意味着长度函数嘦读取访问权,
只是要字符串的临时视图而不是永久版本;

这就是 &变量 符号在 Rust 中的含义;
想想一个小孩子将最喜欢的玩具借给另外一个孩子时说:
"你可以看, 但是, 不能摸; 当你看完后, 我想立即拿回来;"
这就是共享引用;

![Midjourney](https://framerusercontent.com/images/5LwiCYhw088dpelWzFCkp9MWSo.png)


> 图片由 Evan Schwartz 使用 Midjourney 创作


### 可变引 (&mut variable)

那么 &mut 变量又是怎么回事儿?

让我们想象一下在给定字符串前追加 "hello" 的函数,
而不是我们的字符串长度函数;
在这种情况中,
我们硬骨头希望函数修改给进来的数据;
这时,我们就需要 &mut 或说 可变引用;

想想我们的小孩子借一本涂色书给朋友,
让他在一页上色,说:"你可以看以及摸---但是,
当你完成后, 我仍然想要回来";


![Evan Schwartz](https://framerusercontent.com/images/0Y2RBZro7ESbqJzViLGIqfvccY.png)

> 图片由 Evan Schwartz 使用 Midjourney 创作


#### 可变引用是独占的

这里解释关于 Rust 微妙又非常聪明的设计最好的场景之一;

如果某人(或是你的代码的某部分)有一个对某个值的可变袭用,
Rust 编译器会确保绝对没有其它人可以再次引用;
为什么?
因为, 如果你正在查看某个你认为不可变的值,
当然不会在你使用其过程中又和维其它人意外的变更这个对象
(对于我们上面提及的字符串长度函数,
你就知道如果允许, 那得多令人困惑?)

另外一层含义是,
如果任何人对一个值有一个不可变袭用,
我们就不能更改它, 又或是给出另外一个可变引用;


### 值的拥有 (variable)

接下来,我们将讨论 值的拥有;

Rust 的另外一个聪明之处,
在于如何确定何时应该忘记或是从内存中删除一个值;
每当函数完成后, 其中声明的所有值都将被删除或是自动清除;

好吧, 这并不是真的;
如果我们再次考虑字符串长度函数,
就知道, 我们并不希望字符串在长度函数完成时就被完全遗忘/删除;
和追加 hello 函数相同;
在这些情况中, 只会清除对该值的引用,
但是,不会删除实际值;

那么, 将我们向 HashMap 中插入一些东西时又如何?
在这种场景中,
我们希望给定的字符串输入成为 HashMap 的一部分;
希望该值现在由 HashMap 拥有;

想象一个小孩赠送他们的玩具之一时说:
"给, 你可以拿来作任何你想作的事儿,我不需要拿回来了,
享受吧!"
(即便是想象中的孩子, 也需要相当成熟成千可能令此场景可信哪...)


### 引用计数指针 (Rc 和 Arc)

我们在 Rust 中还有另外两种值类型是 Rc 和 Arc;

对于 Rc, 想象孩子生日派对上的装饰品,
例如气球;
当所有人都取信在那里时,
我们希望每个人都看着, 但是不要触摸装饰品;
我们希望装饰品一直保持到最后一个孩子离开时;
但是, 嘦最后一个熊孩子离开,
我们就可以立即开始清理装饰品;
这就是一个 Rc 或是引用计数指针;

Rc 跟踪有多少人(或是代码的一部分)
正在查看, 并保持该值, 直到最后一个引用被删除的那一刻;

如果你正在使用异步或是多线程代码,
你将使用 Arc 或是原子引用计数指针,
但是, 和 Rc 的想法相同;

效果也是: 大家看看装饰品,
晚会一结束我们就收拾干净;

### 结论
作为最后的总结,
你可以根据以下问题, 来决策应该使用那种类型的值:

![Conclusion](https://framerusercontent.com/images/mH73ms5JxUOiNWhWMA8UKtAX7Y.jpg)


------


|                 | &var(不可变引) | &mut var(可变引用) | var(拥有值)                              | Rc(引用计数指针)         | Arc(原子引用计数指针) |
|-----------------|------------------|----------------------|--------------------------------------------|----------------------------|-------------------------|
| 可读?           | ✔︎               | ✔︎                   | ✔︎                                         | ✔︎                         | ✔︎                      |
| 可写?           | ✘                | ✔︎                   | ✔︎                                         | 仅当包装为 Cell/RefCell    | 仅当包装为 Mutex/RwLock |
| 函数结束时丢弃? | ✘                | ✘                    | ✔︎                                         | 仅在 Rc 最后的克隆被丢弃后 | 仅当 Arc 的克隆被丢弃后 |
| 多线程可用?     | ✘ 注1            | ✘                    | 值可以在线程间移动,但不同线程不可同时访问 | ✘                          | ✔︎                      |



------


> 注1: (除非有一个 'static 生命周期, 这意味着在所有线程中存在,或是在线程作用域中使用)


在从 Typescript 等高级语言转到 Rust 时,
& 符号是最可怕或是最不熟悉的部分之一;
但是, 能保证的是, 经过一些练习, 在编写代码时,
知道一个函数应该采用可变引用还是不可变引用,
又或是知道其它库的函数是否可能需要引用或是拥有值,
感觉会更加直观;
也就无需 `"& 驱动开发"` 了;

有关详情, 值得查阅 Rust 语言文档:
[References and Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)
以及:
 [What is Ownership?](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
 
还有 [Evan Schwartz](https://github.com/emschwartz)
是 Fiberplane 的首席 Rust 工程师;
也是 [Autometrics](https://github.com/autometrics-dev/autometrics-rs)
的创造者,
一个全新的 crate, 
可以让你轻松了解代码中任何函数的错误率/延迟和生产使用情况.

## refer.

... TBD



```
          _~`+∽~_
      \/ /  = ◶  \ (/
        '_   𝟂   _'
        | '-----' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```
]]></content:encoded></item><item><title>two_kinds_assert_make_better_code.md</title><link>https://rs.101.so//tip/two_kinds_assert_make_better_code</link><pubDate>Mon, 20 Mar 2023 15:46:43 +0800</pubDate><content:encoded><![CDATA[# 两种'Assert'构建清晰代码
> tips...重要也不重要

原文: [Laurence Tratt: Rust's Two Kinds of 'Assert' Make for Better Code](https://tratt.net/laurie/blog/2023/rusts_two_kinds_of_assert_make_for_better_code.html)


## 快译



Daniel Lemire's recent post "runtime asserts are not free" looks at the run-time cost of assert statements in C and shows that a simple assert in a frequently executed loop can cause significant overhead.
My own opinion on assertions has shifted over the years, from "I don't see the point" to "use them sparingly" to "use them as much as possible". That last shift is largely due to Rust having two kinds of "assert" statement – assert and debug_assert – which has allowed me to accurately express two different kinds of assertions, largely freeing me from performance worries. If you come from a language that only has one kind of assert statement, this distinction can seem pointless, so in this post I want to briefly explain why it helped shift my thinking.

Background
Let me quickly define what I mean by an "assert": it's a programming language statement that checks a property and causes a crash if that property does not hold (conventionally called a "failing assert"). For example, if I have a Python program with a list of people's ages and calculate the minimum age, I might want to check that the youngest person doesn't have a negative age:

ages = [...]
youngest = min(ages)
assert(youngest >= 0)
If ages contains a negative value – or if min doesn't work correctly! – the assert will fail and cause a run-time exception:
Traceback (most recent call last):
  File "/tmp/t.py", line 3, in 
    assert(youngest >= 0)
AssertionError
In other words, writing assert is roughly equivalent to:
ages = [...]
youngest = min(ages)
if not (youngest >= 0):
  raise AssertionError
In practise, asserts are mostly used to check assumptions about a program's state — in this case, that at no point has a negative age entered into the system.
There are two major reasons why I might want to check this particular assumption. First, I might have written subsequent code which will only execute correctly with non-negative youngest values: I want to prevent that subsequent code from executing if that property is violated. Second, the assert both documents and checks the property. In other words, I could just have written a comment:

ages = [...]
youngest = min(ages)
# youngest must be non-negative or bad things will happen below
...
That comment accurately describes the program's assumption, but if the assumption is incorrect – perhaps because another part of the program uses -1 to mean "we don't know how old this person is" – the threatened "bad things" will occur. If I'm lucky, the effects will be relatively benign, and perhaps even invisible. But, if I'm unlucky, genuinely bad things will occur, ranging from odd output to security vulnerabilities.
Debugging incorrect assumptions of this sort is hard, because the effect of the assumption's violation is generally only noticed long after the violation occurred. It's not unusual for some poor programmer to spend a day or more hunting down a problem only to find that it was caused by the violation of a simple assumption. In contrast, the assert causes my program to crash predictably, with a clear report, and at the earliest possible opportunity. In general, fixing the causes of failing asserts tends to be relatively simple.

Why asserts are used less often than one might think
As I've described them above, asserts sound like a clear win — but most programs use many fewer asserts than one might hope.
The most obvious reason for this is that programmers often don't realise the assumptions they're embedding in their programs, or don't consider the consequences of their assumptions. This tends to be particularly true for junior programmers, who have not yet built up scar tissue from multi-day debugging sessions that were necessary only because they didn't think to use asserts. It took me many years of programming before I realised how much time I was wasting by not thinking about, and checking with asserts, my assumptions about a program's properties.

Sometimes it's also very difficult to work out how to assert the property one cares about. This is particularly true in languages like C where there is no built-in help to express properties such as "no element in the list can be negative". The lengthier, and more difficult, an assert needs to be – particularly if it needs a helper function – the less likely it is to be written down.

Inevitably, some asserts are plain wrong, either expressing an incorrect property, or expressing correct property incorrectly. I think most of us expect such mistakes. However, what many people don't realise is that asserts can change a program's behaviour if they have side effects. I have shot myself in the foot more than once by copying and pasting code such as l[i++] into an assert, causing the program to execute differently depending on whether the assert is compiled in or not. I view this as inevitable stupidity on my part, rather than a flaw in the concept of asserts, but I have heard of at least one organisation that bans (or, at least, banned) asserts because of this issue.

Performance issues
Daniel pointed out a very different reason for avoiding asserts: they can cause serious performance issues when used in the "wrong" places. An assert introduces a branch (i.e. an "if") which must be executed at run-time [1]. The existence of an assert can also cause a compiler to miss compile-time optimisation opportunities [2]. There is a general fear in the programming community about the performance costs of asserts, even though none of us can know how they impact a given program without actually measuring it.
To avoid performance issues, most software is compiled in either "debug" (sometimes called "testing") or "release" modes: in debug mode, asserts are compiled in and checked at run-time; but in release mode, the asserts are not compiled in, and thus not checked at run-time. In languages like C, there isn't a standard concept of "debug" and "release" modes, but many people consider "release" mode to imply adding a flag -DNDEBUG, which causes assert to become a no-op. Rust's standard Cargo build system defaults to debug mode, with --release performing a release build.

Two kinds of asserts
While not compiling (and thus not checking) asserts in release mode removes performance problems, it also weakens the guarantees we have about a program's correctness — just because a test suite doesn't violate an assumption doesn't mean that real users won't use the program in a way which does.
These days I thus view asserts as falling into two categories:

Checking problem domain assumptions.
Checking internal assumptions.
That distinction might seem artificial, perhaps even non-existent, so let me give examples of what I mean.
The first category contains assumptions about the "real world" problem my program is trying to help solve. For example, if I'm writing a warehouse stock system, parts of my program might assume properties such as "an item's barcode is never empty".

The second category contains assumptions about the way I've structured my program. For example, I might have written a function which runs much faster if I assume the input integer is greater than 1. It's probable that, at the time I write that function, I won't call it in a way that violates that property: but later programmers (including me!) will quite possibly forget, or not notice, that property. An assertion is thus particularly helpful for future programmers, especially when they're refactoring code, to give them greater confidence that they haven't broken the program in subtle ways.

What it took me years to realise is that I have very different confidence levels about my assumptions in each category. I have high confidence that violations of my assumptions in the second category will be caught during normal testing. However, I have much lower confidence that violations of my assumptions in the first category will be caught during testing.

My differing confidence levels shouldn't be surprising — after all, I've been hired because I can program, not because I know much about warehouse stock systems or barcodes! However, since "normal testing" implies "debug mode" and "user is running the program" implies "release mode", it means that the assumptions I am least confident are not exercised when they're most needed.

Two kinds of assert statement
The problem that I've just expressed ultimately occurs because languages like C force us to encode both kinds of assumption with a single assert statement: either all asserts are compiled in or none are.
I long considered this inevitable, but when I moved to Rust several years back, I slowly realised that I now had access to two kinds of assert statement. debug_assert is rather like assert in C, in the sense that the assumptions it expresses are only checked in debug mode. In contrast, assert is "always checked in both debug and release builds, and cannot be disabled."

This might seem like a small difference, but for me it completely unlocked the power of assertions. If you look at a lot of the code I now write, you'll see liberal use of debug_assert, often checking quite minor assumptions, including those I never think likely to be violated. I never even think, let alone worry, about the performance impact of debug_assert. But occasionally you'll spot an assert, sometimes even in fairly frequently executed code — those are where I'm checking particularly important assumptions, or assumptions in which I have particularly low confidence. Each time I write assert I think about the possible performance impact, and also about whether there's a way I can increase my confidence in the assumption to the point that I can downgrade it to a debug_assert. Similarly, when it comes to debugging, I often check assert statements quite carefully as they indicate my low confidence in a particular assumption: it's more likely that I have to reconsider an assert than a debug_assert.

Of course, there's no reason why you can't write your own equivalents of assert and debug_assert in C, or any other language, but having them built into a language (or standard library), where their differing motivations are clearly documented and widely understood, makes it much easier to use them freely. I hope languages other than Rust will continue to make this difference in assertions — though I would prefer a shorter name than "debug_assert"!






```
          _~`|`~_
      \) /  ← ◷  \ \/
        '_   V   _'
        \ '--∽--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item></channel></rss>