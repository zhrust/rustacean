<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>be Rustaceans ~ æˆé”ˆçºª</title><link>https://rs.101.so</link><description>~ æ±‡é›† å¤§å¦ˆ/Zoom.Quiet å­¦ä¹ /å®è·µ/æ¢ç´¢/... Rust ä¸–ç•Œé”ˆè¿¹, ä¸€èµ·æˆä¸º Rustacean å§...</description><generator>my_rss_generator</generator><item><title>chat_arc_threads.md</title><link>https://rs.101.so//101/chat_arc_threads</link><pubDate>Fri, 24 Mar 2023 14:46:44 +0800</pubDate><content:encoded><![CDATA[# ä½¿ç”¨Arc åœ¨å¤šçº¿ç¨‹ä¸­å…±äº«æ•°æ®
> å­¦ä¼´ChatGPT, chatting for debugging ...

## background
> rustlings ç¬¬78é¢˜:

smart_pointers/arc1.rs

```rust
#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}

```

## goal

å®Œæˆåˆç†æ¦‚å¿µæ‘¸æŸ¥...

## trace

> Q: ä»¥ä¸Šä»£ç å¦‚ä½•è¡¥å…¨?

> A: è¿™æ®µ Rust ä»£ç ä¸­éœ€è¦è¡¥å…¨çš„æ˜¯ shared_numbers å’Œ child_numbers å˜é‡çš„å®šä¹‰ï¼Œä½¿å¾—ä»£ç å¯ä»¥æ­£ç¡®åœ°è®¡ç®—æ¯ä¸ªåç§»é‡ä¸‹çš„æ•°å­—å’Œã€‚å¯ä»¥é€šè¿‡ä½¿ç”¨ Arc ç±»å‹æ¥åˆ›å»ºå…±äº«æ•°æ®å¹¶åœ¨æ¯ä¸ªçº¿ç¨‹ä¹‹é—´å…±äº«å®ƒã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š

```rust
#![forbid(unused_imports)]
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers); // create shared data
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = Arc::clone(&shared_numbers); // clone shared data for each thread
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
```

åœ¨è¿™ä¸ªè§£å†³æ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ Arc::new å‡½æ•°æ¥åˆ›å»ºå…±äº«æ•°æ®ï¼Œç„¶åä½¿ç”¨ Arc::clone å‡½æ•°æ¥ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºä¸€ä¸ªå…±äº«æ•°æ®çš„å…‹éš†ã€‚åœ¨çº¿ç¨‹å†…éƒ¨ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† child_numbers å˜é‡æ¥è®¿é—®å…±äº«æ•°æ®ï¼Œç„¶åé€šè¿‡è¿‡æ»¤å™¨å’Œæ±‚å’Œæ¥è®¡ç®—æ¯ä¸ªåç§»é‡ä¸‹çš„æ•°å­—å’Œã€‚æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨ handle.join() å‡½æ•°æ¥ç­‰å¾…æ¯ä¸ªçº¿ç¨‹å®Œæˆï¼Œå¹¶ä½¿ç”¨ unwrap() å‡½æ•°æ¥å¤„ç†å¯èƒ½çš„é”™è¯¯ã€‚

> Q: ä¸æ˜¯è¯´ clone å°†æ¶ˆè€—å¤§é‡èµ„æºå˜›? è¿™é‡Œæœ‰å…¶å®ƒæ–¹æ¡ˆå˜›? ä¸ä½¿ç”¨ clone çš„è¯

> A: æ˜¯çš„ï¼Œæ¯æ¬¡å…‹éš† Arc éƒ½ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜ã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†æ•°æ®åˆ’åˆ†æˆå›ºå®šå¤§å°çš„å—ï¼Œå¹¶å°†æ¯ä¸ªå—åˆ†é…ç»™ä¸åŒçš„çº¿ç¨‹ã€‚è¿™æ ·å¯ä»¥é¿å…å…‹éš† Arcï¼ŒåŒæ—¶ä¿æŒæ•°æ®çš„å…±äº«ã€‚

ä»¥ä¸‹æ˜¯ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š

```rust
#![forbid(unused_imports)]
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let chunk_size = numbers.len() / 8;
    let shared_numbers = Arc::new(Mutex::new(numbers)); // create shared data
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let start = offset * chunk_size;
        let end = start + chunk_size;
        let child_numbers = Arc::clone(&shared_numbers); // share the same Arc between threads
        joinhandles.push(thread::spawn(move || {
            let chunk = &child_numbers.lock().unwrap()[start..end]; // acquire lock and get the chunk
            let sum: u32 = chunk.iter().filter(|n| *n % 8 == offset).sum(); // compute the sum
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }

    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}

```

åœ¨è¿™ä¸ªè§£å†³æ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆè®¡ç®—æ¯ä¸ªå—çš„å¤§å°ï¼Œå¹¶ä½¿ç”¨ Arc::new(Mutex::new(numbers)) æ¥åˆ›å»ºä¸€ä¸ªåŒ…è£…äº† Vec çš„ Mutexï¼Œä»¥å®ç°å…±äº«å’Œçº¿ç¨‹å®‰å…¨ã€‚ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨ Arc::clone æ¥ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ†é…åŒä¸€ä¸ª Arcã€‚åœ¨æ¯ä¸ªçº¿ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ lock() å‡½æ•°è·å–é”æ¥è®¿é—®å…±äº«æ•°æ®ï¼Œå¹¶ä½¿ç”¨åˆ‡ç‰‡ &[T] è·å–æ¯ä¸ªçº¿ç¨‹çš„å—ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¯ä»¥åƒä¹‹å‰é‚£æ ·è®¡ç®—æ¯ä¸ªåç§»é‡ä¸‹çš„æ•°å­—å’Œï¼Œç„¶ååœ¨å®Œæˆåé‡Šæ”¾é”ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒMutex çš„ä½¿ç”¨å¯èƒ½ä¼šå¯¹æ€§èƒ½äº§ç”Ÿä¸€å®šçš„å½±å“ã€‚å¦‚æœå…±äº«æ•°æ®ä¸éœ€è¦å†™å…¥ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ RwLock æ¥è¿›è¡Œè¯»å–æ“ä½œï¼Œå› ä¸ºå®ƒå¯ä»¥å…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»å–æ•°æ®ã€‚

> Q: ä¸é”™, çœ‹èµ·æ¥å¯ä»¥è¿è¡Œ, è¿˜æœ‰å…¶å®ƒæ–¹æ¡ˆå˜›?


> A: æ˜¯çš„ï¼Œè¿˜æœ‰ä¸€ç§ä½¿ç”¨é€šé“ï¼ˆChannelï¼‰çš„è§£å†³æ–¹æ¡ˆï¼Œå®ƒå¯ä»¥é¿å…ä½¿ç”¨å…±äº«æ•°æ®ç»“æ„å’Œé”ï¼ŒåŒæ—¶ä¿æŒå¹¶å‘æ€§ã€‚åœ¨è¿™ä¸ªæ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬å°†æ•°æ®åˆ’åˆ†æˆå›ºå®šå¤§å°çš„å—ï¼Œå¹¶å°†æ¯ä¸ªå—å‘é€åˆ°ä¸€ä¸ªé€šé“ä¸­ï¼Œç„¶åè®©æ¯ä¸ªçº¿ç¨‹ä»é€šé“ä¸­æ¥æ”¶è‡ªå·±çš„å—ï¼Œå¹¶è®¡ç®—æ¯ä¸ªåç§»é‡ä¸‹çš„æ•°å­—å’Œã€‚

ä»¥ä¸‹æ˜¯ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š

```rust
#![forbid(unused_imports)]
use std::sync::mpsc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let chunk_size = numbers.len() / 8;
    let (tx, rx) = mpsc::channel(); // create a channel
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let start = offset * chunk_size;
        let end = start + chunk_size;
        let child_tx = tx.clone(); // clone the channel sender
        let chunk = &numbers[start..end].to_vec(); // create a new vector with a chunk of the data
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = chunk.iter().filter(|n| *n % 8 == offset).sum(); // compute the sum
            child_tx.send(sum).unwrap(); // send the sum back to the main thread
        }));
    }

    drop(tx); // close the sender channel to signal the end of the transmission
    let total_sum: u32 = rx.iter().sum(); // receive the sums and compute the total sum
    println!("Total sum is {}", total_sum);

    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
```
åœ¨è¿™ä¸ªè§£å†³æ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆè®¡ç®—æ¯ä¸ªå—çš„å¤§å°ï¼Œå¹¶ä½¿ç”¨ mpsc::channel() å‡½æ•°åˆ›å»ºä¸€ä¸ªé€šé“æ¥ä¼ é€’æ•°æ®ã€‚ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨ clone() å‡½æ•°æ¥å…‹éš†é€šé“çš„å‘é€å™¨ï¼Œä»¥ä¾¿æ¯ä¸ªçº¿ç¨‹éƒ½å¯ä»¥å‘é€å®ƒä»¬çš„ç»“æœã€‚åœ¨æ¯ä¸ªçº¿ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ &numbers[start..end].to_vec() æ¥åˆ›å»ºä¸€ä¸ªåŒ…å«å—çš„æ–°å‘é‡ï¼Œå¹¶è®¡ç®—æ¯ä¸ªåç§»é‡ä¸‹çš„æ•°å­—å’Œã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä½¿ç”¨ send() å‡½æ•°å°†ç»“æœå‘é€å›ä¸»çº¿ç¨‹ã€‚åœ¨ä¸»çº¿ç¨‹ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨ iter() å‡½æ•°å’Œ sum() å‡½æ•°æ¥æ¥æ”¶æ‰€æœ‰ç»“æœï¼Œå¹¶è®¡ç®—å®ƒä»¬çš„æ€»å’Œã€‚æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨ drop() å‡½æ•°å…³é—­å‘é€å™¨é€šé“ï¼Œä»¥é€šçŸ¥æ‰€æœ‰æ¥æ”¶å™¨çº¿ç¨‹ä¼ è¾“å·²ç»ç»“æŸã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé€šé“çš„ä½¿ç”¨å¯èƒ½ä¼šå¯¹æ€§èƒ½äº§ç”Ÿä¸€å®šçš„å½±å“ï¼Œå› ä¸ºå®ƒæ¶‰åŠåˆ°äº†æ•°æ®ä¼ è¾“å’Œçº¿ç¨‹é—´é€šä¿¡çš„å¼€é”€ã€‚å¦‚æœè¦å¤„ç†å¤§é‡çš„æ•°æ®æˆ–è€…è¦æ±‚éå¸¸é«˜çš„æ€§èƒ½ï¼Œé‚£ä¹ˆå¯èƒ½éœ€è¦ä½¿ç”¨å…¶å®ƒçš„å¹¶å‘ç¼–ç¨‹æŠ€æœ¯æ¥ä¼˜åŒ–ç¨‹åºã€‚

> Q: ä¸é”™, ä¹Ÿæ˜¯ä¸ªåŠæ³•, è¿˜æœ‰å…¶å®ƒæ–¹æ¡ˆå˜›? å¦‚æœä½¿ç”¨å…¶å®ƒç¬¬ä¸‰æ–¹ crate çš„è¯, æœ‰ä»€ä¹ˆå»ºè®®?


> A: æ˜¯çš„ï¼Œè¿˜æœ‰ä¸€äº›ç¬¬ä¸‰æ–¹ crate å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ›´æ–¹ä¾¿åœ°ç¼–å†™é«˜æ•ˆçš„å¹¶å‘ Rust ä»£ç ã€‚

ä¸€ç§å¸¸ç”¨çš„ crate æ˜¯ Rayonï¼Œå®ƒæ˜¯ä¸€ä¸ªåŸºäºæ•°æ®å¹¶è¡Œæ€§çš„åº“ï¼Œå¯ä»¥è½»æ¾åœ°å°† Rust ä»£ç è½¬æ¢ä¸ºå¹¶è¡Œä»£ç ã€‚åœ¨ Rayon ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ par_iter() å‡½æ•°æ¥åˆ›å»ºä¸€ä¸ªå¹¶è¡Œè¿­ä»£å™¨ï¼Œå¹¶å°†è¿­ä»£å™¨ä¸Šçš„æ“ä½œå¹¶è¡ŒåŒ–ã€‚ä»¥ä¸‹æ˜¯ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š

```rust
#![forbid(unused_imports)]
use rayon::prelude::*;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let joinhandles = (0..8).into_par_iter().map(|offset| {
        let sum: u32 = numbers.par_iter().filter(|n| *n % 8 == offset).sum();
        println!("Sum of offset {} is {}", offset, sum);
    }).collect::<Vec<_>>();
}
```

åœ¨è¿™ä¸ªè§£å†³æ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆä½¿ç”¨ into_par_iter() å‡½æ•°å°† 0..8 è½¬æ¢ä¸ºä¸€ä¸ªå¹¶è¡Œè¿­ä»£å™¨ï¼Œç„¶åä½¿ç”¨ map() å‡½æ•°å¯¹æ¯ä¸ªåç§»é‡è¿›è¡Œæ“ä½œã€‚åœ¨æ¯ä¸ªæ“ä½œä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ par_iter() å‡½æ•°å°† numbers è½¬æ¢ä¸ºä¸€ä¸ªå¹¶è¡Œè¿­ä»£å™¨ï¼Œå¹¶ä½¿ç”¨ filter() å‡½æ•°è¿‡æ»¤å‡ºæ¯ä¸ªåç§»é‡ä¸‹çš„æ•°å­—ï¼Œç„¶åä½¿ç”¨ sum() å‡½æ•°è®¡ç®—å®ƒä»¬çš„æ€»å’Œã€‚åœ¨è®¡ç®—å®Œæ‰€æœ‰åç§»é‡çš„å’Œåï¼Œç¨‹åºå°±å¯ä»¥é€€å‡ºäº†ã€‚

é™¤äº† Rayonï¼Œè¿˜æœ‰ä¸€äº›å…¶å®ƒçš„å¹¶å‘åº“å’Œæ¡†æ¶ï¼Œä¾‹å¦‚ Crossbeam å’Œ tokio ç­‰ï¼Œå®ƒä»¬éƒ½æä¾›äº†ä¸€äº›æ–¹ä¾¿çš„å·¥å…·å’Œ API æ¥å¸®åŠ©æˆ‘ä»¬ç¼–å†™é«˜æ•ˆçš„å¹¶å‘ Rust ä»£ç ã€‚å…·ä½“ä½¿ç”¨å“ªä¸ªåº“ï¼Œå¯ä»¥æ ¹æ®å…·ä½“çš„éœ€æ±‚å’Œåœºæ™¯è¿›è¡Œé€‰æ‹©ã€‚

> Q: çœ‹èµ·æ¥éƒ½ä¸é”™, è°¢è°¢,æˆ‘å­¦ä¹ ä¸€ä¸‹

> A: ä¸ç”¨è°¢ï¼Œç¥ä½ å­¦ä¹ æ„‰å¿«ï¼å¦‚æœä½ æœ‰ä»»ä½•å…¶ä»–é—®é¢˜æˆ–è€…éœ€è¦è¿›ä¸€æ­¥çš„å¸®åŠ©ï¼Œéšæ—¶å¯ä»¥é—®æˆ‘å“¦ï¼



## refer.
> å…¶å®å®˜æ–¹çš„æ–‡æ¡£åƒé€, åŸºæœ¬å¯ä»¥å¹³è¶Ÿ 80% çš„æ—¥å¸¸å¼€å‘äº†...

ä»¥åŠå°†è‡ªå·±ä¼ªè£…æˆä¸€ä¸ªè®¤çœŸåˆå¾ˆç¬¨çš„å­¦å‘˜,
GPT ä»¬å°±å¯ä»¥æ— é™è€å¿ƒçš„åå¤å›ç­”æ‰€æœ‰é—®é¢˜, å½“ç„¶, å¾—é…å¥—è‡ªè¡Œæ£€éªŒä»¥åŠå®˜æ–¹æ–‡æ¡£è¯å®:

- [rayon - crates.io: Rust Package Registry](https://crates.io/crates/rayon)
- [crossbeam - crates.io: Rust Package Registry](https://crates.io/crates/crossbeam)
- [tokio - crates.io: Rust Package Registry](https://crates.io/crates/tokio)
- ...

æ‰€ä»¥, rust æ˜¯æ•…æ„ä¸æŠ˜è…¾å¤æ‚çš„å†…å»ºæ¨¡å—, ä¸“æ³¨æé«˜ç¼–è¯‘å™¨èƒ½åŠ›,
å…¶å®ƒçš„å„ç§åˆ›æ–°å®ç”¨ crate éƒ½ç»™ç¤¾åŒºæŠ˜è…¾äº†...?

```
     _~âˆ½~-~_
 \/ /  - â—µ  \ \/
   '_   V   _'
   / '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>chat_heap_stack.md</title><link>https://rs.101.so//101/chat_heap_stack</link><pubDate>Fri, 24 Mar 2023 11:29:16 +0800</pubDate><content:encoded><![CDATA[# å¯å˜/ä¸å¯å˜å¼•ç”¨æ€åº¦
> å­¦ä¼´ChatGPT, chatting for debugging ...

## background
> ææ˜ codingåˆ°ç¯ç«é˜‘çŠ 2023-03-24 06:00

[Rustå¼€å‘äººå‘˜ç»å¸¸çŠ¯çš„5ä¸ªå¸¸è§é”™è¯¯](https://mp.weixin.qq.com/s/KXfCHeFuLvK8PHAkA5QJmA)

## goal

å®Œæˆåˆç†æ¦‚å¿µæ‘¸æŸ¥...

## trace

> Q: rust ä»£ç :

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        // è¿™ä¸€è¡Œå°†å¯¼è‡´ç¼–è¯‘é”™è¯¯
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}

```

ä¸ºä»€ä¹ˆå‡ºé”™?å¦‚ä½•ä¿®æ”¹? ä»¥åŠå¦‚ä½•ç†è§£?

> A:è¯¥ç¨‹åºå‡ºé”™æ˜¯å› ä¸º string2 çš„ç”Ÿå‘½å‘¨æœŸæ¯” result çš„ç”Ÿå‘½å‘¨æœŸçŸ­ï¼Œè€Œ result æ˜¯ä¸€ä¸ªæŒ‡å‘ string2 ä¸­çš„å¼•ç”¨ï¼Œå› æ­¤åœ¨ string2 ç¦»å¼€ä½œç”¨åŸŸåï¼Œresult æŒ‡å‘çš„å†…å­˜å·²ç»è¢«é‡Šæ”¾ï¼Œè¿™ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦è®© result çš„ç”Ÿå‘½å‘¨æœŸæ¯” string2 çš„ç”Ÿå‘½å‘¨æœŸæ›´é•¿ã€‚æœ‰å¤šç§æ–¹æ³•å¯ä»¥å®ç°è¿™ä¸€ç‚¹ï¼Œä»¥ä¸‹æ˜¯å…¶ä¸­çš„ä¸€ç§ï¼š

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    let string2 = String::from("xyz");
    result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);
}
```
åœ¨è¿™ä¸ªä¿®æ”¹åçš„ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å°† string2 çš„å£°æ˜ç§»åˆ°äº† result çš„å£°æ˜ä¹‹å‰ï¼Œå¹¶ä¸”ä¸å†ä½¿ç”¨ä¸€ä¸ªä»£ç å—æ¥é™åˆ¶ string2 çš„ä½œç”¨åŸŸã€‚è¿™æ„å‘³ç€ string2 å’Œ result çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œå› æ­¤ result ä»ç„¶æœ‰æ•ˆã€‚

è¯¥ç¨‹åºçš„ä»£ç ä½¿ç”¨äº† Rust çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š 'a æ¥å‘Šè¯‰ç¼–è¯‘å™¨ longest å‡½æ•°çš„è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸåº”è¯¥ä¸ x å’Œ y çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒã€‚

ç®€å•åœ°è¯´ï¼Œç¨‹åºä¸­çš„ä¿®æ”¹è®© string2 å’Œ result å…·æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼Œä»è€Œè§£å†³äº†é—®é¢˜ã€‚

> Q: let string2 = "xyz"; æ˜¯å¦ä¹Ÿå¯ä»¥è§£å†³ç›¸åŒçš„é—®é¢˜? ä¸ºä»€ä¹ˆ?

> A:æ˜¯çš„ï¼Œå¦‚æœå°† string2 çš„ç±»å‹ä» String æ”¹ä¸ºå­—ç¬¦ä¸²å­—é¢é‡ &strï¼Œåˆ™ç¨‹åºå°±å¯ä»¥æ­£ç¡®ç¼–è¯‘å’Œè¿è¡Œã€‚ä¿®æ”¹åçš„ç¨‹åºå¦‚ä¸‹ï¼š

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

å­—ç¬¦ä¸²å­—é¢é‡åœ¨ç¼–è¯‘æ—¶å°±å·²ç»å­˜åœ¨äºç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå› æ­¤å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä¸ç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œè€Œä¸éœ€è¦åœ¨å †ä¸Šåˆ†é…å†…å­˜ã€‚è¿™æ„å‘³ç€å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä¸å…¶ä»–åœ¨ç¨‹åºä¸­å®šä¹‰çš„å˜é‡çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œå› æ­¤åœ¨ä½¿ç”¨å­—ç¬¦ä¸²å­—é¢é‡æ—¶ä¸éœ€è¦æ‹…å¿ƒç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜ã€‚

æ‰€ä»¥ä½¿ç”¨å­—ç¬¦ä¸²å­—é¢é‡ä½œä¸ºå‚æ•°ä¼ é€’ç»™ longest å‡½æ•°æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸå·²ç»åœ¨ç¼–è¯‘æ—¶ç¡®å®šäº†ï¼Œå¹¶ä¸”ä¸å‡½æ•°ä¸­çš„å…¶ä»–å˜é‡çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒã€‚

> Q: é‚£ä¹ˆ, ä¸ºä»€ä¹ˆ longest() ä¸€å®šè¦æŒ‡å®šå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸ? æ²¡æœ‰å…¶å®ƒæ›´åŠ ç®€æ´çš„å½¢å¼äº†å˜›?

> A: åœ¨ Rust ä¸­ï¼Œstr æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸² slice ç±»å‹ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯å˜çš„ã€å›ºå®šé•¿åº¦çš„å¼•ç”¨ç±»å‹ã€‚ç”±äº str å¼•ç”¨çš„æ˜¯å­˜å‚¨åœ¨å †ä¸Šçš„å­—ç¬¦ä¸²æ•°æ®ï¼Œå› æ­¤å®ƒçš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»æ˜¯ç”±è¯¥å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒæ¥å†³å®šçš„ã€‚

åœ¨ longest() å‡½æ•°ä¸­ï¼Œx å’Œ y çš„ç±»å‹æ˜¯ &'a strï¼Œè¿™è¡¨ç¤ºå®ƒä»¬æ˜¯æŒ‡å‘æŸä¸ªå­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸè¢«é™åˆ¶ä¸º 'aï¼Œå³å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºå‡½æ•°çš„è¿”å›å€¼ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹å­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»æ˜¯åœ¨å‡½æ•°è¿”å›åæ‰èƒ½å¼€å§‹çš„ï¼Œè€Œä¸”å¿…é¡»ä¸å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³è”ï¼Œä»¥é¿å…æ‚¬å‚å¼•ç”¨çš„é—®é¢˜ã€‚

å¦‚æœæˆ‘ä»¬å°†å‚æ•°ç±»å‹æ”¹ä¸º strï¼Œé‚£ä¹ˆå°±æ— æ³•æ§åˆ¶å®ƒä»¬å¼•ç”¨çš„å­—ç¬¦ä¸²çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› ä¸ºå®ƒä»¬ä¸æ˜¯å¼•ç”¨ç±»å‹ã€‚å¦‚æœæˆ‘ä»¬è¯•å›¾é€šè¿‡å°† string1 å’Œ string2 çš„å€¼è¿›è¡Œ clone æ¥ä¼ é€’å®ƒä»¬çš„å‰¯æœ¬ï¼Œè¿™æ ·å¯èƒ½ä¼šå¯¼è‡´å †åˆ†é…çš„é¢å¤–å¼€é”€å’Œæ€§èƒ½é—®é¢˜ï¼Œå› ä¸ºè¿™éœ€è¦ä¸ºæ¯ä¸ªå­—ç¬¦ä¸²åˆ†é…ä¸€ä¸ªæ–°çš„å†…å­˜å—ï¼Œå¹¶åœ¨å‡½æ•°è°ƒç”¨ç»“æŸåé‡Šæ”¾è¿™äº›å†…å­˜å—ã€‚

å› æ­¤ï¼Œåœ¨ longest() å‡½æ•°ä¸­ï¼Œæœ€å¥½ä½¿ç”¨å­—ç¬¦ä¸² slice ç±»å‹ &strï¼Œå¹¶åœ¨è°ƒç”¨å‡½æ•°æ—¶ä¼ é€’æŒ‡å‘åŸå§‹å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼Œä»¥ç¡®ä¿åœ¨ä¸éœ€è¦åˆ†é…é¢å¤–å†…å­˜çš„æƒ…å†µä¸‹æ­£ç¡®å¤„ç†å­—ç¬¦ä¸²ã€‚

> Q: æ˜ç™½äº†, å¦‚æœä¸è€ƒè™‘æ€§èƒ½, ä½¿ç”¨ clone ä¹Ÿæ˜¯å¯ä»¥çš„

> A: æ˜¯çš„ï¼Œå¦‚æœä¸è€ƒè™‘æ€§èƒ½é—®é¢˜ï¼Œä½ å¯ä»¥é€šè¿‡ä½¿ç”¨ clone() æ–¹æ³•æ¥åˆ›å»ºä¼ é€’ç»™ longest() å‡½æ•°çš„å­—ç¬¦ä¸²çš„æ‹·è´ã€‚è¿™å°†ä½¿æ¯ä¸ªå­—ç¬¦ä¸²éƒ½åœ¨å †ä¸Šåˆ†é…æ–°çš„å†…å­˜ï¼Œå¹¶ä½¿ longest() å‡½æ•°èƒ½å¤Ÿæ¥å— String ç±»å‹çš„å‚æ•°ã€‚

ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ä»£ç æ¥è°ƒç”¨ longest() å‡½æ•°ï¼Œä½¿ç”¨ clone() æ–¹æ³•åˆ›å»ºäº† string1 å’Œ string2 çš„å‰¯æœ¬ï¼š

```rust

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);

    // Create clones of the strings and pass them to longest()
    let string3 = string1.clone();
    let string4 = string2.clone();
    let result2 = longest(string3.as_str(), string4.as_str());
    println!("The longest string is {}", result2);
}

```
æ³¨æ„ï¼Œè¿™ç§æ–¹æ³•å¯èƒ½ä¼šäº§ç”Ÿæ€§èƒ½é—®é¢˜ï¼Œå› ä¸ºæ¯æ¬¡è°ƒç”¨ clone() æ–¹æ³•éƒ½ä¼šåˆ†é…æ–°çš„å†…å­˜å¹¶å¤åˆ¶å­—ç¬¦ä¸²çš„å†…å®¹ã€‚å› æ­¤ï¼Œå¦‚æœæ€§èƒ½æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œæœ€å¥½é¿å…ä½¿ç”¨ clone() æ–¹æ³•æ¥åˆ›å»ºå­—ç¬¦ä¸²çš„å‰¯æœ¬ã€‚


> Q: æ˜ç™½äº†, é‚£ä¹ˆ å †ä¸æ ˆçš„æœ¬è´¨åŒºåˆ«æ˜¯ä»€ä¹ˆ? ä¸ºä»€ä¹ˆ rust å¯¹æ ˆè¿™ä¹ˆä¿¡ä»», å¯¹å †å´å¾ˆè­¦æƒ•?

> A: åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œå †å’Œæ ˆéƒ½æ˜¯å†…å­˜ä¸­ç”¨äºå­˜å‚¨ç¨‹åºæ•°æ®çš„æ•°æ®ç»“æ„ã€‚å®ƒä»¬ä¹‹é—´çš„æœ¬è´¨åŒºåˆ«åœ¨äºå®ƒä»¬çš„å†…å­˜åˆ†é…æ–¹å¼å’Œæ•°æ®å­˜å‚¨çš„ç”Ÿå‘½å‘¨æœŸã€‚

æ ˆæ˜¯ä¸€ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„ï¼Œå®ƒä½¿ç”¨å›ºå®šå¤§å°çš„å†…å­˜å—æ¥å­˜å‚¨ç¨‹åºæ•°æ®ã€‚å½“ä¸€ä¸ªå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œè¯¥å‡½æ•°çš„å‚æ•°ã€å±€éƒ¨å˜é‡å’Œè¿”å›åœ°å€ç­‰æ•°æ®å°†è¢«å­˜å‚¨åœ¨æ ˆå¸§ä¸­ã€‚å½“å‡½æ•°è¿”å›æ—¶ï¼Œè¯¥æ ˆå¸§å°†è¢«å¼¹å‡ºï¼Œå…¶ä¸­å­˜å‚¨çš„æ•°æ®ä¹Ÿå°†è¢«é”€æ¯ã€‚ç”±äºæ ˆå†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾æ˜¯ç”±ç¨‹åºè‡ªåŠ¨è¿›è¡Œçš„ï¼Œå› æ­¤å®ƒä»¬çš„æ•ˆç‡éå¸¸é«˜ã€‚

å †æ˜¯ä¸€ç§åŠ¨æ€çš„æ•°æ®ç»“æ„ï¼Œå®ƒä½¿ç”¨ä¸è¿ç»­çš„å†…å­˜å—æ¥å­˜å‚¨ç¨‹åºæ•°æ®ã€‚å †å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾æ˜¯ç”±ç¨‹åºå‘˜æ‰‹åŠ¨ç®¡ç†çš„ï¼Œå®ƒä»¬çš„æ•ˆç‡ç›¸å¯¹è¾ƒä½ã€‚ç”±äºå †å†…å­˜çš„ç”Ÿå‘½å‘¨æœŸä¸åƒæ ˆé‚£æ ·æ˜“äºç¡®å®šï¼Œå› æ­¤åœ¨ä½¿ç”¨å †å†…å­˜æ—¶éœ€è¦æ³¨æ„å†…å­˜æ³„æ¼å’Œæ‚¬å‚æŒ‡é’ˆç­‰é—®é¢˜ã€‚

åœ¨ Rust ä¸­ï¼Œæ ˆä¸Šçš„æ•°æ®æ˜¯å¯ä»¥ç›´æ¥åœ¨æ ˆå¸§ä¸­è¿›è¡Œåˆ†é…å’Œé‡Šæ”¾çš„ï¼Œå› æ­¤ Rust å¯¹æ ˆçš„ç®¡ç†éå¸¸ä¿¡ä»»ã€‚ä½†æ˜¯ï¼Œç”±äºå †ä¸Šçš„æ•°æ®éœ€è¦æ‰‹åŠ¨ç®¡ç†ï¼Œå› æ­¤åœ¨ Rust ä¸­å¯¹å †çš„ç®¡ç†è¦æ›´åŠ è­¦æƒ•ï¼Œä»¥é¿å…å†…å­˜æ³„æ¼å’Œæ‚¬å‚æŒ‡é’ˆç­‰é—®é¢˜ã€‚å› æ­¤ï¼Œåœ¨ Rust ä¸­ä½¿ç”¨å †å†…å­˜æ—¶ï¼Œå¿…é¡»éµå¾ªæ‰€æœ‰æƒè§„åˆ™ï¼Œä»¥ç¡®ä¿æ¯ä¸ªå€¼éƒ½æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå¹¶åœ¨æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾å…¶å†…å­˜ã€‚è¿™ä¹Ÿæ˜¯ Rust ä¸­æ‰€æœ‰æƒç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µã€‚


> Q: é‚£ä¹ˆ, rust å†…å»ºæ•°æ®ç±»å‹ä¸­, å“ªäº›æ˜¯æ ˆ, å“ªäº›æ˜¯å †?

> A: åœ¨ Rust ä¸­ï¼Œå†…å»ºæ•°æ®ç±»å‹å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šæ ˆä¸Šåˆ†é…çš„å€¼å’Œå †ä¸Šåˆ†é…çš„å€¼ã€‚

ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„æ ˆä¸Šåˆ†é…çš„å€¼ï¼š

- æ‰€æœ‰åŸºæœ¬æ•°æ®ç±»å‹ï¼ˆä¾‹å¦‚æ•´æ•°ã€å¸ƒå°”å€¼å’Œæµ®ç‚¹æ•°ï¼‰
- æ•°ç»„å’Œå…ƒç»„ï¼ˆå½“å®ƒä»¬åŒ…å«æ ˆä¸Šåˆ†é…çš„å€¼æ—¶ï¼‰
- å‡½æ•°å’Œé—­åŒ…

ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„å †ä¸Šåˆ†é…çš„å€¼ï¼š

- æ‰€æœ‰æ ‡å‡†åº“é›†åˆç±»å‹ï¼Œä¾‹å¦‚ Vecã€String å’Œ HashMap ç­‰
- Box æ™ºèƒ½æŒ‡é’ˆå’Œ Rc å¼•ç”¨è®¡æ•°æŒ‡é’ˆ
- é—­åŒ…ï¼ˆå¦‚æœå®ƒä»¬æ•è·äº†å †ä¸Šåˆ†é…çš„å€¼ï¼‰


éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒRust ä¸­çš„**æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥åœ¨å †ä¸Šåˆ†é…ï¼Œåªè¦ä½¿ç”¨å †åˆ†é…å™¨**ï¼ˆå¦‚ Boxã€Vec æˆ–è€… Stringï¼‰å³å¯ã€‚ä½†æ˜¯ï¼Œæ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿è¿™äº›å †ä¸Šåˆ†é…çš„å€¼ä»ç„¶éµå¾ªæ‰€æœ‰æƒè§„åˆ™ï¼Œä»¥ç¡®ä¿å†…å­˜å®‰å…¨ã€‚


> Q: æ˜ç™½äº†, ä¹Ÿå°±æ˜¯è¯´ String::from("xyz") æ˜¯å †ä¸Šå†…å­˜, ä½†æ˜¯, "xyz" æ˜¯æ ˆä¸Šå†…å­˜,
é‚£ä¹ˆ, ä¸ºä»€ä¹ˆéƒ½æ˜¯ç”Ÿæˆä¸å¯å˜å­—ç¬¦ä¸², ä¸ºä»€ä¹ˆ Rust è¦æ„å»ºå‡ºå †ä¸Šå­—ç¬¦ä¸² String::from("xyz") ?
é—®é¢˜æ˜¯ String::from("xyz")  æœ‰ä»€ä¹ˆæ¯” "xyz" çš„å¥½å¤„?


> A: æ˜¯çš„ï¼Œæ‚¨çš„ç†è§£æ˜¯æ­£ç¡®çš„ã€‚"xyz" æ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶å¸¸é‡ï¼Œåˆ†é…åœ¨ç¨‹åºçš„æ ˆä¸Šï¼Œå®ƒæ˜¯ä¸€ä¸ªé™æ€åˆ†é…çš„ä¸å¯å˜å­—ç¬¦ä¸²ã€‚è€Œ String::from("xyz") æ˜¯åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†é…çš„å †ä¸Šçš„ä¸€ä¸ªä¸å¯å˜å­—ç¬¦ä¸²ã€‚

Rust ä¹‹æ‰€ä»¥æä¾› String ç±»å‹ï¼Œæ˜¯å› ä¸ºå®ƒå…·æœ‰ä»¥ä¸‹ä¸€äº›ä¼˜ç‚¹ï¼š

- åŠ¨æ€é•¿åº¦ï¼šåœ¨å †ä¸Šåˆ†é…ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒçš„é•¿åº¦å¯ä»¥åœ¨è¿è¡Œæ—¶æ ¹æ®éœ€è¦åŠ¨æ€å¢åŠ æˆ–å‡å°‘ï¼Œè¿™æ˜¯æ ˆä¸Šåˆ†é…çš„é™æ€å­—ç¬¦ä¸²æ‰€ä¸èƒ½åšåˆ°çš„ã€‚
- ä¸°å¯Œçš„å­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½ï¼šString ç±»å‹æä¾›äº†å„ç§å­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½ï¼Œä¾‹å¦‚æ‹¼æ¥ã€åˆ‡å‰²ã€æŸ¥æ‰¾ã€æ›¿æ¢ç­‰ã€‚
- UTF-8 ç¼–ç ï¼šRust ä¸­çš„å­—ç¬¦ä¸²ç±»å‹éƒ½æ˜¯åŸºäº UTF-8 ç¼–ç çš„ï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥è¡¨ç¤ºä¸–ç•Œä¸Šå‡ ä¹æ‰€æœ‰è¯­è¨€ä¸­çš„å­—ç¬¦ï¼ŒåŒ…æ‹¬éæ‹‰ä¸å­—ç¬¦é›†ï¼Œè€Œä¸ä¼šå‡ºç°ç¼–ç é—®é¢˜ã€‚


ä½†æ˜¯ï¼Œç”±äºåŠ¨æ€åˆ†é…å†…å­˜æ¶‰åŠåˆ°å †çš„ä½¿ç”¨ï¼Œè¿™ä¼šå¸¦æ¥ä¸€äº›é¢å¤–çš„å¼€é”€å’Œå¤æ‚æ€§ã€‚å› æ­¤ï¼Œåœ¨ç¼–å†™ Rust ä»£ç æ—¶ï¼Œåº”è¯¥å°½å¯èƒ½åœ°ä½¿ç”¨æ ˆä¸Šåˆ†é…çš„æ•°æ®ç±»å‹æ¥é¿å…å †åˆ†é…çš„å¼€é”€ã€‚ä»…å½“éœ€è¦åŠ¨æ€é•¿åº¦æˆ–å…¶ä»–ç‰¹æ®ŠåŠŸèƒ½æ—¶ï¼Œæ‰åº”è¯¥ä½¿ç”¨å †ä¸Šåˆ†é…çš„ç±»å‹ã€‚


## refer.
> å…¶å®å®˜æ–¹çš„æ–‡æ¡£åƒé€, åŸºæœ¬å¯ä»¥å¹³è¶Ÿ 80% çš„æ—¥å¸¸å¼€å‘äº†...

ä»¥åŠå°†è‡ªå·±ä¼ªè£…æˆä¸€ä¸ªè®¤çœŸåˆå¾ˆç¬¨çš„å­¦å‘˜,
GPT ä»¬å°±å¯ä»¥æ— é™è€å¿ƒçš„åå¤å›ç­”æ‰€æœ‰é—®é¢˜, å½“ç„¶, å¾—é…å¥—è‡ªè¡Œæ£€éªŒä»¥åŠå®˜æ–¹æ–‡æ¡£è¯å®:


- [ä»€ä¹ˆæ˜¯æ‰€æœ‰æƒï¼Ÿ - Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap)
- [ç”Ÿå‘½å‘¨æœŸåŸºç¡€ - Rust By Practice( Rust ç»ƒä¹ å®è·µ )](https://zh.practice.rs/lifetime/basic.html)
- [å­—ç¬¦ä¸²ï¼šstrå’ŒString - Rustå…¥é—¨ç§˜ç±](https://rust-book.junmajinlong.com/ch3/04_str_string.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F)
- [ç†è§£Rustå†…å­˜ç®¡ç† - Rustå…¥é—¨ç§˜ç±](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - [å †ç©ºé—´å’Œæ ˆç©ºé—´ - Rustå…¥é—¨ç§˜ç±](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - [ç®±å­ã€æ ˆå’Œå † - é€šè¿‡ä¾‹å­å­¦ Rust ä¸­æ–‡ç‰ˆ](https://rustwiki.org/zh-CN/rust-by-example/std/box.html)
    - ...
- [ä½¿ç”¨Box<T> æŒ‡å‘å †ä¸Šæ•°æ® - Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ](https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE)


```
     _~`|~~_
 \/ /  = â†’  \ ()
   '_   âˆ§   _'
   / '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>clear_explanation_rust_modele_system.md</title><link>https://rs.101.so//tip/clear_explanation_rust_modele_system</link><pubDate>Wed, 22 Mar 2023 00:51:38 +0800</pubDate><content:encoded><![CDATA[# æ¸…æ™°è§£é‡ŠRustæ¨¡å—ç³»ç»Ÿ
> tips...é‡è¦ä¹Ÿä¸é‡è¦

åŸæ–‡: [Clear explanation of Rustâ€™s module system](https://www.sheshbabu.com/posts/rust-module-system/)

## å¿«è¯‘



Rustâ€™s module system is surprisingly confusing and causes a lot of frustration for beginners.

In this post, Iâ€™ll explain the module system using practical examples so you get a clear understanding of how it works and can immediately start applying this in your projects.

Since Rustâ€™s module system is quite unique, I request the reader to read this post with an open mind and resist comparing it with how modules work in other languages.

Letâ€™s use this file structure to simulate a real world project:

```
my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â”œâ”€â”€ config.rs
  â”œâ”€â”¬ routes
  â”‚ â”œâ”€â”€ health_route.rs
  â”‚ â””â”€â”€ user_route.rs
  â””â”€â”¬ models
    â””â”€â”€ user_model.rs
```

These are the different ways we should be able to consume our modules:

![rust-module-system-1](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-1.png)


These 3 examples should be sufficient to explain how Rustâ€™s module system works.

------


### Example 1
Letâ€™s start with the first example - importing config.rs in main.rs.

// main.rs
fn main() {
  println!("main");
}
// config.rs
fn print_config() {
  println!("config");
}
The first mistake that everyone makes is just because we have files like config.rs, health_route.rs etc, we think that these files are modules and we can import them from other files.

Hereâ€™s what we see (file system tree) and what the compiler sees (module tree):



Surprisingly, the compiler only sees the crate module which is our main.rs file. This is because we need to explicitly build the module tree in Rust - thereâ€™s no implicit mapping between file system tree to module tree.

We need to explicitly build the module tree in Rust, thereâ€™s no implicit mapping to file system

To add a file to the module tree, we need to declare that file as a submodule using the mod keyword. The next thing that confuses people is that you would assume we declare a file as module in the same file. But we need to declare this in a different file! Since we only have main.rs in the module tree, letâ€™s declare config.rs as a submodule in main.rs.

The mod keyword declares a submodule

The mod keyword has this syntax:

mod my_module;
Here, the compiler looks for my_module.rs or my_module/mod.rs in the same directory.

my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â””â”€â”€ my_module.rs

or

my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â””â”€â”¬ my_module
    â””â”€â”€ mod.rs
Since main.rs and config.rs are in the same directory, letâ€™s declare the config module as follows:

// main.rs
+ mod config;

fn main() {
+ config::print_config();
  println!("main");
}
// config.rs
fn print_config() {
  println!("config");
}
Weâ€™re accessing the print_config function using the :: syntax.

Hereâ€™s how the module tree looks like:



Weâ€™ve successfully declared the config module! But this is not sufficient to be able to call the print_config function inside config.rs. Almost everything in Rust is private by default, we need to make the function public using the pub keyword:

The pub keyword makes things public

// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// config.rs
- fn print_config() {
+ pub fn print_config() {
  println!("config");
}
Now, this works. Weâ€™ve successfully called a function defined in a different file!

------


### Example 2
Letâ€™s try calling the print_health_route function defined in routes/health_route.rs from main.rs.

// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// routes/health_route.rs
fn print_health_route() {
  println!("health_route");
}
As we discussed earlier, we can use the mod keyword only for my_module.rs or my_module/mod.rs in the same directory.

So in order to call functions inside routes/health_route.rs from main.rs, we need to do the following things:

Create a file named routes/mod.rs and declare the routes submodule in main.rs
Declare the health_route submodule in routes/mod.rs and make it public
Make the functions inside health_route.rs public
my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â”œâ”€â”€ config.rs
  â”œâ”€â”¬ routes
+ â”‚ â”œâ”€â”€ mod.rs
  â”‚ â”œâ”€â”€ health_route.rs
  â”‚ â””â”€â”€ user_route.rs
  â””â”€â”¬ models
    â””â”€â”€ user_model.rs
// main.rs
mod config;
+ mod routes;

fn main() {
+ routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/mod.rs
+ pub mod health_route;
// routes/health_route.rs
- fn print_health_route() {
+ pub fn print_health_route() {
  println!("health_route");
}
Hereâ€™s how the module tree looks like:



We can now call a function defined in a file inside a folder.

------


### Example 3
Letâ€™s try calling from main.rs => routes/user_route.rs => models/user_model.rs

// main.rs
mod config;
mod routes;

fn main() {
  routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/user_route.rs
fn print_user_route() {
  println!("user_route");
}
// models/user_model.rs
fn print_user_model() {
  println!("user_model");
}
We want to call the function print_user_model from print_user_route from main.

Letâ€™s make the same changes as before - declaring submodules, making functions public and adding the mod.rs file.

my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â”œâ”€â”€ config.rs
  â”œâ”€â”¬ routes
  â”‚ â”œâ”€â”€ mod.rs
  â”‚ â”œâ”€â”€ health_route.rs
  â”‚ â””â”€â”€ user_route.rs
  â””â”€â”¬ models
+   â”œâ”€â”€ mod.rs
    â””â”€â”€ user_model.rs
// main.rs
mod config;
mod routes;
+ mod models;

fn main() {
  routes::health_route::print_health_route();
+ routes::user_route::print_user_route();
  config::print_config();
  println!("main");
}
// routes/mod.rs
pub mod health_route;
+ pub mod user_route;
// routes/user_route.rs
- fn print_user_route() {
+ pub fn print_user_route() {
  println!("user_route");
}
// models/mod.rs
+ pub mod user_model;
// models/user_model.rs
- fn print_user_model() {
+ pub fn print_user_model() {
  println!("user_model");
}
Hereâ€™s how the module tree looks like:



Wait, we havenâ€™t actually called print_user_model from print_user_route! So far, weâ€™ve only called the functions defined in other modules from main.rs, how do we do that from other files?

If we look at our module tree, the print_user_model function sits in the crate::models::user_model path. So in order to use a module in files that are not main.rs, we should think in terms of the path necessary to reach that module in the module tree.

// routes/user_route.rs
pub fn print_user_route() {
+ crate::models::user_model::print_user_model();
  println!("user_route");
}
Weâ€™ve successfully called a function defined in a file from a file thatâ€™s not main.rs.

------


### super
The fully qualified name gets too lengthy if our file organization is multiple directories deep. Letâ€™s say for whatever reason, we want to call print_health_route from print_user_route. These are under the paths crate::routes::health_route and crate::routes::user_route respectively.

We can call it by using the fully qualified name crate::routes::health_route::print_health_route() but we can also use a relative path super::health_route::print_health_route();. Notice that weâ€™ve used super to refer to the parent scope.

The super keyword in module path refers to the parent scope

pub fn print_user_route() {
  crate::routes::health_route::print_health_route();
  // can also be called using
  super::health_route::print_health_route();

  println!("user_route");
}

------


### use
It would be tedious to use the fully qualified name or even the relative name in the above examples. In order to shorten the names, we can use the use keyword to bind the path to a new name or alias.

The use keyword is used to shorten the module path

pub fn print_user_route() {
  crate::models::user_model::print_user_model();
  println!("user_route");
}
The above code can be refactored as:

use crate::models::user_model::print_user_model;

pub fn print_user_route() {
  print_user_model();
  println!("user_route");
}
Instead of using the name print_user_model, we can also alias it to something else:

use crate::models::user_model::print_user_model as log_user_model;

pub fn print_user_route() {
  log_user_model();
  println!("user_route");
}

------

### External modules
Dependencies added to Cargo.toml are available globally to all modules inside the project. We donâ€™t need to explicitly import or declare anything to use a dependency.

External dependencies are globally available to all modules inside a project

For example, letâ€™s say we added the rand crate to our project. We can use it in our code directly as:

pub fn print_health_route() {
  let random_number: u8 = rand::random();
  println!("{}", random_number);
  println!("health_route");
}
We can also use use to shorten the path:

use rand::random;

pub fn print_health_route() {
  let random_number: u8 = random();
  println!("{}", random_number);
  println!("health_route");
}

------

### Summary
The module system is explicit - thereâ€™s no 1:1 mapping with file system
We declare a file as module in its parent, not in itself
The mod keyword is used to declare submodules
We need to explicitly declare functions, structs etc as public so they can be consumed in other modules
The pub keyword makes things public
The use keyword is used to shorten the module path
We donâ€™t need to explicitly declare 3rd party modules
Thanks for reading! Feel free to follow me in Twitter for more posts like this :)





```
         _~^*âˆ½~_
     \/ /  # â—µ  \ (/
       '_   â©Œ   _'
       | '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>past_ampersand-driven_development.md</title><link>https://rs.101.so//101/past_ampersand-driven_development</link><pubDate>Wed, 22 Mar 2023 00:47:58 +0800</pubDate><content:encoded><![CDATA[# å…‹æœ "& é©±åŠ¨å¼€å‘"
åŸæ–‡: [Getting Past â€œAmpersand-Driven Developmentâ€ in Rust - Blog](https://fiberplane.com/blog/getting-past-ampersand-driven-development-in-rust)

## background

[RR23W10 - é”ˆå‘¨åˆŠ -> Weekly :: China<Rustaceans>](https://weekly.rs.101.so/abt/index.html) ä¸­å‘ç°å¥½æ–‡,
è¯‘æ¥ç»†è¯»....

## å¿«è¯‘
> A little mental model for ownership and borrowing

æ‰€æœ‰æƒå’Œå€Ÿç”¨çš„å°å°å¿ƒæ™ºæ¨¡å‹.

æˆ‘æ˜¯åœ¨ä¸€æ¬¡ [Tad Lispy](https://www.youtube.com/watch?v=lsnksAMpUvM)
çš„æ¼”è®²ä¸­å¬åˆ° "& ç¬¦å·é©±åŠ¨å¼€å‘"è¿™è¯å„¿çš„,
éå¸¸ç²¾ç¡®çš„æ•æ‰åˆ°äº†å¾ˆå¤š Rust æ–°äººå¼€å‘æ—¶,
ä¸‹æ„è¯†çš„éšæœºæ’å…¥ & ç¬¦å·æ¥å®‰æŠšç¼–è¯‘çš„è¡Œä¸º.

æ­¤æ–‡, æè¿°äº†æˆ‘æƒ³å‘ Rust æ–°æ‰‹è§£é‡Šçš„ä¸€ä¸ªå¿ƒæ™ºæ¨¡å‹ï¼Œ
æ¶‰åŠ &,&mut,æ‰€æœ‰æƒ, Rcs å’Œ Arcs ä¹‹é—´çš„åŒºåˆ«;
æˆ‘å¸Œæœ›ä½ æˆ–æ˜¯å…¶å®ƒæœ‰æŠ±è´Ÿçš„ Rustacean ä»¬å¯¹æ­¤æ„Ÿè§‰æœ‰ç”¨.

### å¼•ç”¨ (&variable)

è®©æˆ‘ä»¬ä» & ç¬¦å·å¼€å§‹,
çœŸæ˜¯ä¸ªå¯æ€•çš„ç¬¦å·;
åœ¨ Rust ä¸­éšå¤„å¯è§ --- å¦‚æœä½ é¦–æ¬¡å°è¯•ç¼–å†™ä¸€äº› Rust ä»£ç ,
å¯èƒ½ä¸åˆ° 10 åˆ†é’Ÿ,
Rust ç¼–è¯‘å™¨å°±ä¼šçƒ¦äººçš„æˆ–æ˜¯æœ‰ç”¨çš„å‘Šè¯‰ä½ ,
åœ¨å“ªå„¿éœ€è¦æ”¾ç½®ä¸€ä¸ª &;

æƒ³è±¡ä¸€ä¸‹,æˆ‘ä»¬æœ‰ä¸ªè®¡ç®—å­—ç¬¦ä¸²é•¿åº¦çš„ç®€å•å‡½æ•°;
æ­¤å‡½æ•°éœ€è¦æŸ¥é˜…å­—ç¬¦ä¸²;
ä½†æ˜¯, éœ€è¦æ‰€æœ‰æƒè¿›è¡Œä¿®æ”¹å˜›?ä¸;
å½“é•¿åº¦å‡½æ•°å®Œæˆæ—¶,æˆ‘ä»¬åº”è¯¥ä»å†…å­˜ä¸­åˆ é™¤å­—ç¬¦ä¸²å˜›? ä¹Ÿä¸éœ€è¦;
è¿™æ„å‘³ç€é•¿åº¦å‡½æ•°å˜¦è¯»å–è®¿é—®æƒ,
åªæ˜¯è¦å­—ç¬¦ä¸²çš„ä¸´æ—¶è§†å›¾è€Œä¸æ˜¯æ°¸ä¹…ç‰ˆæœ¬;

è¿™å°±æ˜¯ &å˜é‡ ç¬¦å·åœ¨ Rust ä¸­çš„å«ä¹‰;
æƒ³æƒ³ä¸€ä¸ªå°å­©å­å°†æœ€å–œæ¬¢çš„ç©å…·å€Ÿç»™å¦å¤–ä¸€ä¸ªå­©å­æ—¶è¯´:
"ä½ å¯ä»¥çœ‹, ä½†æ˜¯, ä¸èƒ½æ‘¸; å½“ä½ çœ‹å®Œå, æˆ‘æƒ³ç«‹å³æ‹¿å›æ¥;"
è¿™å°±æ˜¯å…±äº«å¼•ç”¨;

![Midjourney](https://framerusercontent.com/images/5LwiCYhw088dpelWzFCkp9MWSo.png)


> å›¾ç‰‡ç”± Evan Schwartz ä½¿ç”¨ Midjourney åˆ›ä½œ


### å¯å˜å¼• (&mut variable)

é‚£ä¹ˆ &mut å˜é‡åˆæ˜¯æ€ä¹ˆå›äº‹å„¿?

è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹åœ¨ç»™å®šå­—ç¬¦ä¸²å‰è¿½åŠ  "hello" çš„å‡½æ•°,
è€Œä¸æ˜¯æˆ‘ä»¬çš„å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°;
åœ¨è¿™ç§æƒ…å†µä¸­,
æˆ‘ä»¬ç¡¬éª¨å¤´å¸Œæœ›å‡½æ•°ä¿®æ”¹ç»™è¿›æ¥çš„æ•°æ®;
è¿™æ—¶,æˆ‘ä»¬å°±éœ€è¦ &mut æˆ–è¯´ å¯å˜å¼•ç”¨;

æƒ³æƒ³æˆ‘ä»¬çš„å°å­©å­å€Ÿä¸€æœ¬æ¶‚è‰²ä¹¦ç»™æœ‹å‹,
è®©ä»–åœ¨ä¸€é¡µä¸Šè‰²,è¯´:"ä½ å¯ä»¥çœ‹ä»¥åŠæ‘¸---ä½†æ˜¯,
å½“ä½ å®Œæˆå, æˆ‘ä»ç„¶æƒ³è¦å›æ¥";


![Evan Schwartz](https://framerusercontent.com/images/0Y2RBZro7ESbqJzViLGIqfvccY.png)

> å›¾ç‰‡ç”± Evan Schwartz ä½¿ç”¨ Midjourney åˆ›ä½œ


#### å¯å˜å¼•ç”¨æ˜¯ç‹¬å çš„

è¿™é‡Œè§£é‡Šå…³äº Rust å¾®å¦™åˆéå¸¸èªæ˜çš„è®¾è®¡æœ€å¥½çš„åœºæ™¯ä¹‹ä¸€;

å¦‚æœæŸäºº(æˆ–æ˜¯ä½ çš„ä»£ç çš„æŸéƒ¨åˆ†)æœ‰ä¸€ä¸ªå¯¹æŸä¸ªå€¼çš„å¯å˜è¢­ç”¨,
Rust ç¼–è¯‘å™¨ä¼šç¡®ä¿ç»å¯¹æ²¡æœ‰å…¶å®ƒäººå¯ä»¥å†æ¬¡å¼•ç”¨;
ä¸ºä»€ä¹ˆ?
å› ä¸º, å¦‚æœä½ æ­£åœ¨æŸ¥çœ‹æŸä¸ªä½ è®¤ä¸ºä¸å¯å˜çš„å€¼,
å½“ç„¶ä¸ä¼šåœ¨ä½ ä½¿ç”¨å…¶è¿‡ç¨‹ä¸­åˆå’Œç»´å…¶å®ƒäººæ„å¤–çš„å˜æ›´è¿™ä¸ªå¯¹è±¡
(å¯¹äºæˆ‘ä»¬ä¸Šé¢æåŠçš„å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°,
ä½ å°±çŸ¥é“å¦‚æœå…è®¸, é‚£å¾—å¤šä»¤äººå›°æƒ‘?)

å¦å¤–ä¸€å±‚å«ä¹‰æ˜¯,
å¦‚æœä»»ä½•äººå¯¹ä¸€ä¸ªå€¼æœ‰ä¸€ä¸ªä¸å¯å˜è¢­ç”¨,
æˆ‘ä»¬å°±ä¸èƒ½æ›´æ”¹å®ƒ, åˆæˆ–æ˜¯ç»™å‡ºå¦å¤–ä¸€ä¸ªå¯å˜å¼•ç”¨;


### å€¼çš„æ‹¥æœ‰ (variable)

æ¥ä¸‹æ¥,æˆ‘ä»¬å°†è®¨è®º å€¼çš„æ‹¥æœ‰;

Rust çš„å¦å¤–ä¸€ä¸ªèªæ˜ä¹‹å¤„,
åœ¨äºå¦‚ä½•ç¡®å®šä½•æ—¶åº”è¯¥å¿˜è®°æˆ–æ˜¯ä»å†…å­˜ä¸­åˆ é™¤ä¸€ä¸ªå€¼;
æ¯å½“å‡½æ•°å®Œæˆå, å…¶ä¸­å£°æ˜çš„æ‰€æœ‰å€¼éƒ½å°†è¢«åˆ é™¤æˆ–æ˜¯è‡ªåŠ¨æ¸…é™¤;

å¥½å§, è¿™å¹¶ä¸æ˜¯çœŸçš„;
å¦‚æœæˆ‘ä»¬å†æ¬¡è€ƒè™‘å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°,
å°±çŸ¥é“, æˆ‘ä»¬å¹¶ä¸å¸Œæœ›å­—ç¬¦ä¸²åœ¨é•¿åº¦å‡½æ•°å®Œæˆæ—¶å°±è¢«å®Œå…¨é—å¿˜/åˆ é™¤;
å’Œè¿½åŠ  hello å‡½æ•°ç›¸åŒ;
åœ¨è¿™äº›æƒ…å†µä¸­, åªä¼šæ¸…é™¤å¯¹è¯¥å€¼çš„å¼•ç”¨,
ä½†æ˜¯,ä¸ä¼šåˆ é™¤å®é™…å€¼;

é‚£ä¹ˆ, å°†æˆ‘ä»¬å‘ HashMap ä¸­æ’å…¥ä¸€äº›ä¸œè¥¿æ—¶åˆå¦‚ä½•?
åœ¨è¿™ç§åœºæ™¯ä¸­,
æˆ‘ä»¬å¸Œæœ›ç»™å®šçš„å­—ç¬¦ä¸²è¾“å…¥æˆä¸º HashMap çš„ä¸€éƒ¨åˆ†;
å¸Œæœ›è¯¥å€¼ç°åœ¨ç”± HashMap æ‹¥æœ‰;

æƒ³è±¡ä¸€ä¸ªå°å­©èµ é€ä»–ä»¬çš„ç©å…·ä¹‹ä¸€æ—¶è¯´:
"ç»™, ä½ å¯ä»¥æ‹¿æ¥ä½œä»»ä½•ä½ æƒ³ä½œçš„äº‹å„¿,æˆ‘ä¸éœ€è¦æ‹¿å›æ¥äº†,
äº«å—å§!"
(å³ä¾¿æ˜¯æƒ³è±¡ä¸­çš„å­©å­, ä¹Ÿéœ€è¦ç›¸å½“æˆç†Ÿæˆåƒå¯èƒ½ä»¤æ­¤åœºæ™¯å¯ä¿¡å“ª...)


### å¼•ç”¨è®¡æ•°æŒ‡é’ˆ (Rc å’Œ Arc)

æˆ‘ä»¬åœ¨ Rust ä¸­è¿˜æœ‰å¦å¤–ä¸¤ç§å€¼ç±»å‹æ˜¯ Rc å’Œ Arc;

å¯¹äº Rc, æƒ³è±¡å­©å­ç”Ÿæ—¥æ´¾å¯¹ä¸Šçš„è£…é¥°å“,
ä¾‹å¦‚æ°”çƒ;
å½“æ‰€æœ‰äººéƒ½å–ä¿¡åœ¨é‚£é‡Œæ—¶,
æˆ‘ä»¬å¸Œæœ›æ¯ä¸ªäººéƒ½çœ‹ç€, ä½†æ˜¯ä¸è¦è§¦æ‘¸è£…é¥°å“;
æˆ‘ä»¬å¸Œæœ›è£…é¥°å“ä¸€ç›´ä¿æŒåˆ°æœ€åä¸€ä¸ªå­©å­ç¦»å¼€æ—¶;
ä½†æ˜¯, å˜¦æœ€åä¸€ä¸ªç†Šå­©å­ç¦»å¼€,
æˆ‘ä»¬å°±å¯ä»¥ç«‹å³å¼€å§‹æ¸…ç†è£…é¥°å“;
è¿™å°±æ˜¯ä¸€ä¸ª Rc æˆ–æ˜¯å¼•ç”¨è®¡æ•°æŒ‡é’ˆ;

Rc è·Ÿè¸ªæœ‰å¤šå°‘äºº(æˆ–æ˜¯ä»£ç çš„ä¸€éƒ¨åˆ†)
æ­£åœ¨æŸ¥çœ‹, å¹¶ä¿æŒè¯¥å€¼, ç›´åˆ°æœ€åä¸€ä¸ªå¼•ç”¨è¢«åˆ é™¤çš„é‚£ä¸€åˆ»;

å¦‚æœä½ æ­£åœ¨ä½¿ç”¨å¼‚æ­¥æˆ–æ˜¯å¤šçº¿ç¨‹ä»£ç ,
ä½ å°†ä½¿ç”¨ Arc æˆ–æ˜¯åŸå­å¼•ç”¨è®¡æ•°æŒ‡é’ˆ,
ä½†æ˜¯, å’Œ Rc çš„æƒ³æ³•ç›¸åŒ;

æ•ˆæœä¹Ÿæ˜¯: å¤§å®¶çœ‹çœ‹è£…é¥°å“,
æ™šä¼šä¸€ç»“æŸæˆ‘ä»¬å°±æ”¶æ‹¾å¹²å‡€;

### ç»“è®º
ä½œä¸ºæœ€åçš„æ€»ç»“,
ä½ å¯ä»¥æ ¹æ®ä»¥ä¸‹é—®é¢˜, æ¥å†³ç­–åº”è¯¥ä½¿ç”¨é‚£ç§ç±»å‹çš„å€¼:

![Conclusion](https://framerusercontent.com/images/mH73ms5JxUOiNWhWMA8UKtAX7Y.jpg)


------


|                 | &var(ä¸å¯å˜å¼•) | &mut var(å¯å˜å¼•ç”¨) | var(æ‹¥æœ‰å€¼)                              | Rc(å¼•ç”¨è®¡æ•°æŒ‡é’ˆ)         | Arc(åŸå­å¼•ç”¨è®¡æ•°æŒ‡é’ˆ) |
|-----------------|------------------|----------------------|--------------------------------------------|----------------------------|-------------------------|
| å¯è¯»?           | âœ”ï¸               | âœ”ï¸                   | âœ”ï¸                                         | âœ”ï¸                         | âœ”ï¸                      |
| å¯å†™?           | âœ˜                | âœ”ï¸                   | âœ”ï¸                                         | ä»…å½“åŒ…è£…ä¸º Cell/RefCell    | ä»…å½“åŒ…è£…ä¸º Mutex/RwLock |
| å‡½æ•°ç»“æŸæ—¶ä¸¢å¼ƒ? | âœ˜                | âœ˜                    | âœ”ï¸                                         | ä»…åœ¨ Rc æœ€åçš„å…‹éš†è¢«ä¸¢å¼ƒå | ä»…å½“ Arc çš„å…‹éš†è¢«ä¸¢å¼ƒå |
| å¤šçº¿ç¨‹å¯ç”¨?     | âœ˜ æ³¨1            | âœ˜                    | å€¼å¯ä»¥åœ¨çº¿ç¨‹é—´ç§»åŠ¨,ä½†ä¸åŒçº¿ç¨‹ä¸å¯åŒæ—¶è®¿é—® | âœ˜                          | âœ”ï¸                      |



------


> æ³¨1: (é™¤éæœ‰ä¸€ä¸ª 'static ç”Ÿå‘½å‘¨æœŸ, è¿™æ„å‘³ç€åœ¨æ‰€æœ‰çº¿ç¨‹ä¸­å­˜åœ¨,æˆ–æ˜¯åœ¨çº¿ç¨‹ä½œç”¨åŸŸä¸­ä½¿ç”¨)


åœ¨ä» Typescript ç­‰é«˜çº§è¯­è¨€è½¬åˆ° Rust æ—¶,
& ç¬¦å·æ˜¯æœ€å¯æ€•æˆ–æ˜¯æœ€ä¸ç†Ÿæ‚‰çš„éƒ¨åˆ†ä¹‹ä¸€;
ä½†æ˜¯, èƒ½ä¿è¯çš„æ˜¯, ç»è¿‡ä¸€äº›ç»ƒä¹ , åœ¨ç¼–å†™ä»£ç æ—¶,
çŸ¥é“ä¸€ä¸ªå‡½æ•°åº”è¯¥é‡‡ç”¨å¯å˜å¼•ç”¨è¿˜æ˜¯ä¸å¯å˜å¼•ç”¨,
åˆæˆ–æ˜¯çŸ¥é“å…¶å®ƒåº“çš„å‡½æ•°æ˜¯å¦å¯èƒ½éœ€è¦å¼•ç”¨æˆ–æ˜¯æ‹¥æœ‰å€¼,
æ„Ÿè§‰ä¼šæ›´åŠ ç›´è§‚;
ä¹Ÿå°±æ— éœ€ `"& é©±åŠ¨å¼€å‘"` äº†;

æœ‰å…³è¯¦æƒ…, å€¼å¾—æŸ¥é˜… Rust è¯­è¨€æ–‡æ¡£:
[References and Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)
ä»¥åŠ:
 [What is Ownership?](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
 
è¿˜æœ‰ [Evan Schwartz](https://github.com/emschwartz)
æ˜¯ Fiberplane çš„é¦–å¸­ Rust å·¥ç¨‹å¸ˆ;
ä¹Ÿæ˜¯ [Autometrics](https://github.com/autometrics-dev/autometrics-rs)
çš„åˆ›é€ è€…,
ä¸€ä¸ªå…¨æ–°çš„ crate, 
å¯ä»¥è®©ä½ è½»æ¾äº†è§£ä»£ç ä¸­ä»»ä½•å‡½æ•°çš„é”™è¯¯ç‡/å»¶è¿Ÿå’Œç”Ÿäº§ä½¿ç”¨æƒ…å†µ.

## refer.

... TBD



```
          _~`+âˆ½~_
      \/ /  = â—¶  \ (/
        '_   ğŸ‚   _'
        | '-----' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```
]]></content:encoded></item></channel></rss>