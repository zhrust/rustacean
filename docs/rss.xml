<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>be Rustaceans ~ 成锈纪</title><link>https://rs.101.so</link><description>~ 汇集 大妈/Zoom.Quiet 学习/实践/探索/... Rust 世界锈迹, 一起成为 Rustacean 吧...</description><generator>my_rss_generator</generator><item><title>clear_explanation_rust_modele_system.md</title><link>https://rs.101.so//tip/clear_explanation_rust_modele_system</link><pubDate>Sat, 25 Mar 2023 00:41:47 +0800</pubDate><content:encoded><![CDATA[# 清晰解释Rust模块系统
> tips...重要也不重要

原文: [Clear explanation of Rust’s module system](https://www.sheshbabu.com/posts/rust-module-system/)

## 快译


Rust 的模块系统出奇的混乱,给初学者带来了很多挫败感;

在这篇文章中, 我将使用实际案例来解释模块系统,
以便清楚的了解其工作原理,
并可以立即开始在你的项目中应用起来;

由于 Rust 的模块系统非常独特,
我请求读者以开放的心态阅读这篇文章,
不要将其和其它语言的模块运作方式进行比较;

先使用这个文件结构来模拟一个真实世界的项目:


```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
    └── user_model.rs
```

以下这些是我们想使用自己不同模块的不同方式:

- 同级引用
- 引用下级
- 跨目录引用兄弟目录/模块

![rust-module-system-1](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-1.png)


这三个例子足以营利 Rust 的模块系统是如何工作的;


(`译按`: 其实, 这只是最基础的, 
这种目录结构是人工创建, 还是工具创建, 其实也是个问题,
毕竟, Rust 还支持内部库, 工作空间 ...等等代码管理姿势...)


------


### 示例 1

先从第一个姿势开始 --- `importing config.rs in main.rs`

```rust
// main.rs
fn main() {
  println!("main");
}

// config.rs
fn print_config() {
  println!("config");
}
```

The first mistake that everyone makes is just because we have files like config.rs, health_route.rs etc, we think that these files are modules and we can import them from other files.

Here’s what we see (file system tree) and what the compiler sees (module tree):

![system-2](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-2.png)

Surprisingly, the compiler only sees the crate module which is our main.rs file. This is because we need to explicitly build the module tree in Rust - there’s no implicit mapping between file system tree to module tree.

> We need to explicitly build the module tree in Rust, there’s no implicit mapping to file system

To add a file to the module tree, we need to declare that file as a submodule using the mod keyword. The next thing that confuses people is that you would assume we declare a file as module in the same file. But we need to declare this in a different file! Since we only have main.rs in the module tree, let’s declare config.rs as a submodule in main.rs.

> The mod keyword declares a submodule

The mod keyword has this syntax:

`mod my_module;`

Here, the compiler looks for my_module.rs or my_module/mod.rs in the same directory.

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  └── my_module.rs
```

or

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  └─┬ my_module
    └── mod.rs
```
Since main.rs and config.rs are in the same directory, let’s declare the config module as follows:

```rust
// main.rs
+ mod config;

fn main() {
+ config::print_config();
  println!("main");
}
// config.rs
fn print_config() {
  println!("config");
}
```

We’re accessing the print_config function using the :: syntax.

Here’s how the module tree looks like:

![system-3](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-3.png)


We’ve successfully declared the config module! But this is not sufficient to be able to call the print_config function inside config.rs. Almost everything in Rust is private by default, we need to make the function public using the pub keyword:

> The pub keyword makes things public

```rust
// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// config.rs
- fn print_config() {
+ pub fn print_config() {
  println!("config");
}
```


Now, this works. We’ve successfully called a function defined in a different file!

------

### Example 2
Let’s try calling the print_health_route function defined in routes/health_route.rs from main.rs.

```rust
// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// routes/health_route.rs
fn print_health_route() {
  println!("health_route");
}

```

As we discussed earlier, we can use the mod keyword only for my_module.rs or my_module/mod.rs in the same directory.

So in order to call functions inside routes/health_route.rs from main.rs, we need to do the following things:

Create a file named routes/mod.rs and declare the routes submodule in main.rs
Declare the health_route submodule in routes/mod.rs and make it public
Make the functions inside health_route.rs public

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
+ │ ├── mod.rs
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
    └── user_model.rs
```

```rust

// main.rs
mod config;
+ mod routes;

fn main() {
+ routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/mod.rs
+ pub mod health_route;
// routes/health_route.rs
- fn print_health_route() {
+ pub fn print_health_route() {
  println!("health_route");
}
```

Here’s how the module tree looks like:

![system-4](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-4.png)

We can now call a function defined in a file inside a folder.

------


### Example 3
Let’s try calling from `main.rs => routes/user_route.rs => models/user_model.rs`


```rust

// main.rs
mod config;
mod routes;

fn main() {
  routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/user_route.rs
fn print_user_route() {
  println!("user_route");
}
// models/user_model.rs
fn print_user_model() {
  println!("user_model");
}
```

We want to call the function print_user_model from print_user_route from main.

Let’s make the same changes as before - declaring submodules, making functions public and adding the mod.rs file.

```
my_project
├── Cargo.toml
└─┬ src
  ├── main.rs
  ├── config.rs
  ├─┬ routes
  │ ├── mod.rs
  │ ├── health_route.rs
  │ └── user_route.rs
  └─┬ models
+   ├── mod.rs
    └── user_model.rs
```

```rust
// main.rs
mod config;
mod routes;
+ mod models;

fn main() {
  routes::health_route::print_health_route();
+ routes::user_route::print_user_route();
  config::print_config();
  println!("main");
}

// routes/mod.rs
pub mod health_route;
+ pub mod user_route;
// routes/user_route.rs
- fn print_user_route() {
+ pub fn print_user_route() {
  println!("user_route");
}

// models/mod.rs
+ pub mod user_model;
// models/user_model.rs
- fn print_user_model() {
+ pub fn print_user_model() {
  println!("user_model");
}

```

Here’s how the module tree looks like:

![module-system-5.](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-5.png)

Wait, we haven’t actually called print_user_model from print_user_route! So far, we’ve only called the functions defined in other modules from main.rs, how do we do that from other files?

If we look at our module tree, the print_user_model function sits in the crate::models::user_model path. So in order to use a module in files that are not main.rs, we should think in terms of the path necessary to reach that module in the module tree.

```rust
// routes/user_route.rs
pub fn print_user_route() {
+ crate::models::user_model::print_user_model();
  println!("user_route");
}

```

We’ve successfully called a function defined in a file from a file that’s not main.rs.

------


### super
The fully qualified name gets too lengthy if our file organization is multiple directories deep. Let’s say for whatever reason, we want to call print_health_route from print_user_route. These are under the paths crate::routes::health_route and crate::routes::user_route respectively.

We can call it by using the fully qualified name crate::routes::health_route::print_health_route() but we can also use a relative path super::health_route::print_health_route();. Notice that we’ve used super to refer to the parent scope.

> The super keyword in module path refers to the parent scope

```rust
pub fn print_user_route() {
  crate::routes::health_route::print_health_route();
  // can also be called using
  super::health_route::print_health_route();

  println!("user_route");
}

```


------


### use
It would be tedious to use the fully qualified name or even the relative name in the above examples. In order to shorten the names, we can use the use keyword to bind the path to a new name or alias.

> The use keyword is used to shorten the module path

```rust
pub fn print_user_route() {
  crate::models::user_model::print_user_model();
  println!("user_route");
}

```


The above code can be refactored as:

```rust
use crate::models::user_model::print_user_model;

pub fn print_user_route() {
  print_user_model();
  println!("user_route");
}

```


Instead of using the name print_user_model, we can also alias it to something else:

```rust
use crate::models::user_model::print_user_model as log_user_model;

pub fn print_user_route() {
  log_user_model();
  println!("user_route");
}

```


------

### External modules
Dependencies added to Cargo.toml are available globally to all modules inside the project. We don’t need to explicitly import or declare anything to use a dependency.

> External dependencies are globally available to all modules inside a project

For example, let’s say we added the rand crate to our project. We can use it in our code directly as:

```rust
pub fn print_health_route() {
  let random_number: u8 = rand::random();
  println!("{}", random_number);
  println!("health_route");
}

```

We can also use use to shorten the path:

```rust
pub fn print_health_route() {
  let random_number: u8 = random();
  println!("{}", random_number);
  println!("health_route");
}

```

use rand::random;


------

### Summary

- The module system is explicit - there’s no 1:1 mapping with file system
- We declare a file as module in its parent, not in itself
- The mod keyword is used to declare submodules
- We need to explicitly declare functions, structs etc as public so they can be consumed in other modules
- The pub keyword makes things public
- The use keyword is used to shorten the module path
- We don’t need to explicitly declare 3rd party modules


Thanks for reading! Feel free to follow me in Twitter for more posts like this :)





```
         _~^*∽~_
     \/ /  # ◵  \ (/
       '_   ⩌   _'
       | '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>chat_for_or_itertools.md</title><link>https://rs.101.so//101/chat_for_or_itertools</link><pubDate>Fri, 24 Mar 2023 16:33:18 +0800</pubDate><content:encoded><![CDATA[# 用迭代简化嵌套循环
> 学伴ChatGPT, chatting for debugging ...

## background
> exercises 第81题?


[Rectangles in Rust on Exercism](https://exercism.org/tracks/rust/exercises/rectangles)

```
   +--+
  ++  |
+-++--+
|  |  |
+--+--+
```

要求完成代码, 可以从同类似上述 ASCII 字符串中数出6个矩形来

## goal

完成合理概念摸查...

## trace

好容易折腾出一个可以通过所有 test 的代码:

```rust

pub fn count(lines: &[&str]) -> u32 {
    let chars = lines
            .iter()
            .map(|l| l.as_bytes())
            .collect::<Vec<_>>();
    let width = lines
            .get(0)
            .map(|l| l.len())
            .unwrap_or_default();
    let height = lines.len();


    let mut count = 0;
    for top in 0..height
    {
        for left in 0..width
        {
            for bottom in top+1..height
            {
                for right in left+1..width
                {
                    if chars[top][left] == b'+'
                        && chars[top][right] == b'+'
                        && chars[bottom][left] == b'+'
                        && chars[bottom][right] == b'+'
                        && (top+1..bottom).all(|i| {
                            matches!(
                                (chars[i][left], chars[i][right]),
                                (b'|'| b'+', b'|'| b'+')
                            )})
                        && (left+1..right).all(|j| {
                            matches!(
                                (chars[top][j], chars[bottom][j]),
                                (b'-'| b'+', b'-'| b'+')
                            )})
                    {
                        count += 1;
                    }
                }
            }
        }
    }
    count 

}
```

一看就很JS, 圈复杂度不小, 应该 Rusty 一些,就开始尝试:

> Q:可以运行, 但是, 嵌套太多 for 循环了,如何改进?

> A: 这段 Rust 代码实现了一个计算 ASCII 图中矩形数量的函数。函数输入是一个字符串数组，每个字符串表示 ASCII 图的一行。函数通过检查每个可能的矩形来计算矩形数量。

原始代码中，函数使用了四层嵌套的循环来检查每个矩形。这种实现方式难以理解和维护，也可能不太高效。为了改进代码，可以使用 itertools 库中的 combinations 方法，将嵌套的循环转换为使用迭代器的方式进行迭代。

新的代码使用了迭代器和高阶函数，使得代码更加简洁和易于理解。首先，它使用 combinations 方法生成了所有行和列的索引的组合，然后使用 flat_map 将生成的嵌套迭代器展开为一个单一的元组迭代器。然后，使用 filter_map 过滤掉不是矩形的元组，最后使用 sum 方法统计矩形的数量。

这种实现方式相比原始代码减少了循环嵌套的层数，并且使用了更加高级的 Rust 特性，可以提高代码的可读性和性能。

```rust
use itertools::Itertools;

pub fn count(lines: &[&str]) -> u32 {
    let chars = lines
        .iter()
        .map(|l| l.as_bytes())
        .collect::<Vec<_>>();
    let width = lines.get(0).map(|l| l.len()).unwrap_or_default();
    let height = lines.len();

    (2..height)
        .combinations(2)
        .flat_map(|(top, bottom)| {
            (2..width)
                .combinations(2)
                .map(move |(left, right)| (top, bottom, left, right))
        })
        .filter_map(|(top, bottom, left, right)| {
            if chars[top][left] == b'+'
                && chars[top][right] == b'+'
                && chars[bottom][left] == b'+'
                && chars[bottom][right] == b'+'
                && (top + 1..bottom)
                    .all(|i| matches!((chars[i][left], chars[i][right]), (b'|' | b'+', b'|' | b'+')))
                && (left + 1..right)
                    .all(|j| matches!((chars[top][j], chars[bottom][j]), (b'-' | b'+', b'-' | b'+')))
            {
                Some(1)
            } else {
                None
            }
        })
        .sum()
}

```

> A: 报错: error[E0308]: mismatched types

```rust
  --> src/lib.rs:50:20
   |
50 |         .flat_map(|(top, bottom)| {
   |                    ^^^^^^^^^^^^-
   |                    |           |
   |                    |           expected due to this
   |                    expected struct `Vec`, found tuple
   |
   = note: expected struct `Vec<usize>`
               found tuple `(_, _)`

error[E0308]: mismatched types
  --> src/lib.rs:53:28
   |
53 |                 .map(move |(left, right)| (top, bottom, left, right))
   |                            ^^^^^^^^^^^^-
   |                            |           |
   |                            |           expected due to this
   |                            expected struct `Vec`, found tuple
   |
   = note: expected struct `Vec<usize>`
               found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rectangles` due to 2 previous errors
```

> A: 这个错误表明，你的代码在尝试使用一个包含元组的迭代器作为 flat_map 方法的输出，但是该方法期望的是一个包含整数的 Vec 结构体。类似的错误也出现在 map 方法的调用中。

这个错误可能是由于 flat_map 方法的输出类型和后续的调用期望的类型不匹配导致的。具体来说，由于 flat_map 方法返回的是一个元组的迭代器，而不是一个包含整数的 Vec，所以后续的调用无法使用该迭代器的元素。

要解决这个问题，你可以在 flat_map 和 map 方法中使用闭包来将元组转换为 Vec，或者在后续的调用中使用元组的解构方式来获取迭代器中的元素。例如，你可以修改 flat_map 和 map 方法的调用如下：

```rust
.flat_map(|(top, bottom)| {
    (0..width).combinations(2).map(move |c| (top, bottom, c[0], c[1])).collect::<Vec<_>>()
})
.filter_map(|(top, bottom, left, right)| {
    if chars[top][left] == b'+'
        && chars[top][right] == b'+'
        && chars[bottom][left] == b'+'
        && chars[bottom][right] == b'+'
        && (top+1..bottom).all(|i| {
            matches!(
                (chars[i][left], chars[i][right]),
                (b'|'| b'+', b'|'| b'+')
            )})
        && (left+1..right).all(|j| {
            matches!(
                (chars[top][j], chars[bottom][j]),
                (b'-'| b'+', b'-'| b'+')
            )})
    {
        Some(1)
    } else {
        None
    }
})
```

这些修改将确保 flat_map 和 map 方法返回的是一个包含整数的 Vec，这样就可以在后续的调用中使用了。

> A: 还是报错: error[E0308]: mismatched types

```rust
  --> src/lib.rs:50:20
   |
50 |         .flat_map(|(top, bottom)| {
   |                    ^^^^^^^^^^^^-
   |                    |           |
   |                    |           expected due to this
   |                    expected struct `Vec`, found tuple
   |
   = note: expected struct `Vec<usize>`
               found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rectangles` due to previous error

```

> A: 根据错误提示，似乎我们在flat_map操作中需要返回一个类型为Vec的对象，但我们返回的是一个元组。这个错误可能是由于我们尝试将元组（(usize, usize)）解构为两个参数而引起的。

我们可以尝试在flat_map中直接返回一个Vec，而不是一个元组。我们可以使用into_iter()方法将元组中的元素转换为迭代器，并使用collect()方法将它们收集到一个Vec中，如下所示：

```rust
let rects = (0..height - 1).into_iter()
        .flat_map(|top| {
            (top + 1..height).into_iter()
                .map(move |bottom| (top, bottom))
        })
        .flat_map(|(top, bottom)| {
            (0..width - 1).into_iter()
                .flat_map(move |left| {
                    (left + 1..width).into_iter()
                        .map(move |right| (top, bottom, left, right))
                })
        })
        .collect::<Vec<_>>();
```

这里，我们首先使用into_iter()将一个区间（0..height-1）转换为一个迭代器。然后，我们使用flat_map将每个元素（top）映射到一个迭代器，其中每个元素都是一个二元组，表示从当前top到最后一行的所有可能的矩形的底部行。我们将top传递给move闭包，以便在之后的操作中使用它。

接下来，我们使用into_iter()将一个区间（top+1..height）转换为另一个迭代器，并使用map将每个元素（bottom）映射到一个二元组，表示当前矩形的顶部行和底部行。我们使用move将top捕获到闭包中。

然后，我们使用into_iter()将一个区间（0..width-1）转换为另一个迭代器，并使用flat_map将每个元素（left）映射到一个迭代器，其中每个元素都是一个四元组，表示当前矩形的左上角和右下角的坐标。我们将top、bottom和left传递给move闭包，以便在之后的操作中使用它们。

最后，我们使用into_iter()将一个区间（left+1..width）转换为另一个迭代器，并使用map将每个元素（right）映射到一个四元组，表示当前矩形的左上角和右下角的坐标。我们将top、bottom、left和right传递给move闭包，以便在之后的操作中使用它们。

最后，我们使用collect()方法将所有四元组收集到一个Vec中。我们使用::<Vec<_>>来指定要收集

>> 接下来 ChatGPT 就开始轴了,死活绕不出修改一个不相关的地方,触发相同问题, 再次建议相同代码...

换了个模型, 重启对话获得不同回答:

> A: 该错误是因为代码尝试将一个由两个元素组成的元组映射成一个 Vec<usize>，这是不能直接转换的。

要解决这个问题，你需要使用 map 方法中的 unwrap 方法将元组解包，然后将两个元素放入 Vec 中。例如，你可以这样修改代码：

```rust
let pairs_of_rows = rows.windows(2);
let rectangles = pairs_of_rows.flat_map(|pair| {
    let (top, bottom) = pair.unwrap();  // 解构元组
    (0..columns).map(move |column| {
        (top[column], bottom[column])  // 返回一个元组
    })
}).filter(|&(top, bottom)| {
    top < bottom
}).map(|(top, bottom)| {
    vec![top, bottom]  // 在这里创建一个包含两个元素的 Vec
}).collect::<Vec<_>>();  // 将所有 Vec 组合成一个 Vec

```
这样就能避免类型不匹配的错误了。

> Q: 如果对应代码原先是这样的,应该如何修改? 

```rust
    (2..height)
        .combinations(2)
        .map(|(top, bottom)| vec![top, bottom])
```

> A: 原先的代码使用了 itertools::Itertools trait 中的 combinations 方法来选择两个不同的行，得到一个包含两个元素的元组 (top, bottom)，然后通过 map 将其转换为一个 Vec，其中 Vec 包含两个 usize 类型的元素 top 和 bottom。然而，combinations 方法返回的元组是不同于独立的元素的，所以不能直接将其转换为 Vec。

你可以通过使用 map 和 collect 方法来解决这个问题。具体来说，你可以在 map 中解构元组 (top, bottom)，并将它们插入新的 Vec 中，然后再将这些 Vec 收集到一个大的 Vec 中。例如：

```rust
let pairs_of_rows = (2..height)
    .combinations(2)
    .map(|pair| {
        let (top, bottom) = (pair[0], pair[1]); // 解构元组
        vec![top, bottom] // 返回一个包含两个元素的 Vec
    })
    .collect::<Vec<_>>(); // 将所有 Vec 组合成一个 Vec
```
这应该能帮助你将原来的代码转换为一个可以在 Rust 中正确运行的版本。


------
>> 终于打开了思路, 然后获得没有报错的代码:

```rust

    (2..height)
        .combinations(2)
        .map(|pair| {
            let (top, bottom) = (pair[0], pair[1]); // 解构元组
            vec![top, bottom].into_iter() // 返回一个包含两个元素的 Vec
        })
        .flat_map(|mut tb| {
            //let top = tb[0];
            //let bottom = tb[1];
            let top = tb.nth(0).unwrap();
            let bottom = tb.nth(0).unwrap();
            (0..width)
                .combinations(2)
                .map(move |c| (top, bottom, c[0], c[1]))
                .collect::<Vec<_>>()
                .into_iter()
        })
        .filter_map(|(top, bottom, left, right)| {
            if chars[top][left] == b'+'
                && chars[top][right] == b'+'
                && chars[bottom][left] == b'+'
                && chars[bottom][right] == b'+'
                && (top + 1..bottom).all(|i| {
                    matches!(
                        (chars[i][left], chars[i][right]),
                        (b'|' | b'+', b'|' | b'+')
                    )
                })
                && (left + 1..right).all(|j| {
                    matches!(
                        (chars[top][j], chars[bottom][j]),
                        (b'-' | b'+', b'-' | b'+')
                    )
                })
            {
                Some(1)
            } else {
                None
            }
        })
        .sum::<u32>()
```

可惜问题了,这个看起来非常 Rusty 的代码, 无法通过所有 test,
多数案例并没有清点明白所有矩形...

所以....代码复杂不怕, 就怕人看不明白, 难以调试...

## refer.
> 其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...

以及将自己伪装成一个认真又很笨的学员,
GPT 们就可以无限耐心的反复回答所有问题, 当然, 得配套自行检验以及官方文档证实:


- [itertools - Rust](https://docs.rs/itertools/0.10.5/itertools/#crate-features)
    - [Combinations in itertools::structs - Rust](https://docs.rs/itertools/0.10.5/itertools/structs/struct.Combinations.html)
- ...

所以, rust 是故意不折腾复杂的内建模块, 专注提高编译器能力,
其它的各种创新实用 crate 都给社区折腾了...?

```
     _~∽~-~_
 \/ /  - ◵  \ \/
   '_   V   _'
   / '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>chat_arc_threads.md</title><link>https://rs.101.so//101/chat_arc_threads</link><pubDate>Fri, 24 Mar 2023 14:46:44 +0800</pubDate><content:encoded><![CDATA[# 使用Arc 在多线程中共享数据
> 学伴ChatGPT, chatting for debugging ...

## background
> rustlings 第78题:

smart_pointers/arc1.rs

```rust
#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}

```

## goal

完成合理概念摸查...

## trace

> Q: 以上代码如何补全?

> A: 这段 Rust 代码中需要补全的是 shared_numbers 和 child_numbers 变量的定义，使得代码可以正确地计算每个偏移量下的数字和。可以通过使用 Arc 类型来创建共享数据并在每个线程之间共享它。

以下是一个可能的解决方案：

```rust
#![forbid(unused_imports)]
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers); // create shared data
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = Arc::clone(&shared_numbers); // clone shared data for each thread
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
```

在这个解决方案中，我们使用 Arc::new 函数来创建共享数据，然后使用 Arc::clone 函数来为每个线程创建一个共享数据的克隆。在线程内部，我们使用了 child_numbers 变量来访问共享数据，然后通过过滤器和求和来计算每个偏移量下的数字和。最后，我们使用 handle.join() 函数来等待每个线程完成，并使用 unwrap() 函数来处理可能的错误。

> Q: 不是说 clone 将消耗大量资源嘛? 这里有其它方案嘛? 不使用 clone 的话

> A: 是的，每次克隆 Arc 都会增加引用计数，这可能会导致性能问题。为了避免这种情况，我们可以考虑将数据划分成固定大小的块，并将每个块分配给不同的线程。这样可以避免克隆 Arc，同时保持数据的共享。

以下是一种可能的解决方案：

```rust
#![forbid(unused_imports)]
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let chunk_size = numbers.len() / 8;
    let shared_numbers = Arc::new(Mutex::new(numbers)); // create shared data
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let start = offset * chunk_size;
        let end = start + chunk_size;
        let child_numbers = Arc::clone(&shared_numbers); // share the same Arc between threads
        joinhandles.push(thread::spawn(move || {
            let chunk = &child_numbers.lock().unwrap()[start..end]; // acquire lock and get the chunk
            let sum: u32 = chunk.iter().filter(|n| *n % 8 == offset).sum(); // compute the sum
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }

    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}

```

在这个解决方案中，我们首先计算每个块的大小，并使用 Arc::new(Mutex::new(numbers)) 来创建一个包装了 Vec 的 Mutex，以实现共享和线程安全。然后，我们使用 Arc::clone 来为每个线程分配同一个 Arc。在每个线程中，我们使用 lock() 函数获取锁来访问共享数据，并使用切片 &[T] 获取每个线程的块。接下来，我们可以像之前那样计算每个偏移量下的数字和，然后在完成后释放锁。

需要注意的是，Mutex 的使用可能会对性能产生一定的影响。如果共享数据不需要写入，那么可以使用 RwLock 来进行读取操作，因为它可以允许多个线程同时读取数据。

> Q: 不错, 看起来可以运行, 还有其它方案嘛?


> A: 是的，还有一种使用通道（Channel）的解决方案，它可以避免使用共享数据结构和锁，同时保持并发性。在这个方案中，我们将数据划分成固定大小的块，并将每个块发送到一个通道中，然后让每个线程从通道中接收自己的块，并计算每个偏移量下的数字和。

以下是一种可能的解决方案：

```rust
#![forbid(unused_imports)]
use std::sync::mpsc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let chunk_size = numbers.len() / 8;
    let (tx, rx) = mpsc::channel(); // create a channel
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let start = offset * chunk_size;
        let end = start + chunk_size;
        let child_tx = tx.clone(); // clone the channel sender
        let chunk = &numbers[start..end].to_vec(); // create a new vector with a chunk of the data
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = chunk.iter().filter(|n| *n % 8 == offset).sum(); // compute the sum
            child_tx.send(sum).unwrap(); // send the sum back to the main thread
        }));
    }

    drop(tx); // close the sender channel to signal the end of the transmission
    let total_sum: u32 = rx.iter().sum(); // receive the sums and compute the total sum
    println!("Total sum is {}", total_sum);

    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
```
在这个解决方案中，我们首先计算每个块的大小，并使用 mpsc::channel() 函数创建一个通道来传递数据。然后，我们使用 clone() 函数来克隆通道的发送器，以便每个线程都可以发送它们的结果。在每个线程中，我们使用 &numbers[start..end].to_vec() 来创建一个包含块的新向量，并计算每个偏移量下的数字和。接下来，我们使用 send() 函数将结果发送回主线程。在主线程中，我们通过使用 iter() 函数和 sum() 函数来接收所有结果，并计算它们的总和。最后，我们使用 drop() 函数关闭发送器通道，以通知所有接收器线程传输已经结束。

需要注意的是，通道的使用可能会对性能产生一定的影响，因为它涉及到了数据传输和线程间通信的开销。如果要处理大量的数据或者要求非常高的性能，那么可能需要使用其它的并发编程技术来优化程序。

> Q: 不错, 也是个办法, 还有其它方案嘛? 如果使用其它第三方 crate 的话, 有什么建议?


> A: 是的，还有一些第三方 crate 可以帮助我们更方便地编写高效的并发 Rust 代码。

一种常用的 crate 是 Rayon，它是一个基于数据并行性的库，可以轻松地将 Rust 代码转换为并行代码。在 Rayon 中，我们可以使用 par_iter() 函数来创建一个并行迭代器，并将迭代器上的操作并行化。以下是一种可能的解决方案：

```rust
#![forbid(unused_imports)]
use rayon::prelude::*;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let joinhandles = (0..8).into_par_iter().map(|offset| {
        let sum: u32 = numbers.par_iter().filter(|n| *n % 8 == offset).sum();
        println!("Sum of offset {} is {}", offset, sum);
    }).collect::<Vec<_>>();
}
```

在这个解决方案中，我们首先使用 into_par_iter() 函数将 0..8 转换为一个并行迭代器，然后使用 map() 函数对每个偏移量进行操作。在每个操作中，我们使用 par_iter() 函数将 numbers 转换为一个并行迭代器，并使用 filter() 函数过滤出每个偏移量下的数字，然后使用 sum() 函数计算它们的总和。在计算完所有偏移量的和后，程序就可以退出了。

除了 Rayon，还有一些其它的并发库和框架，例如 Crossbeam 和 tokio 等，它们都提供了一些方便的工具和 API 来帮助我们编写高效的并发 Rust 代码。具体使用哪个库，可以根据具体的需求和场景进行选择。

> Q: 看起来都不错, 谢谢,我学习一下

> A: 不用谢，祝你学习愉快！如果你有任何其他问题或者需要进一步的帮助，随时可以问我哦！



## refer.
> 其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...

以及将自己伪装成一个认真又很笨的学员,
GPT 们就可以无限耐心的反复回答所有问题, 当然, 得配套自行检验以及官方文档证实:

- [rayon - crates.io: Rust Package Registry](https://crates.io/crates/rayon)
- [crossbeam - crates.io: Rust Package Registry](https://crates.io/crates/crossbeam)
- [tokio - crates.io: Rust Package Registry](https://crates.io/crates/tokio)
- ...

所以, rust 是故意不折腾复杂的内建模块, 专注提高编译器能力,
其它的各种创新实用 crate 都给社区折腾了...?

```
     _~∽~-~_
 \/ /  - ◵  \ \/
   '_   V   _'
   / '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>chat_heap_stack.md</title><link>https://rs.101.so//101/chat_heap_stack</link><pubDate>Fri, 24 Mar 2023 11:29:16 +0800</pubDate><content:encoded><![CDATA[# 可变/不可变引用态度
> 学伴ChatGPT, chatting for debugging ...

## background
> 李明 coding到灯火阑珊 2023-03-24 06:00

[Rust开发人员经常犯的5个常见错误](https://mp.weixin.qq.com/s/KXfCHeFuLvK8PHAkA5QJmA)

## goal

完成合理概念摸查...

## trace

> Q: rust 代码:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        // 这一行将导致编译错误
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}

```

为什么出错?如何修改? 以及如何理解?

> A:该程序出错是因为 string2 的生命周期比 result 的生命周期短，而 result 是一个指向 string2 中的引用，因此在 string2 离开作用域后，result 指向的内存已经被释放，这会导致未定义的行为。

为了解决这个问题，我们需要让 result 的生命周期比 string2 的生命周期更长。有多种方法可以实现这一点，以下是其中的一种：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    let string2 = String::from("xyz");
    result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);
}
```
在这个修改后的程序中，我们将 string2 的声明移到了 result 的声明之前，并且不再使用一个代码块来限制 string2 的作用域。这意味着 string2 和 result 的生命周期相同，因此 result 仍然有效。

该程序的代码使用了 Rust 的生命周期注释 'a 来告诉编译器 longest 函数的返回值的生命周期应该与 x 和 y 的生命周期相同。

简单地说，程序中的修改让 string2 和 result 具有相同的生命周期，从而解决了问题。

> Q: let string2 = "xyz"; 是否也可以解决相同的问题? 为什么?

> A:是的，如果将 string2 的类型从 String 改为字符串字面量 &str，则程序就可以正确编译和运行。修改后的程序如下：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

字符串字面量在编译时就已经存在于程序的二进制文件中，因此它们的生命周期与程序的生命周期相同，而不需要在堆上分配内存。这意味着它们的生命周期与其他在程序中定义的变量的生命周期相同，因此在使用字符串字面量时不需要担心生命周期的问题。

所以使用字符串字面量作为参数传递给 longest 函数是安全的，因为它们的生命周期已经在编译时确定了，并且与函数中的其他变量的生命周期相同。

> Q: 那么, 为什么 longest() 一定要指定参数的生命周期? 没有其它更加简洁的形式了嘛?

> A: 在 Rust 中，str 是一个字符串 slice 类型，它是一个不可变的、固定长度的引用类型。由于 str 引用的是存储在堆上的字符串数据，因此它的生命周期必须是由该字符串的所有权来决定的。

在 longest() 函数中，x 和 y 的类型是 &'a str，这表示它们是指向某个字符串数据的引用，它们的生命周期被限制为 'a，即函数的生命周期。这是必要的，因为函数的返回值也是一个对字符串数据的引用，它的生命周期必须是在函数返回后才能开始的，而且必须与参数的生命周期相关联，以避免悬垂引用的问题。

如果我们将参数类型改为 str，那么就无法控制它们引用的字符串的生命周期，因为它们不是引用类型。如果我们试图通过将 string1 和 string2 的值进行 clone 来传递它们的副本，这样可能会导致堆分配的额外开销和性能问题，因为这需要为每个字符串分配一个新的内存块，并在函数调用结束后释放这些内存块。

因此，在 longest() 函数中，最好使用字符串 slice 类型 &str，并在调用函数时传递指向原始字符串的引用，以确保在不需要分配额外内存的情况下正确处理字符串。

> Q: 明白了, 如果不考虑性能, 使用 clone 也是可以的

> A: 是的，如果不考虑性能问题，你可以通过使用 clone() 方法来创建传递给 longest() 函数的字符串的拷贝。这将使每个字符串都在堆上分配新的内存，并使 longest() 函数能够接受 String 类型的参数。

例如，可以使用下面的代码来调用 longest() 函数，使用 clone() 方法创建了 string1 和 string2 的副本：

```rust

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);

    // Create clones of the strings and pass them to longest()
    let string3 = string1.clone();
    let string4 = string2.clone();
    let result2 = longest(string3.as_str(), string4.as_str());
    println!("The longest string is {}", result2);
}

```
注意，这种方法可能会产生性能问题，因为每次调用 clone() 方法都会分配新的内存并复制字符串的内容。因此，如果性能是一个问题，最好避免使用 clone() 方法来创建字符串的副本。


> Q: 明白了, 那么 堆与栈的本质区别是什么? 为什么 rust 对栈这么信任, 对堆却很警惕?

> A: 在计算机科学中，堆和栈都是内存中用于存储程序数据的数据结构。它们之间的本质区别在于它们的内存分配方式和数据存储的生命周期。

栈是一种先进后出的数据结构，它使用固定大小的内存块来存储程序数据。当一个函数被调用时，该函数的参数、局部变量和返回地址等数据将被存储在栈帧中。当函数返回时，该栈帧将被弹出，其中存储的数据也将被销毁。由于栈内存的分配和释放是由程序自动进行的，因此它们的效率非常高。

堆是一种动态的数据结构，它使用不连续的内存块来存储程序数据。堆内存的分配和释放是由程序员手动管理的，它们的效率相对较低。由于堆内存的生命周期不像栈那样易于确定，因此在使用堆内存时需要注意内存泄漏和悬垂指针等问题。

在 Rust 中，栈上的数据是可以直接在栈帧中进行分配和释放的，因此 Rust 对栈的管理非常信任。但是，由于堆上的数据需要手动管理，因此在 Rust 中对堆的管理要更加警惕，以避免内存泄漏和悬垂指针等问题。因此，在 Rust 中使用堆内存时，必须遵循所有权规则，以确保每个值都有且只有一个所有者，并在所有者超出作用域时自动释放其内存。这也是 Rust 中所有权系统的核心概念。


> Q: 那么, rust 内建数据类型中, 哪些是栈, 哪些是堆?

> A: 在 Rust 中，内建数据类型可以分为两类：栈上分配的值和堆上分配的值。

以下是一些常见的栈上分配的值：

- 所有基本数据类型（例如整数、布尔值和浮点数）
- 数组和元组（当它们包含栈上分配的值时）
- 函数和闭包

以下是一些常见的堆上分配的值：

- 所有标准库集合类型，例如 Vec、String 和 HashMap 等
- Box 智能指针和 Rc 引用计数指针
- 闭包（如果它们捕获了堆上分配的值）


需要注意的是，Rust 中的**所有类型都可以在堆上分配，只要使用堆分配器**（如 Box、Vec 或者 String）即可。但是，所有权系统确保这些堆上分配的值仍然遵循所有权规则，以确保内存安全。


> Q: 明白了, 也就是说 String::from("xyz") 是堆上内存, 但是, "xyz" 是栈上内存,
那么, 为什么都是生成不可变字符串, 为什么 Rust 要构建出堆上字符串 String::from("xyz") ?
问题是 String::from("xyz")  有什么比 "xyz" 的好处?


> A: 是的，您的理解是正确的。"xyz" 是一个编译时常量，分配在程序的栈上，它是一个静态分配的不可变字符串。而 String::from("xyz") 是在运行时动态分配的堆上的一个不可变字符串。

Rust 之所以提供 String 类型，是因为它具有以下一些优点：

- 动态长度：在堆上分配一个字符串，它的长度可以在运行时根据需要动态增加或减少，这是栈上分配的静态字符串所不能做到的。
- 丰富的字符串处理功能：String 类型提供了各种字符串处理功能，例如拼接、切割、查找、替换等。
- UTF-8 编码：Rust 中的字符串类型都是基于 UTF-8 编码的，这意味着它们可以表示世界上几乎所有语言中的字符，包括非拉丁字符集，而不会出现编码问题。


但是，由于动态分配内存涉及到堆的使用，这会带来一些额外的开销和复杂性。因此，在编写 Rust 代码时，应该尽可能地使用栈上分配的数据类型来避免堆分配的开销。仅当需要动态长度或其他特殊功能时，才应该使用堆上分配的类型。


## refer.
> 其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...

以及将自己伪装成一个认真又很笨的学员,
GPT 们就可以无限耐心的反复回答所有问题, 当然, 得配套自行检验以及官方文档证实:


- [什么是所有权？ - Rust 程序设计语言 简体中文版](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap)
- [生命周期基础 - Rust By Practice( Rust 练习实践 )](https://zh.practice.rs/lifetime/basic.html)
- [字符串：str和String - Rust入门秘籍](https://rust-book.junmajinlong.com/ch3/04_str_string.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F)
- [理解Rust内存管理 - Rust入门秘籍](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - [堆空间和栈空间 - Rust入门秘籍](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - [箱子、栈和堆 - 通过例子学 Rust 中文版](https://rustwiki.org/zh-CN/rust-by-example/std/box.html)
    - ...
- [使用Box<T> 指向堆上数据 - Rust 程序设计语言 简体中文版](https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE)


```
     _~`|~~_
 \/ /  = →  \ ()
   '_   ∧   _'
   / '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item></channel></rss>