<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>be Rustaceans ~ 成锈纪</title><link>https://rs.101.so</link><description>~ 汇集 大妈/Zoom.Quiet 学习/实践/探索/... Rust 世界锈迹, 一起成为 Rustacean 吧...</description><generator>my_rss_generator</generator><item><title>oop-2-polymorphism.md</title><link>https://rs.101.so//tip/oop-2-polymorphism</link><pubDate>Wed, 08 Mar 2023 22:38:06 +0800</pubDate><content:encoded><![CDATA[# Rust 超越面向对象,第2部分
原文:[Rust Is Beyond Object-Oriented, Part 2: Polymorphism :: The Coded Message](https://www.thecodedmessage.com/posts/oop-2-polymorphism/)


## 快译

在这篇文章中, 通过讨论 OOP 三大传统支柱中的第二个: 多态,
继续系列文章:关于 Rust 和传统 OOP 范式的不同;

多态性是面向对象编程中的一个特别重要的话题，
也许是其三大支柱中最重要的一个;
关于多态性是什么, 各种编程语言如何实现(在 OOP 世界内外---是的,多态性也存在于 OOP 宇宙之外),
如何有效的使用, 以及更加关键的何时嫑使用;
可以写一些关于如何单独使用多态的 Rust 版本的书了;

不幸的是, 这只是一篇 blog,所以,
我无法像我想的那样详细或是多样性的介绍多态;
相反,我将特别关注 Rust 和 OOP 概念的不同之处;
我将从描述其在 OOP 中的工作方式开始,
然后, 讨论如何在 Rust 中实现相同的目标;

在 OOP 中,多态性就是一切;
试图采取所有决策(或是尽可能多的决策)并将其统一在一个通用的狭义机制中:
运行时多态;
但是, 不幸的是, 并不是任意运行时多态, 而是一种特定的/狭义的运行时多态形式,
受到 OOP 哲学和实现如何工作细节的限制:

- 间接需求: 每个对象通常都必须存储在堆上,才能使运行时多态生效, 因为,不同的"运行时类型"具有不同的尺寸; 这鼓励了可变对象的别名使用;不仅如此,要真正调用一个方法,必须穿过三层间接:
    - 解引用对象引用
    - 解引用类指针或是 “vtable” 指针
    - 最后完成间接函数调用
- 排斥优化: 除了间接函数调用的内在成本之外, 调用是间接的这一事实, 意味着内联是不可能的；通常,多态方法很小,甚至于微不足道,例如返回常量/设置字段或是重新排列参数并调用另一个方法, 因此, 内联会很有用; 内联对于允许优化跨内联边界也很重要;
- 仅能在单一参数上多态: 特殊的接收者参数,称为 self 或是 this, 是运行时多态也的并上通常可能通过的唯一参数; 其它参数的多态可以用那些类型中的辅助方式来模拟, 这就很尴尬, 而且, 返回类型的多态也是不可能的;
- 每个值都是独立多态的: 在运行时多态中, 通常没有办法说集合的所有元素都属于实现相同接口/interface 的某种类型 T,但是, 该类型是什么又应该在运行时能确定;
- 和其它 OOP 特性纠缠在一起: 在 C++ 中,运行时多态和继承紧密耦合；　在很多 OOP 语言中, 多态仅适用于类的类型, 正如我在上篇 blog 中讨论的那样, 类类型是一种受约束的模块形式;

其实我完全可以针对以上每条吐糟单独写一大篇文章 --- 也许有一天真的会;

不过,尽管有这么多限制, 多态仍然被视为使用 OOP 语言进行决策的首选方式,
并且, 特别直观且易于访问;
受过训练的程序员, 嘦可能就一定使用此工具,
无论是否是手上决策是最佳工具, 即便当前不需要用多态进行运行时决策;
有些编程语言,例如 Smalltalk 甚至折叠了 "if-then" 逻辑,
并循环到 this 这个奇怪的特定决策结构中,
通过多态方法(如: ifTrue:idFalse)最终实现,
这些方法将在 True 和 False 类中以不同方式再实现
(和 therefore 在 true 以及 false 对象上配套);

需要明确的是, 拥有基于 vtable 的运行时多态性机制本身并不是一件坏事儿 --- Rust 甚至有也一个
(和上述 OOP 版本相似,但是,并不完全对等);
但是, Rust 版本只用以相对罕见的情况, 在这种情况中,
该机制最适合整个儿 palette 机制;
在 OOP 中, 将这种严格约束且忾和用低下的决策制定形式提升到所有其它形式之上,
以及使用多态是表达程序注释和业务编辑的最佳方式以及最直观方式的哲学断言,
本身就是个问题;

事实证明,当你选择最适合手头情况的工具时, 编程更加吻合人体工程学 --- 而 OOP 运行时多态性,
只是偶尔才是最合适完成当前工作的实效工具;

因此, 让我们看看在 OOP 使用运行时多态性时, 可以使用的 Rust 版四种替代方案;




### 备选方案#0：枚举

不仅有其它形式的多态性, 而且具有更少的严格约束
(例如 Haskell 的类型类)或一组不同的权衡
(例如 Rust 的 trait,主要基于 Haskell 类型类),
Rust 中还有另外一个决策系统, 即:代数数据类型(ADTs, algebraic data types)
或曰求合/sum 类型,
也能接管 OOP 样式多态的很多应用程序;

在 Rust 中, 这些被称为 枚举/enums;
很多编程语言中的枚举是存储在整数尺寸类型中的常量列表,
有时以类型安全的方式实现(比如在 Java 中),
有时不是(比如在 C 中),
有时可以使用任何一种选项(比如,在 C++ 中枚举和枚举类之间就有区别);

Rust 枚举支持这种熟悉的用例, 而且具有类型安全:


```rust
pub enum Visibility {
    Visible,
    Invisible,
}
```

但是, 还支持和每个选项关联的附加字段,
创建类型理论中称为"总和类型"(sum type)的东西,
但在 C 或是 C++ 程序员中更加广为人知识的叫"联合标记"(tagged union)
--- 不同之处在于, Rust 中, 编译器知道并能强制执行标记;

以下是一些枚举声明的示例:


```rust
pub enum UserId {
    Username(String),
    Anonymous(IpAddress),
    // ^^ This isn't supposed to be a real network type,
    // just an example.
}

let user1 = User::Username("foo".to_string());
let user2 = User::Anonymous(parse_ip("127.0.0.1")?);

pub enum HostIdentifier {
    Dns(DomainName),
    Ipv4Addr(Ipv4Addr),
    Ipv6Addr(Ipv6Addr),
}

pub enum Location {
    Nowhere,
    Address(Address),
    Coordinates {
        lat: f64,
        long: f64,
    }
}

let loc1 = Location::Nowhere;
let loc2 = Location::Coordinates {
    lat: 80.0,
    long: 40.0,
};
```

你可能会问,这些`联合标记`和多态有什么关系?
好吧, 大多数 OOP 语言对于这些 求合类型/sum type 没什么好办法,
但是, 她们确实有强大的运行时多态机制,
所以, 你会看到运行时多态用 Rust 枚举实现也是一样的适合
(我可能进一步争辩: 更加合适):
每当有一些小关于如何协商会议值的选项, 但是,这些选项又包含不同细节时;

比如, 这是一种使用继承和运行时多态在 Java 中表示 UserId 类型的方法 --- 当我还是学生时, 
肯定会这么来(将每个类放在不同的文件中):


```java
class UserId {
}

class Username extends UserId {
    private String username;
    public Username(String username) {
        this.username = username;
    }

    // ... getters, setters, etc.
}

class AnonymousUser extends UserId {
    private Ipv4Address ipAddress;
    
    // ... constructor, getters, setters, etc.
}

UserId user1 = new Username("foo");
UserId user2 = new AnonymousUser(new Ipv4Address("127.0.0.1"));
```

重要的是, 就像在枚举示例中一样,
我们可以将 user1 和 user2 给定相同类型的变量,
并将她们得狮给相同类型的函数, 并通常对她们执行相同的操作;

现在这些 OOP 风格的类看起来轻飘到飞溅的程度,
但是, 这主要是因为我们没有为这种情况添加任何真正的操作代码 --- 只有数据和结构, 
以及一些变量定义和模板;
让我们考虑一下, 如果我们真的对用户 ID 尝试进行任何操作时会怎么样?

例如,我们可能想确认她们是否为管理员;
在我们的假设中, 假设匿名用户永远不是管理员,
而拥有用户名的用户只有在用户名以字符串 admin_ 开头时,才是位管理员;

理论上认可的 OOP 方法是添加一个方法,
比如: administrator;
为了让这个方法起作用, 我们必须将其追加到所有三个类: 基数以及两个子类:

```java
class UserId {
    // ...
    public abstract bool isAdministrator();
}

class Username extends UserId {
    // ...
    public bool isAdministrator() {
        return username.startsWith("admin_");
    }
}

class AnonymousUser extends UserId {
    // ...
    public bool isAdminstrator() {
        return false;
    }
}
```

因此, 为了在 Java 中为这种类型添加这种简单的操作,如此简单的能力,
我们却必须使用三个类,
而且必须存储在三个文件中;
丫们每个对象都包含一个方法来作一些简单的事儿,
但是, 在任何羌族都看不到谁是管理员, 又或者不是管理员的完整逻辑 --- 有人可能会很不合时宜的问出这个问题;

Rust 则为这种操作使用 match,
将有关所有信息放在一个地方完成判定:


```rust
fn is_administrator(user: &UserId) -> bool {
    match user {
        UserId::Username(name) => name.starts_with("admin_"),
        UserId::AnonymousUser(_) => false,
    }
}
```

诚然, 这将产生更加复杂的单个函数,
但是,具有明确的所有逻辑;
让编辑明显而不是隐含在继承屡次结构中, 
这就违反了 OOP 原则, 
在 OOP 宇宙中, 方法应该简单, 多态性用于隐含的表达逻辑;
但是,这并不能保证任何事儿, 只是将其扫到地毯下而已:
事实证明, 隐藏复杂性会令其更难应对, 而不是相反;

让的我们来看另外一个例子;
我们已经用了一段时间的 UserId 代码,
你的任务是为这个系统编写一个新的 Web 前端;
你需要某种方式, 以 HTML 格式显示用户信息,
要么是指向用户配置文件的链接(对于指定用户),
要么是将 IP 地址字符串化为红色(对于匿名用户);
因此, 你决定为这个小型类型追加一个新操作 toHTML,
将输出新前端的专用 DOM 类型;
(也许 Java 被编译为 WebAssembly 呢? 我也不确定,不过细节不重要;-)


你逈后端核心库深入的 UserId 类屡次结构的维护者提交了 pull request;
然后, 他们拒绝了;

事实上, 他们有很好的理由, 你必须勉强承认;
他们说:"这是一种荒谬的关注点分离";
此外, 公司也无法从你的前端获得此核心库处理类型;

所以, 你叹了口气, 写了个 Rust 匹配表达式的等价物, 但是用的是 Java
(请原谅我荒谬的假设有个 HTML 库):


```java
Html userIdToHtml(UserId userId) {
    if (userId instanceof Username) {
        Username username = (Username)userId;
        String usernameString = username.getUsername();
        Url url = ProfileHandler.getProfileForUsername(usernameString);
        return Link.createTextLink(url, username.getUsername());
    } else if (userId instanceof AnonymousUser) {
        AnonymousUser anonymousUser = (AnonymousUser)userId;
        return Span.createColoredText(anonymousUser.getIp().formatString(), "red");
    } else {
        throw new RuntimeException("IDK, man");
    }
}
```

你的老板们在代码审查时拒绝了这段代码,
你你使用了 instanceof 反模式,
但是, 后来在你让他们和不接受你的其它补丁的核心库维护者争论之后,
丫们勉强接受了这段代码;

但是, 看看那坨 instanceof 代码有多难看!
难怪 Java 程序员认为这是一种反模式!
但是, 在这种情况中, 已经是最合理的事儿了,
实际上, 是除了实施观察者东西方或是访问者模式又或是其它相当于基础设施的东西之外,
唯一可能的实现, 只是用来创造具有控制反转的实例而已;

当操作集有界(或是接近有限)并且该类的子类数量可能以意想不到的方式增长时,
通过向每个子类追加一个方法来实现操作是有意义的;
可是,通常情况中, 操作的数量又会以意想不到的方式增长,
而子类的数量总是有限的(又或是接近有限);

对于后一种情况, 这种情况比 OOP 拥护者想象的更加常见,
Rust 枚举 --- 以及一般的 求和类型 --- 是完美的;
一但你习惯了她们, 你就会发现自己一直在使用;

我要郑重声明,
在所有面向对象的编程语言中,都没有这么糟糕;
在某些情况中, 你可以按任何顺序编写任意类方法组合,
因此,如果你愿意, 可以将所有三个实现写在一个地方;
Smalltalk 传统上允许你在一个特殊的浏览器中游览代码库,
你可以在其中看到一个类实现的方法列表,
或者一个接受给定"消息"的类列表,
正如 Smalltalk 所说的那样,
这样你就可以随心所欲的操弄对象了;

(译按: 当然, 你必须在 Salltalk 对应解释器的 IDE 环境中, 一但出了这个对象镜像, 将失去一切观察能力, 这导致 Smalltalk 没办法使用其它传统 IDE)



### 备选方案 #1: 闭包
> Alternative #1: Closures

有时, 一个 OOP 接口或是多态决策只涉及一个实际操作;
在这种情况中,只能使用闭包;

我不想在这方面花太多时间,
因为, 大多数 OOP 程序员已经意识到这点,
并且, 自从他们的 OOP 语言已经赶上了函数式语言,
并获得了 lambda 语法 --- Java 中的 Java 8 ,
C++ 中的, C++11;
因此, 像 Java 的 Comparator 这种愚蠢的单一方法接口 ---
幸运的是 --- 基本上已经都感染过去式了;

此外, Rust 中的闭包在技术上涉及 traits,
因此,使用和接下来的两个替代方案相同的机制来竀,
所以,也有人可能会争辩说这在 Rust 中并不是真正的独立选项;
然而,在我看来 lambda/闭包和
FnMut/FnOnce/Fn 等 trait 们在美学上和情境上都非常特别,
值得花点时间掌握;

因此, 我将花些时时间来说明这点:
如果你发现自己只使用一种方法编写 trait 
(Java 接口或是 C++ 类),
请考虑你是否应该改用某种闭包或是 lambda 类型;
毕竟只有你自己才能防止过度设计;

### 备选方案#2: 具有Traits的多态

就像 Rust 有个比 OOP 类概念更加灵活/强大的封装版本,
正如在上篇文章中讨论的那样,
Rust 有一个比 OOP 假设更加强大的多态版本: trait;

trait 就像来自 Java 的接口
(又或是 C++ 中的全抽象超类),
但是,并没有我在文章开头指出的大部分限制;
trait 即没有语义约束, 也没有性能约束;
trait 在语义和原理方面深受 C++ 模板的启发;
C++ 程序员可以将其视为带有concepts/概念的模板
(除非设计的,从一开始就融入编程语言,
而且不必要处理所有不使用它的代码;)

让我们从语义开始:
你可以使用 trait 完成那些无法使用纯 OOP 完成的,
即便你将世界上所有的间接调用都丢给她?
好吧, 在纯粹的 OOP 术语中,
是无法编写像 Rust Eq 和 Ord 这样的接口,
这里给出了非常简单的定义
(Eq 和 Ord 的真正定义在于拓展了其它允许不同类型之间的部分等价和排序的类,
但是, 像这种简化定义,
非部分 Eq 和 Ord 的 Rust 标准库版本确定涵盖了相同类型值之间的等价和排序):


```rust
trait Eq {
    fn eq(self, other: &Self) -> bool;
}

pub enum Ordering {
    Less,
    Equal,
    Greater,
}

trait Ord: Eq {
    fn cmp(&self, other: &Self) -> Ordering;
}
```

看看发生了什么?
就像在 OOP 风格的接口中一样,
这些无法采用 Self 类型的“接受者”类型,
一个 self 秋粮 -- 也就是说,任何实现 trait 的具体类型
(技术上这里是对 Self 或 &Self 的引用);
但是, 和 OOP 风格的接口不同,
这里还能采用另外一个 &Self 类型的参数;
为了实现 Eq 和 Ord,
类型 T 提供了一个函数,
该函数接受对 T 的两个引用;
字面上的意思是: 对 T 的两个引用, 而不是对 T 的一个引用和对 T 或是任何子类的一个引用
(这样的事情在 Rust 中并不存在),
不是对 T 的一个引用和对实现 Eq 的任何其它值的一个引用,
而是对同一具体类型的两个真正的非异构引用,
然后，函数就可以比较她们是否相等(或是进行排序);

这点很就将要,因为,
我们想用这种能力来实现像排序这类方法:

```rust
impl Vec<T> {
    pub fn sort(&mut self) where T: Ord {
        // ...
    }
}
```

OOP-样 多态非常适合异构容器,
其中每个元素都有自己的运行时类型和自己的接口实现;
但是, sort 并不是那样工作的;
你不能对类似 `[3, "Hello", true]; ` 这种集合进行排序;
所有类型都没有合理的顺序;

相反 sort 在同类容器上运行;
所有元素的类型必须匹配, 以便可以相互比较;
他们并不需要每种类型都要有不同的操作实现;

尽管如此, 排序仍然是多态的;
排序算法对于整数和字符串是相同的,
但是, 比较整数和比较字符串是完全不同的操作;
排序算法需要一种方法来调用对其项目的操作 --- 比较 --- 对于不同的类型必须不同,
同时仍然得具有相同的整体代码结构;

可以通过注入一个比较函数来完成,
但是, 很多类型都有一个内在/默认的排序,
而且, 就应该默认使用这个排序;
因此, 多态 --- 并不是 OOP 友好的变体;

请参考以下 Java 定义排序的声明:


```java
static <T extends Comparable<? super T>> 
void sort(List<T> list)
```

并没有简单的 trait 能要求 T 和其它 T 具有可比性,
以便对 T 进行排序;
相反, 就编程语言而言, T 和其自身而不是任何其它随机类型可比的查清只是作为此方法的一个偶然事件而阐明;
打有什么可以阻止某人以不一致的方式现实 Comparable 接口,
例如让 Integer 实现 `Comparable<String>`;

(译按: 作死小能手, 说的就是人类自身, 无论出于什么动机,代码只是文本,
对文本当然可以进行任何修改;)

此外, 当实际查找 Comparable 实现时,
Rust 将会根据任何比较的第一个参数而不是类型来测定使用什么实现;
通常,她们都是相同类型,
得是不是, 理论上这个列表可以是异构的,
嘦所有对象都 “extend” T,
并且可以实现不同的 Comparable;
计算机必须作额外工作来满足这种可能性,
即便, 这肯定是一个错误;

(译按: 特别是动态语言中, 将用户视为心理不够成熟的小朋友,
尽可能友善/专业/高级/良好/...的猜测用户行为,
并积极将所有异构数据进行合理转换, 以便完成排序...)

由于现在我们已经在脱离语义领域，进入性能领域，
让我们来全面讨论一下性能实现；

正如我们提及的, Java 排序方法要求集合中的每个项目都是完整的对象类型,
这意味着不是将值直接存储在数组中，而是在堆中,
而引用存储在数组中;
这奵基于 trait 的方法是不必要的---值可以直接存在于数组中;

这意味着不同的数组将具有不同的元素大小,
因此, 这也必须由 trait 来处理;
也就是: 值的大小也通过 Size 的 trait 参数化;
大小必须在数组的所有项目间保持一致,
但是,这是可执行的,因为,我们可以表达所有元素实际上是完全相同类型
---不像 Java 的 Linst<T> 只表达它们是 T 类型或是 T 的某些子类型;

Rust 的排序方法可以通过在运行时将大小信息(来者 Sized 的 trait)
和排序函数(来自 Ord trait)作为整数值和函数指针传递来实现;
这就是类型类在 Haskell 中的工作方式,
这是 Rust trait 本身灵感来源;
这俨然比 Java 更有效,
因为,只有一个排序函数,而不是对比较的每个左进行不同的间接查找,
从而允许间接分支预测在处理器中能工作;

但是, Rust 比这更进一步, 通过单态化来实现 trait;
这类似 C++ 中模板实例化,
但是, 在语义上受到更好的约束;
前提是虽然 sort 在语义上只是一种方法,
但是,在输出的编译代码中,
将为调用她的每个类型 T 输出不同版本的 sort;

C++ 模板会创建臭名昭著的错误消息,
并且难以推理, 因为, 丫们本质上是宏,
而且是笨拙的宏;
即便是 Rust 也不能用自己的宏系统创建很好的错误消息;
而且,编写宏需要专业知识,
这意味着程序员将放弃类型系统的很多处 --- 在我看来,
模板通常被称为编译时 duck 类型的一种形式;
由于这些原因, C++ 中的模板编程通常被认为比 OOP 样式的多态更高级
(也就是说, 读起来更难/更不方便, 而不是更强大);

然而, 在 Rust 中, trait 提供了一种有组织且更连贯的方式来访问类似技术,
获得模板的性能优势,
同时仍然提供可靠类型系统的结构;



### Alternative #3: Dynamic Trait Objects
Sometimes, however, you do need full run-time polymorphism. You have the opposite of the scenario with the enum: You have a closed set of operations that can be performed on a value, but what those operations actually do will change dynamically in a way that cannot be bounded ahead of time.

In such situations, Rust has you covered with the dyn keyword. Please don’t overuse it, though. In almost all situations where I’ve thought it might be appropriate, static polymorphism combined with other design elements have worked out better.

Legitimate use cases for dyn tend to come up in situations involving inversion of control, where a framework library takes on a main loop, and the client code says how to handle various events. In network programming, the framework library says how to juggle all the sockets and register them with the operating system, but the application needs to say what to actually do with the data. In GUI programming, the framework code can say what widget was being clicked on, but very different things happen if that widget is a button versus a text box versus a custom widget you invented for this particular app.

Now, you don’t strictly need run-time polymorphism for this. You could use closures (or even raw function pointers) instead, creating struct of closures (or function pointers) if multiple operations are called for – which amounts to basically doing what dyn does the hard way by hand. For example, I fully expected tokio to use Rust’s run-time polymorphism feature internally to handle this inversion of control in task scheduling. Instead, for what I imagine are performance reasons, tokio implements dyn by hand, even calling its struct of function pointers Vtable.

But dyn does all of this work for you, for your trait. The only requirement is that your trait be object-safe, and the list of requirements may seem familiar, especially when it comes to the requirements for an associated function (e.g. a method) to be “dispatchable”:

------

- Not have any type parameters (although lifetime parameters are allowed),
- Be a method that does not use Self except in the type of the receiver.
- Have a receiver with one of the following types:
    - &Self (i.e. &self)
    - &mut Self (i.e &mut self)
    - Box<Self>
    - Rc<Self>
    - Arc<Self>
    - Pin<P> where P is one of the types above
- Does not have a where Self: Sized bound (receiver type of Self (i.e. self) implies this).

------



That is to say, it can be polymorphic in exactly one parameter, and that parameter must be by reference – more or less the exact requirements for methods to support run-time polymorphism in OOP.

This is of course because dyn uses almost exactly the same mechanism as OOP to implement run-time polymorphism: the “vtable.” Box<dyn Foo> really contains two pointers rather than one, one to the object in question, and the pointer to the “vtable,” the automatically-generated structure of function pointers for that type. The one-parameter requirement is because that is the parameter whose vtable is used to look up which concrete implementation of a method to call, and the indirection requirement is because the concrete type might be different sizes, with the size only known at run-time.

To be clear, these are limitations on one particular implementation strategy for run-time polymorphism. Alternative strategies exist that fully decouple the vtable from individual values of the type, as in Haskell.

There are still a few advantages of Rust’s version of run-time polymorphism with traits as opposed to OOP-style interfaces.

Performance-wise, it’s something done alongside a type, rather than intrinsic to the type. Normal values don’t store a vtable, spreading the cost of this throughout the program, but rather, the vtables are only referenced when a dyn pointer is created. If you never create a dyn pointer to a value of a given type, that type’s vtable doesn’t even have to be created. Certainly, you don’t have 8 bytes of extra gunk in every allocation for all the vtable pointers! This also means there’s one fewer level of indirection.

Semantically, it’s also a good thing that it’s just one option among many, and that it’s not the strongly preferred option that the entire programming language is trying to push you towards. Often, even usually, static polymorphism, enums, or even just good old-fashioned closures more accurately represent the problem at hand, and should be used instead.

Finally, the fact that run-time and static polymorphism in Rust both use traits makes it easier to transition from one system to another. If you find yourself using dyn for a trait, you don’t have to use it everywhere that trait is used. You can use the mechanisms of static polymorphism (like type parameters and impl Trait) instead, freely mixing and matching with the same traits.

Unlike in C++, you don’t have to learn two completely different sets of syntax for concepts vs parent classes, and vastly different semantics. Really, in Rust, dynamic polymorphism is just a special case of static polymorphism, and the only differences are the things that actually are different.


## logging

- 230215 ZQ init.



```
         _~^&∽~_
     \/ /  O ^  \ \/
       '_   v   _'
       / '--#--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>chatgpt101.md</title><link>https://rs.101.so//101/chatgpt101</link><pubDate>Wed, 08 Mar 2023 15:32:57 +0800</pubDate><content:encoded><![CDATA[# 伴学ChatGPT
> chatting for debugging ...

## background

通过网络中各种免费教程/图书学习时,
作者文字背后的思考过程无法交流...

## goal

合理使用 ChatGPT 进行提示工程style 学习

## trace
> 记录各种舒服的姿势:


### CLI 测试姿势
```rust
se assert_cmd::Command;
use predicates::prelude::*;
use std::fs;

type TestResult = Result<(), Box<dyn std::error::Error>>;

#[test]
fn dies_no_args() -> TestResult {
    let mut cmd = Command::cargo_bin("echor")?; 
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("USAGE"));
    Ok(()) 
}

#[test]
fn hello1() -> TestResult {
    let expected = fs::read_to_string("tests/expected/hello1.txt")?;
    let mut cmd = Command::cargo_bin("echor")?;
    cmd.arg("Hello there").assert().success().stdout(expected);
    Ok(())
}
```

> Q:

以上代码中, 为什么要专门定义 TestResult 类型?

> GPT:

在 Rust 中，测试函数必须返回 Result<(), Box<dyn std::error::Error>> 类型。这是因为测试框架需要处理测试函数中可能出现的错误，并将这些错误转换为测试结果。如果测试函数返回的是一个普通的错误类型，测试框架无法对其进行处理，因此需要使用 Result 类型。TestResult 类型只是为了更清晰地表明这是一个测试函数返回的结果类型，并没有特殊的含义。

> Q:

Result<(), Box<dyn std::error::Error>> 这一类型, 具体有什么要求?

> GPT:

Result<(), Box<dyn std::error::Error>> 是 Rust 中测试函数的标准返回类型。具体要求如下：

- 返回类型为 Result，表示测试函数可以返回成功或失败的结果。
- () 表示测试函数不返回任何值，因为测试函数的目的是验证代码的行为是否正确，而不是生成有用的输出。
- Box<dyn std::error::Error> 表示测试函数返回的错误类型可以是任何实现了 std::error::Error trait 的类型，而且这个类型被包装在 Box 中。这是因为测试框架需要能够处理各种可能的错误类型，包括编译错误、运行时错误等等。使用 Box<dyn std::error::Error> 可以使测试函数返回任何实现了 std::error::Error trait 的错误类型，同时又能够在测试框架中方便地处理这些错误。

总之，Result<(), Box<dyn std::error::Error>> 表示测试函数可以返回成功或失败的结果，不返回任何值，但是可以返回任何实现了 std::error::Error trait 的错误类型。

> Q:

任何实现了 std::error::Error trait 的错误类型 一般有什么类型包含这种 trait? 能举例说明嘛?

> GPT:

任何实现了 std::error::Error trait 的类型都可以作为测试函数返回的错误类型。在 Rust 中，标准库中的很多错误类型都实现了 std::error::Error trait，例如：

- std::io::Error：表示 I/O 操作中可能出现的错误，如文件读写错误、网络通信错误等。
- std::num::ParseIntError：表示将字符串转换为数字时可能出现的错误，如字符串不符合数字格式等。
- std::env::VarError：表示获取环境变量时可能出现的错误，如环境变量不存在等。
- serde_json::Error：表示处理 JSON 数据时可能出现的错误，如 JSON 数据格式错误等。

这些类型都实现了 std::error::Error trait，因此可以作为测试函数返回的错误类型。在测试函数中，如果某个操作出现了这些错误，可以将错误包装成 Box<dyn std::error::Error> 类型返回，这样测试框架就可以处理这些错误并将其视为测试失败。

> Q:

如果要为自定义新数据类型追加这种 trait 有哪些可行方案? 举例说明一下?

> GPT:

如果要为自定义的新数据类型追加 std::error::Error trait，有以下几种可行的方案：


- 实现 std::error::Error trait：在新数据类型的实现代码中手动实现 std::error::Error trait，包括实现 description 方法和 source 方法。这样就可以将新数据类型作为测试函数的错误类型返回。例如：


```rust
use std::error::Error;

#[derive(Debug)]
struct MyError {
    message: String,
}

impl std::fmt::Display for MyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for MyError {
    fn description(&self) -> &str {
        &self.message
    }

    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let result = Err(MyError {
        message: "An error occurred".to_owned(),
    });
    result.map_err(Box::new)?;
    Ok(())
}
```

- 使用 thiserror crate：thiserror 是一个 Rust crate，它提供了一种更简单的方法来实现 std::error::Error trait。使用 thiserror crate 可以通过宏来自动生成错误类型的实现代码，包括实现 std::error::Error trait。例如：

```rust
use std::error::Error;
use thiserror::Error;

#[derive(Debug, Error)]
#[error("An error occurred: {message}")]
struct MyError {
    message: String,
}

fn main() -> Result<(), Box<dyn Error>> {
    let result = Err(MyError {
        message: "An error occurred".to_owned(),
    });
    result.map_err(Box::new)?;
    Ok(())
}

```
... 在上面的代码中，使用 thiserror crate 定义了一个 MyError 类型，通过 #[derive(Error)] 宏自动生成了实现 std::error::Error trait 的代码。此时，MyError 类型就可以作为测试函数的错误类型返回了。

无论使用哪种方法，一旦为新数据类型追加了 std::error::Error trait，就可以将其作为测试函数的错误类型返回了。例如，下面是使用自定义错误类型进行测试的示例：

```rust
use std::error::Error;

#[derive(Debug)]
struct MyError {
    message: String,
}

impl std::fmt::Display for MyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for MyError {
    fn description(&self) -> &str {
        &self.message
    }

    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
}

fn foo() -> Result<(), Box<dyn Error>> {
    Err(MyError {
        message: "An error occurred".to_owned(),
    })
}

#[test]
fn test_foo() -> Result<(), Box<dyn Error>> {
    let result = foo();
    assert!(result.is_err());
    Ok(())
}
```


### crate 思路

> Q:

如何将一个 CLI 工具项目发布为一个 crate? 要进行哪些改造? 以及要注意什么?

> GPT:


要将一个 CLI 工具项目发布为一个 crate，你需要进行以下步骤：

- 将你的 CLI 工具项目打包成一个库。在 Rust 中，库文件通常以 lib.rs 文件为入口点，并将 CLI 代码重构为函数或结构体方法。这样可以将你的代码解耦，并使其更易于测试和重用。
- 在你的项目根目录中创建一个 Cargo.toml 文件，其中包含以下信息：
    - 包的名称、版本号和作者信息。
    - 项目的描述信息。
    - 项目的依赖项和其版本要求。
    - 包的类型，例如库或二进制文件。
    - 包的许可证类型。
- 将你的代码上传到 crates.io。首先，你需要创建一个 crates.io 帐户。然后，你可以使用 cargo login 命令登录并上传你的代码。在上传前，确保你的代码已经完成了测试，并且包含了合适的文档和许可证信息。
- 给你的 crate 添加文档。Rust 社区非常注重代码文档，因此你需要确保你的 crate 包含了适当的文档和注释。你可以使用 Rust 内置的文档工具来生成文档，并将其上传到 crates.io。
- 更新你的项目文档和 README。在将你的 crate 发布到 crates.io 后，你需要更新你的项目文档和 README 文件，以便其他开发者可以使用你的 crate。


在发布你的 crate 前，你需要注意以下几点：

- 你需要确保你的代码质量和可靠性。这包括确保你的代码通过了单元测试和集成测试，并尽可能避免使用未经测试的依赖项。
- 你需要确保你的代码符合 Rust 社区的代码规范和最佳实践。
- 你需要确保你的 crate 包含了适当的许可证信息，并确保你有权发布你的代码。
- 你需要确保你的 crate 包含了合适的文档和注释，以便其他开发者可以轻松地使用你的代码。

总之，将一个 CLI 工具项目发布为一个 crate 需要对代码进行一些改造，确保代码质量和可靠性，并且遵循 Rust 社区的最佳实践和规范。发布前，你需要确保你的代码包含了适当的文档和许可证信息，并更新你的项目文档和 README 文件。

### .toml 作为配置

> Q:

rudt 中读写 .toml 文件, 最推荐的 create 是哪个? 如何使用?

> GPT:

如果你需要在 Rust 中读写 TOML 文件，可以使用 toml crate。这个 crate 可以在 Cargo.toml 文件中添加以下依赖来使用：

```toml
[dependencies]
toml = "0.5.8"
```

以下是一个简单的示例代码，演示如何使用 toml crate 读取一个名为 "config.toml" 的 TOML 文件：

```rust
use std::fs;
use toml::Value;

fn main() {
    // 读取文件
    let contents = fs::read_to_string("config.toml")
        .expect("Something went wrong reading the file");

    // 解析 TOML
    let parsed_toml: Value = toml::from_str(&contents).unwrap();

    // 访问值
    let title = parsed_toml["title"].as_str().unwrap();
    let subtitle = parsed_toml["subtitle"].as_str().unwrap();

    println!("{}: {}", title, subtitle);
}
```

在上面的代码中，首先使用 fs::read_to_string 函数读取 TOML 文件的内容。然后，使用 toml::from_str 函数将内容解析为 toml::Value 类型的值。接下来，可以访问解析后的 TOML 值，例如 parsed_toml["title"].as_str().unwrap() 用于获取 TOML 文件中的 "title" 值。最后，将这些值打印到控制台。

如果你需要将数据写入 TOML 文件，则可以使用 toml crate 的 to_string 函数将 toml::Value 类型的值转换为 TOML 格式的字符串，然后使用 fs::write 函数将字符串写入文件。

以下是一个简单的示例代码，演示如何使用 toml crate 写入一个名为 "config.toml" 的 TOML 文件：

```rust
use std::fs;
use toml::Value;

fn main() {
    // 创建一个 `toml::Value` 类型的值
    let mut toml_value = Value::new();
    toml_value["title"] = "My Title".into();
    toml_value["subtitle"] = "My Subtitle".into();

    // 将值转换为 TOML 格式的字符串
    let toml_str = toml::to_string(&toml_value).unwrap();

    // 写入文件
    fs::write("config.toml", toml_str).expect("Something went wrong writing the file");
}

```
在上面的代码中，首先创建一个 toml::Value 类型的值，该值包含要写入 TOML 文件的数据。然后，使用 toml::to_string 函数将该值转换为 TOML 格式的字符串。最后，使用 fs::write 函数将字符串写入文件。


### 展开 BufReader

> Q:
```rust
use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -> std::io::Result<()> {
    let f = File::open("log.txt")?;
    let mut reader = BufReader::new(f);

    let mut line = String::new();
    let len = reader.read_line(&mut line)?;
    println!("First line is {} bytes long", len);
    Ok(())
}
```

如何将这段代码修改为循环将指定文件所有行内容逐一输出?

> PS: 从 [std::io::BufReader - Rust](https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html#examples) 抄的

> GPT:

要循环输出文件的所有行内容，您可以在一个循环中使用BufReader的read_line方法。每次迭代时，该方法会读取文件中的一行，并将其存储在给定的字符串变量中。当没有更多的行可以读取时，该方法将返回一个长度为0的结果，这是跳出循环的信号。

以下是修改后的代码示例：

```rust
use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -> std::io::Result<()> {
    let f = File::open("log.txt")?;
    let reader = BufReader::new(f);

    for line in reader.lines() {
        println!("{}", line?);
    }
    Ok(())
}
```

在这个例子中，我们使用了reader.lines()方法，它返回一个std::io::Lines迭代器。每次迭代时，该迭代器都会读取文件中的一行，并将其包装在一个std::io::Result<String>中返回。我们可以使用?操作符来解包这个结果，如果读取失败，它会将错误传播到main函数的调用方。

通过这种方式，我们可以逐行读取文件并将每一行内容输出到控制台。

> Q:
std::io::prelude 是什么库? 引用了什么进来? 用在哪儿了?

> GPT:

`std::io::prelude` 是一个模块，包含了一些常见的 I/O trait 和类型的预定义导入。这些预定义导入使得开发者能够轻松地使用 Rust 标准库中的 I/O 功能，同时也减少了大量的代码重复。

在 Rust 代码中，通过引入std::io::prelude模块来使用预定义导入，通常会出现在处理 I/O 相关操作的代码中。这个模块包含了以下几个 trait 的预定义导入：

- Read: 用于读取数据的 trait。
- BufRead: 用于读取缓冲区的 trait。
- Write: 用于写入数据的 trait。

这些 trait 都被用于在 Rust 中进行 I/O 操作，因此它们经常会被其他的 I/O 模块或库使用。例如，在上面提供的示例代码中，我们使用了std::io::prelude来导入Read trait，从而使用BufReader的read_line方法读取文件中的每一行内容。


> A: 
如何对循环中的 line 进行类似 contains 的判定呢?

> GPT:

要对读取的每一行内容进行包含（contains）的判定，您可以在for循环内使用if语句，对每一行进行检查。以下是示例代码：

```rust
use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;

fn main() -> std::io::Result<()> {
    let f = File::open("log.txt")?;
    let reader = BufReader::new(f);

    for line in reader.lines() {
        let line_content = line?;
        if line_content.contains("Error") {
            println!("{}", line_content);
        }
    }
    Ok(())
}
```
在这个例子中，我们使用contains方法检查每一行内容是否包含字符串"Error"。如果是，我们将该行内容打印到控制台。否则，我们将跳过该行并继续读取文件的下一行。

> Q:

对应代码修改为:

```rust
    let f = File::open(&args.path)
        .expect("could NOT read the file");
    let reader = BufReader::new(f);

    let mut line = String::new();
    for line in reader.lines() {
            let line_content = line?;
            if line_content.contains("Error") {
                println!("{}", line_content);
            }
        }
```
但是报错:
```
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
  --> src/main.rs:66:36
   |
24 | fn main() {
   | --------- this function should return `Result` or `Option` to accept `?`
...
66 |             let line_content = line?;
   |                                    ^ cannot use the `?` operator in a function that returns `()`
   |
   = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
```
应该如何解决?


> GPT:

该错误是因为在main函数中，我们不能在循环中使用?操作符。?操作符只能用于返回Result或Option的函数或方法中，它会在发生错误时自动将错误返回给调用者。

在main函数中，我们必须手动处理错误并决定如何处理它们。在这种情况下，我们可以简单地将错误打印到控制台。以下是示例代码：

```rust
use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: {} <path_to_file>", args[0]);
        return;
    }

    let f = File::open(&args[1]).expect("Could not read file");
    let reader = BufReader::new(f);

    for line in reader.lines() {
        if let Ok(line_content) = line {
            if line_content.contains("Error") {
                println!("{}", line_content);
            }
        } else {
            eprintln!("Error while reading file");
            return;
        }
    }
}
```
在这个例子中，我们使用if let语句检查读取每一行是否成功。如果成功，我们检查行内容是否包含字符串"Error"，如果是则将其打印到控制台。如果读取行时发生错误，我们将错误打印到标准错误流（stderr），并退出程序。

> Q:

看起来这里有多层 if 不是很 rusty, 有其它方案来达成相同效果嘛?

> GPT:

您可以使用match语句来代替嵌套的if let语句，以避免多层嵌套和提高代码可读性。以下是使用match语句重写的示例代码：

```rust
use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: {} <path_to_file>", args[0]);
        return;
    }

    let f = File::open(&args[1]).expect("Could not read file");
    let reader = BufReader::new(f);

    for line in reader.lines() {
        match line {
            Ok(line_content) => {
                if line_content.contains("Error") {
                    println!("{}", line_content);
                }
            }
            Err(_) => {
                eprintln!("Error while reading file");
                return;
            }
        }
    }
}
```

在这个例子中，我们使用match语句匹配line的值。如果读取行成功，我们使用Ok(line_content)分支来处理行内容，如果行内容包含字符串"Error"，则将其打印到控制台。如果读取行时出现错误，我们使用Err(_)分支来处理错误，并将错误打印到标准错误流（stderr），并退出程序。

相比使用嵌套的if let语句，match语句更加清晰和简洁。

> Q:

没错, match 看起来优雅多了, 不过, 还有其它方案嘛?

> GPT:

是的，除了使用match语句，还有一种更简洁的方法来实现类似的效果。可以使用filter_map方法和std::result::Result::ok函数来过滤行并将它们转换为可选的字符串。然后，您可以使用for循环迭代这些字符串并将它们打印出来。以下是使用filter_map和std::result::Result::ok函数的示例代码：

```rust
use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: {} <path_to_file>", args[0]);
        return;
    }

    let f = File::open(&args[1]).expect("Could not read file");
    let reader = BufReader::new(f);

    for line in reader.lines().filter_map(Result::ok).filter(|line| line.contains("Error")) {
        println!("{}", line);
    }
}

```

在这个例子中，我们首先调用filter_map方法来过滤掉那些读取行时返回错误的行，并将其转换为可选的字符串。然后，我们使用filter方法来过滤掉那些不包含字符串"Error"的行。最后，我们使用for循环迭代这些字符串，并将它们打印到控制台。

相比使用match语句和嵌套的if let语句，这种方法更加简洁和优雅。

> Q:

还有更加优雅的方案嘛?

> GPT:
当然，Rust 的标准库提供了非常强大的迭代器和函数式编程工具箱，可以让代码更加简洁和优雅。

在这个例子中，您可以使用filter方法和闭包来过滤掉不包含"Error"的行，然后使用map方法和unwrap函数将可选的行转换为字符串并将其打印到控制台上。这是代码的示例：

```rust
use std::io::prelude::*;
use std::io::BufReader;
use std::fs::File;
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: {} <path_to_file>", args[0]);
        return;
    }

    let f = File::open(&args[1]).expect("Could not read file");
    let reader = BufReader::new(f);

    reader.lines()
          .filter(|line| line.as_ref().map(|s| s.contains("Error")).unwrap_or(false))
          .map(|line| line.unwrap())
          .for_each(|line| println!("{}", line));
}
```

在这个例子中，我们首先调用filter方法来过滤掉那些不包含字符串"Error"的行。由于lines方法返回的是一个包含Result<Option<String>>的迭代器，我们需要在闭包中使用as_ref方法来将Result<Option<String>>转换为Option<&String>。然后，我们使用map方法和unwrap函数来将可选的行转换为字符串，并将其打印到控制台上。

使用这种方法，我们可以将代码进一步简化，并更加清晰地表达我们的意图。


> Q:

没错, 这样又简洁,又整齐,而且意义明确;
看起来 迭代器和函数式工具有很多, 类似 filter 和 map 的内置工具还有哪些? 分别有什么优雅的实用案例?

> GPT:

Rust 的标准库提供了丰富的迭代器和函数式编程工具，包括：

- map：将一个迭代器中的每个元素转换为另一种类型的元素，通常用于数据类型转换和计算。
    - 示例：

```rust
let numbers = vec![1, 2, 3, 4, 5];
let squares: Vec<i32> = numbers.iter().map(|n| n * n).collect();
// squares is [1, 4, 9, 16, 25]
```

- filter：根据某个条件过滤出迭代器中的元素，通常用于数据过滤和筛选。
    - 示例：

```rust
let numbers = vec![1, 2, 3, 4, 5];
let evens: Vec<i32> = numbers.iter().filter(|n| n % 2 == 0).collect();
// evens is [2, 4]
```

- fold：使用某种累加器（初始值）和一个闭包来聚合迭代器中的元素，通常用于求和、平均值和字符串拼接等操作。
    - 示例：计算一个数字向量中所有元素的和。

```rust
let numbers = vec![1, 2, 3, 4, 5];
let sum: i32 = numbers.iter().fold(0, |acc, n| acc + n);
// sum is 15
```

- flat_map：将一个迭代器中的每个元素转换为另一个迭代器，然后将所有的迭代器合并为一个迭代器。
    - 示例：

```rust
let words = vec!["hello world", "foo bar", "baz qux"];
let letters: Vec<char> = words.iter().flat_map(|s| s.chars()).collect();
// letters is ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', 'f', 'o', 'o', ' ', 'b', 'a', 'r', 'b', 'a', 'z', ' ', 'q', 'u', 'x']
```

- any 和 all：检查迭代器中是否存在任意元素或所有元素都满足某个条件。
    - 示例：

```rust
let numbers = vec![1, 2, 3, 4, 5];
let any_odd = numbers.iter().any(|n| n % 2 == 1);
let all_even = numbers.iter().all(|n| n % 2 == 0);
// any_odd is true, all_even is false
```


- enumerate: 枚举迭代器中的元素，并将元素索引和值组成一个元组返回。
    - 示例：遍历一个字符串向量并打印每个元素的索引和值。

```rust
let v = vec!["foo", "bar", "baz"];
for (i, s) in v.iter().enumerate() {
    println!("{}: {}", i, s);
}

```


- zip：将两个迭代器合并为一个元素对的迭代器。
    - 示例：从两个向量中取出对应位置的元素并组成一个新的向量


```rust
let numbers = vec![1, 2, 3];
let letters = vec!['a', 'b', 'c'];
let pairs: Vec<(i32, char)> = numbers.iter().zip(letters.iter()).collect();
// pairs is [(1, 'a'), (2, 'b'), (3, 'c')]

```

当使用迭代器处理数据时，有时需要对数据进行分段处理。在这种情况下，可以使用 take 和 skip 方法。

- take：从一个集合中取出前几个元素。例如，从一个包含所有人的向量中取出前 10 个人。
    - take(n) 方法会创建一个新的迭代器，它只包含原始迭代器的前 n 个元素。例如：

```rust
let numbers = vec![1, 2, 3, 4, 5];
let first_three = numbers.iter().take(3);
for number in first_three {
    println!("{}", number);
}
// 输出:
// 1
// 2
// 3
```

- skip：跳过一个集合中的前几个元素。例如，从一个包含所有人的向量中跳过前 10 个人，然后返回剩余的所有人。
    - skip(n) 方法会创建一个新的迭代器，它跳过原始迭代器的前 n 个元素，然后迭代其余的元素。例如：

```rust
let numbers = vec![1, 2, 3, 4, 5];
let last_two = numbers.iter().skip(3);
for number in last_two {
    println!("{}", number);
}
// 输出:
// 4
// 5

```

- chain：将两个集合连接在一起，然后返回一个新的集合。例如，将一个包含所有男性的向量和一个包含所有女性的向量连接在一起，然后返回一个包含所有人的向量。
    - 另一个常见的迭代器方法是 chain 方法。它接收另一个迭代器作为参数，将其添加到当前迭代器的末尾，并返回一个新的迭代器。例如：

```rust
let numbers1 = vec![1, 2, 3];
let numbers2 = vec![4, 5, 6];
let all_numbers = numbers1.iter().chain(numbers2.iter());
for number in all_numbers {
    println!("{}", number);
}
// 输出:
// 1
// 2
// 3
// 4
// 5
// 6

```
在上面的示例中，我们首先创建了两个向量 numbers1 和 numbers2，然后将它们合并为一个新的迭代器 all_numbers。最后，我们遍历 all_numbers 并输出其中的所有元素。



这些是 Rust 中一些常见的迭代器方法和函数式工具，您可以根据自己的需要来选择使用它们。在 Rust 中，迭代器和函数式编程被广泛应用于各种场景，例如处理集合、过滤和排序数据、处理文本等等。通过使用这些工具，您可以编写更加简洁、优雅、高效和安全的代码。


> Q:

发现还有 try_fold 之类带有 try_ 的迭代器,一般是用在什么场景中的?


> GPT:

try_fold 方法是一个带有 try_ 前缀的迭代器方法，它类似于 fold 方法，但是它允许在迭代器处理过程中发生错误，并将错误传递给调用方进行处理。try_fold 方法的使用场景通常是处理可能会失败的操作的迭代器元素序列，例如网络请求或文件 I/O 操作。

try_fold 方法有两个参数：一个初始累加器和一个闭包，闭包将当前累加器的值和迭代器的下一个元素作为参数，并返回一个 Result 值。如果闭包返回一个 Ok 值，则 try_fold 方法会继续迭代。如果闭包返回一个 Err 值，则 try_fold 方法会立即停止迭代并将错误传递给调用方。

以下是一个简单的示例，演示如何使用 try_fold 方法来计算向量中所有元素的和，其中每个元素都是 Result<i32, String> 类型：

```rust
fn main() {
    let vec = vec![Ok(1), Ok(2), Err("failed".to_string()), Ok(3)];
    let sum = vec
        .into_iter()
        .try_fold(0, |acc, x| x.map(|n| acc + n));
    match sum {
        Ok(result) => println!("Sum is {}", result),
        Err(error) => println!("Error: {}", error),
    }
}
```
在上面的代码中，我们首先创建了一个向量 vec，其中包含三个 Ok 值和一个 Err 值。然后我们使用 into_iter 方法将向量转换为迭代器，使用 try_fold 方法来计算所有元素的和，其中使用 map 方法将 Ok 值映射到它们的整数值，并忽略 Err 值。最后，我们使用 match 来处理可能的错误和结果。



## refer.
> 其实官方的文档吃透, 基本可以平趟 80% 的日常开发了...

- 🌝🦀 [sigoden/aichat: Chat with ChatGPT-3.5 in the terminal.](https://github.com/sigoden/aichat "sigoden/aichat: Chat with ChatGPT-3.5 in the terminal.")
    - [f/awesome-chatgpt-prompts: This repo includes ChatGPT prompt curation to use ChatGPT better.](https://github.com/f/awesome-chatgpt-prompts) ~ 提示工程师技巧...
    - [加入 Beta 版“AssisChat” - TestFlight - Apple](https://testflight.apple.com/join/IIfv6RIc "加入 Beta 版“AssisChat” - TestFlight - Apple") ~ 官方移动支持...
    - ...
- std::
    - [Iterator in std::iter - Rust](https://doc.rust-lang.org/std/iter/trait.Iterator.html#)
    - ...
- ...


## logging
> 版本记要

- ..
- 230224 ZQ init.




```
          _~^~`~_
      () /  - ◶  \ \/
        '_   ⏝   _'
        > '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>README.md</title><link>https://rs.101.so//dev/README</link><pubDate>Wed, 08 Mar 2023 14:31:43 +0800</pubDate><content:encoded><![CDATA[# 开发
> projects ...


## background
> 无奈背景

开发语言学习, 不用来开发真实项目, 基本是表演学习行为了...

## goal
> 必要目标

一组日常要用工具, 原创/再制/...

关键是积累一组可用作品, 打底儿.

## trace
> 具体推进

MVP ~ 最小可行工程能力?

- [ ] 工程结构
    - [ ] crate/library/pakage/workspace/project 划分和使用
        - [x] package ~ cargo new 出来的东西
        - [x] crate ~ src/*.rs 
            - 二进制包
                - `src/main.rs` 
                - `src/bin/*.rs` 
        - [x] library ~ src/lib.rs
        - [x] module ~ mod 圈定的代码块
                - 绝对/相对引用路径
                - self/super/crate/... ~> [super 和 self - 通过例子学 Rust 中文版](https://rustwiki.org/zh-CN/rust-by-example/mod/split.html)
                - rustc 1.30+ 要求:
                    - 同级目录创建 mod 名同名目录
                    - 在其中创建子模块.rs 文件
                    - 此时才能在 mod 名同名 .rs 中使用 mod 来引用
                - lib.rs ~ 检索更方便
                - crates.rs ~ 下载最稳定
        - [x] use 和可见性...
            - 结构体和枚举的可见性...[结构体的可见性 - 通过例子学 Rust 中文版](https://rustwiki.org/zh-CN/rust-by-example/mod/struct_visibility.html#%E5%8F%82%E8%A7%81)
            - 优先使用最细粒度(引入函数、结构体等)的引用方式，如果引起了某种麻烦(例如前面两种情况)，再使用引入模块的方式
            - 不同模块同名 as 别名引用
            - use xxx::{self, yyy}; ~ 集成引用
            - use std::collections::*; ~ 只用来引入 tests
            - pub use ~ 引入后再导出(所有权无处不在...)
            - pub(in crate::a) ... 限制可见性语法
                - pub 意味着可见性无任何限制
                - pub(crate) 表示在当前包可见
                - pub(self) 在当前模块可见
                - pub(super) 在父模块可见
                - pub(in <path>) 表示在某个路径代表的模块中可见，其中 `path` 必须是父模块或者祖先模块
              - ~> [使用 use 引入模块及受限可见性 - Rust语言圣经(Rust Course)](https://course.rs/basic/crate-module/use.html#%E9%99%90%E5%88%B6%E5%8F%AF%E8%A7%81%E6%80%A7%E8%AF%AD%E6%B3%95)
        - [ ] workspace
        - [ ] project
    - [ ] 模块切分/命名..艺术?
    - [x] [将 crate 发布到 Crates.io - Cargo 手册 中文版](https://wangchujiang.com/rust-cn-document-for-docker/cargo/reference/publishing.html#%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA-crate)
- [ ] 基本应用
    - [x] 基本调试循环 ~ 配合 tracing 和 log 目录...
    - [ ] 基本单元测试
    - [x] 基本编译发行 ~ cargo build
- [ ] 分布式
    - [ ] 调试/追踪
    - [ ] CI/CD
    - [ ] ...
- [ ] 核心概念/技能
    - [ ] 内建数据类型
    - [ ] 智能指针
    - [ ] 所有权和借用
    - [ ] 泛型
    - [ ] trait
    - [ ] 生命周期
- [ ] 高级工程技巧
    - [ ] 宏
    - [ ] GDB
    - [ ] ...
- [ ] 嵌入式
    - [ ] 基本工具箱
    - [ ] Pico
    - [ ] ...

## refer.
> 关键参考

[贡献者公约/Contributor Covenant:](https://www.contributor-covenant.org/zh-cn/version/2/1/code_of_conduct/)

- [介绍 - Rust 的绅士介绍](https://llever.com/gentle-intro/readme.zh.html)
- [Clear explanation of Rust’s module system](https://www.sheshbabu.com/posts/rust-module-system/)
- [将 crate 发布到 Crates.io - Cargo 手册 中文版](https://wangchujiang.com/rust-cn-document-for-docker/cargo/reference/publishing.html#%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA-crate)
- 各种值得尝试的作品类型:
    - SSG: [Tutorial: Building a Blog in Rust \- Static File Server \- YouTube](https://www.youtube.com/watch?v=9uAy8skUVsc)
    - ...
- ...

### 关键工具:

- [diff.rs](https://diff.rs/ "diff.rs")
    - [xfbs/diff.rs: Web application (WASM) to render a diff between Rust crate versions.](https://github.com/xfbs/diff.rs "xfbs/diff.rs: Web application (WASM) to render a diff between Rust crate versions.")
    - 可以在线对应所有 crate 各种版本间所有文件的差异, 快速观察到改进思路...
- ...


## logging
> 版本记要

- ..
- 230228 ZQ ++🦀🦀🦀
- 221023 ZQ init.


```
           _~`+~~_
       () /  ♡ ◷  \ \/
         '_   V   _'
         \ '--~--' |

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```
]]></content:encoded></item><item><title>cli_rss4mdbook.md</title><link>https://rs.101.so//dev/cli_rss4mdbook</link><pubDate>Wed, 08 Mar 2023 01:41:51 +0800</pubDate><content:encoded><![CDATA[# RSS for Mdbook
> 是的一个应该是常用的工具...


## backgroung
作为一名工程师, 使用哪种语言, 就想用这语言作一切...

mdbook 非常好, 吻合以往想用 Markdown 快速发布网站的所有期待:

- 纯 .md, 不包含约定的各种奇怪的 meta head
- 根据自然目录生成
- 生成速度非常快
- ...


## goal

虽然 RSS 有点儿过气了, 但是, 在工程师世界里还是一个标准的信息交换接口,

但是, [mdbook\-rss \- crates\.io: Rust Package Registry](https://crates.io/crates/mdbook-rss) 

- 很久没更新
- 而且也不生效
- ...


那么就得自己上了...



## trace

- [x] 探索..决定方案
- [x] 架构基本框架
- [x] 实现核心功能
- [x] 清查发表 crate
  - [rss4mdbook - crates.io: Rust Package Registry](https://crates.io/crates/rss4mdbook)
- [x] 试用
    - 囧了,竟然不好支持多站点...
    - 🌝 妥了 -> [Release RSS4mdBook v0.2.42 · zhrust/rss4mdbook](https://github.com/zhrust/rss4mdbook/releases/tag/v0.2.42)
- [ ] 宣传?
- [ ] ...无尽的维护



## refer.

- [clap::_derive::_cookbook::git_derive - Rust](https://docs.rs/clap/latest/clap/_derive/_cookbook/git_derive/index.html)
- [markdown \- crates\.io: Rust Package Registry](https://crates.io/crates/markdown/0.3.0)
- [mdbook \- crates\.io: Rust Package Registry](https://crates.io/crates/mdbook/0.4.28)
- [rss \- crates\.io: Rust Package Registry](https://crates.io/crates/rss/1.10.0)
- ...

## logging

- ...🦀
- 230308 ZQ publish ~>  [rss4mdbook - crates.io: Rust Package Registry](https://crates.io/crates/rss4mdbook)
- 230306 ZQ init.




```
        _~∽&`~_
    \) /  ◕ =  \ (/
      '_   ⏝   _'
      / '--~--' \

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```


]]></content:encoded></item></channel></rss>