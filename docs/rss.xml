<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>be Rustaceans ~ æˆé”ˆçºª</title><link>https://rs.101.so</link><description>~ æ±‡é›† å¤§å¦ˆ/Zoom.Quiet å­¦ä¹ /å®è·µ/æ¢ç´¢/... Rust ä¸–ç•Œé”ˆè¿¹, ä¸€èµ·æˆä¸º Rustacean å§...</description><generator>my_rss_generator</generator><item><title>chat_heap_stack.md</title><link>https://rs.101.so//101/chat_heap_stack</link><pubDate>Fri, 24 Mar 2023 11:28:53 +0800</pubDate><content:encoded><![CDATA[# å¯å˜/ä¸å¯å˜å¼•ç”¨æ€åº¦
> å­¦ä¼´ChatGPT, chatting for debugging ...

## background
> ææ˜ codingåˆ°ç¯ç«é˜‘çŠ 2023-03-24 06:00

[Rustå¼€å‘äººå‘˜ç»å¸¸çŠ¯çš„5ä¸ªå¸¸è§é”™è¯¯](https://mp.weixin.qq.com/s/KXfCHeFuLvK8PHAkA5QJmA)

## goal

å®Œæˆåˆç†æ¦‚å¿µæ‘¸æŸ¥...

## trace

> Q: rust ä»£ç :

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        // è¿™ä¸€è¡Œå°†å¯¼è‡´ç¼–è¯‘é”™è¯¯
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}

```

ä¸ºä»€ä¹ˆå‡ºé”™?å¦‚ä½•ä¿®æ”¹? ä»¥åŠå¦‚ä½•ç†è§£?

> A:è¯¥ç¨‹åºå‡ºé”™æ˜¯å› ä¸º string2 çš„ç”Ÿå‘½å‘¨æœŸæ¯” result çš„ç”Ÿå‘½å‘¨æœŸçŸ­ï¼Œè€Œ result æ˜¯ä¸€ä¸ªæŒ‡å‘ string2 ä¸­çš„å¼•ç”¨ï¼Œå› æ­¤åœ¨ string2 ç¦»å¼€ä½œç”¨åŸŸåï¼Œresult æŒ‡å‘çš„å†…å­˜å·²ç»è¢«é‡Šæ”¾ï¼Œè¿™ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦è®© result çš„ç”Ÿå‘½å‘¨æœŸæ¯” string2 çš„ç”Ÿå‘½å‘¨æœŸæ›´é•¿ã€‚æœ‰å¤šç§æ–¹æ³•å¯ä»¥å®ç°è¿™ä¸€ç‚¹ï¼Œä»¥ä¸‹æ˜¯å…¶ä¸­çš„ä¸€ç§ï¼š

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    let string2 = String::from("xyz");
    result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);
}
```
åœ¨è¿™ä¸ªä¿®æ”¹åçš„ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å°† string2 çš„å£°æ˜ç§»åˆ°äº† result çš„å£°æ˜ä¹‹å‰ï¼Œå¹¶ä¸”ä¸å†ä½¿ç”¨ä¸€ä¸ªä»£ç å—æ¥é™åˆ¶ string2 çš„ä½œç”¨åŸŸã€‚è¿™æ„å‘³ç€ string2 å’Œ result çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œå› æ­¤ result ä»ç„¶æœ‰æ•ˆã€‚

è¯¥ç¨‹åºçš„ä»£ç ä½¿ç”¨äº† Rust çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š 'a æ¥å‘Šè¯‰ç¼–è¯‘å™¨ longest å‡½æ•°çš„è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸåº”è¯¥ä¸ x å’Œ y çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒã€‚

ç®€å•åœ°è¯´ï¼Œç¨‹åºä¸­çš„ä¿®æ”¹è®© string2 å’Œ result å…·æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼Œä»è€Œè§£å†³äº†é—®é¢˜ã€‚

> Q: let string2 = "xyz"; æ˜¯å¦ä¹Ÿå¯ä»¥è§£å†³ç›¸åŒçš„é—®é¢˜? ä¸ºä»€ä¹ˆ?

> A:æ˜¯çš„ï¼Œå¦‚æœå°† string2 çš„ç±»å‹ä» String æ”¹ä¸ºå­—ç¬¦ä¸²å­—é¢é‡ &strï¼Œåˆ™ç¨‹åºå°±å¯ä»¥æ­£ç¡®ç¼–è¯‘å’Œè¿è¡Œã€‚ä¿®æ”¹åçš„ç¨‹åºå¦‚ä¸‹ï¼š

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

å­—ç¬¦ä¸²å­—é¢é‡åœ¨ç¼–è¯‘æ—¶å°±å·²ç»å­˜åœ¨äºç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå› æ­¤å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä¸ç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œè€Œä¸éœ€è¦åœ¨å †ä¸Šåˆ†é…å†…å­˜ã€‚è¿™æ„å‘³ç€å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä¸å…¶ä»–åœ¨ç¨‹åºä¸­å®šä¹‰çš„å˜é‡çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œå› æ­¤åœ¨ä½¿ç”¨å­—ç¬¦ä¸²å­—é¢é‡æ—¶ä¸éœ€è¦æ‹…å¿ƒç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜ã€‚

æ‰€ä»¥ä½¿ç”¨å­—ç¬¦ä¸²å­—é¢é‡ä½œä¸ºå‚æ•°ä¼ é€’ç»™ longest å‡½æ•°æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸå·²ç»åœ¨ç¼–è¯‘æ—¶ç¡®å®šäº†ï¼Œå¹¶ä¸”ä¸å‡½æ•°ä¸­çš„å…¶ä»–å˜é‡çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒã€‚

> Q: é‚£ä¹ˆ, ä¸ºä»€ä¹ˆ longest() ä¸€å®šè¦æŒ‡å®šå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸ? æ²¡æœ‰å…¶å®ƒæ›´åŠ ç®€æ´çš„å½¢å¼äº†å˜›?

> A: åœ¨ Rust ä¸­ï¼Œstr æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸² slice ç±»å‹ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯å˜çš„ã€å›ºå®šé•¿åº¦çš„å¼•ç”¨ç±»å‹ã€‚ç”±äº str å¼•ç”¨çš„æ˜¯å­˜å‚¨åœ¨å †ä¸Šçš„å­—ç¬¦ä¸²æ•°æ®ï¼Œå› æ­¤å®ƒçš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»æ˜¯ç”±è¯¥å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒæ¥å†³å®šçš„ã€‚

åœ¨ longest() å‡½æ•°ä¸­ï¼Œx å’Œ y çš„ç±»å‹æ˜¯ &'a strï¼Œè¿™è¡¨ç¤ºå®ƒä»¬æ˜¯æŒ‡å‘æŸä¸ªå­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸè¢«é™åˆ¶ä¸º 'aï¼Œå³å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºå‡½æ•°çš„è¿”å›å€¼ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹å­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»æ˜¯åœ¨å‡½æ•°è¿”å›åæ‰èƒ½å¼€å§‹çš„ï¼Œè€Œä¸”å¿…é¡»ä¸å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³è”ï¼Œä»¥é¿å…æ‚¬å‚å¼•ç”¨çš„é—®é¢˜ã€‚

å¦‚æœæˆ‘ä»¬å°†å‚æ•°ç±»å‹æ”¹ä¸º strï¼Œé‚£ä¹ˆå°±æ— æ³•æ§åˆ¶å®ƒä»¬å¼•ç”¨çš„å­—ç¬¦ä¸²çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› ä¸ºå®ƒä»¬ä¸æ˜¯å¼•ç”¨ç±»å‹ã€‚å¦‚æœæˆ‘ä»¬è¯•å›¾é€šè¿‡å°† string1 å’Œ string2 çš„å€¼è¿›è¡Œ clone æ¥ä¼ é€’å®ƒä»¬çš„å‰¯æœ¬ï¼Œè¿™æ ·å¯èƒ½ä¼šå¯¼è‡´å †åˆ†é…çš„é¢å¤–å¼€é”€å’Œæ€§èƒ½é—®é¢˜ï¼Œå› ä¸ºè¿™éœ€è¦ä¸ºæ¯ä¸ªå­—ç¬¦ä¸²åˆ†é…ä¸€ä¸ªæ–°çš„å†…å­˜å—ï¼Œå¹¶åœ¨å‡½æ•°è°ƒç”¨ç»“æŸåé‡Šæ”¾è¿™äº›å†…å­˜å—ã€‚

å› æ­¤ï¼Œåœ¨ longest() å‡½æ•°ä¸­ï¼Œæœ€å¥½ä½¿ç”¨å­—ç¬¦ä¸² slice ç±»å‹ &strï¼Œå¹¶åœ¨è°ƒç”¨å‡½æ•°æ—¶ä¼ é€’æŒ‡å‘åŸå§‹å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼Œä»¥ç¡®ä¿åœ¨ä¸éœ€è¦åˆ†é…é¢å¤–å†…å­˜çš„æƒ…å†µä¸‹æ­£ç¡®å¤„ç†å­—ç¬¦ä¸²ã€‚

> Q: æ˜ç™½äº†, å¦‚æœä¸è€ƒè™‘æ€§èƒ½, ä½¿ç”¨ clone ä¹Ÿæ˜¯å¯ä»¥çš„

> A: æ˜¯çš„ï¼Œå¦‚æœä¸è€ƒè™‘æ€§èƒ½é—®é¢˜ï¼Œä½ å¯ä»¥é€šè¿‡ä½¿ç”¨ clone() æ–¹æ³•æ¥åˆ›å»ºä¼ é€’ç»™ longest() å‡½æ•°çš„å­—ç¬¦ä¸²çš„æ‹·è´ã€‚è¿™å°†ä½¿æ¯ä¸ªå­—ç¬¦ä¸²éƒ½åœ¨å †ä¸Šåˆ†é…æ–°çš„å†…å­˜ï¼Œå¹¶ä½¿ longest() å‡½æ•°èƒ½å¤Ÿæ¥å— String ç±»å‹çš„å‚æ•°ã€‚

ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ä»£ç æ¥è°ƒç”¨ longest() å‡½æ•°ï¼Œä½¿ç”¨ clone() æ–¹æ³•åˆ›å»ºäº† string1 å’Œ string2 çš„å‰¯æœ¬ï¼š

```rust

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);

    // Create clones of the strings and pass them to longest()
    let string3 = string1.clone();
    let string4 = string2.clone();
    let result2 = longest(string3.as_str(), string4.as_str());
    println!("The longest string is {}", result2);
}

```
æ³¨æ„ï¼Œè¿™ç§æ–¹æ³•å¯èƒ½ä¼šäº§ç”Ÿæ€§èƒ½é—®é¢˜ï¼Œå› ä¸ºæ¯æ¬¡è°ƒç”¨ clone() æ–¹æ³•éƒ½ä¼šåˆ†é…æ–°çš„å†…å­˜å¹¶å¤åˆ¶å­—ç¬¦ä¸²çš„å†…å®¹ã€‚å› æ­¤ï¼Œå¦‚æœæ€§èƒ½æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œæœ€å¥½é¿å…ä½¿ç”¨ clone() æ–¹æ³•æ¥åˆ›å»ºå­—ç¬¦ä¸²çš„å‰¯æœ¬ã€‚


> Q: æ˜ç™½äº†, é‚£ä¹ˆ å †ä¸æ ˆçš„æœ¬è´¨åŒºåˆ«æ˜¯ä»€ä¹ˆ? ä¸ºä»€ä¹ˆ rust å¯¹æ ˆè¿™ä¹ˆä¿¡ä»», å¯¹å †å´å¾ˆè­¦æƒ•?

> A: åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œå †å’Œæ ˆéƒ½æ˜¯å†…å­˜ä¸­ç”¨äºå­˜å‚¨ç¨‹åºæ•°æ®çš„æ•°æ®ç»“æ„ã€‚å®ƒä»¬ä¹‹é—´çš„æœ¬è´¨åŒºåˆ«åœ¨äºå®ƒä»¬çš„å†…å­˜åˆ†é…æ–¹å¼å’Œæ•°æ®å­˜å‚¨çš„ç”Ÿå‘½å‘¨æœŸã€‚

æ ˆæ˜¯ä¸€ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„ï¼Œå®ƒä½¿ç”¨å›ºå®šå¤§å°çš„å†…å­˜å—æ¥å­˜å‚¨ç¨‹åºæ•°æ®ã€‚å½“ä¸€ä¸ªå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œè¯¥å‡½æ•°çš„å‚æ•°ã€å±€éƒ¨å˜é‡å’Œè¿”å›åœ°å€ç­‰æ•°æ®å°†è¢«å­˜å‚¨åœ¨æ ˆå¸§ä¸­ã€‚å½“å‡½æ•°è¿”å›æ—¶ï¼Œè¯¥æ ˆå¸§å°†è¢«å¼¹å‡ºï¼Œå…¶ä¸­å­˜å‚¨çš„æ•°æ®ä¹Ÿå°†è¢«é”€æ¯ã€‚ç”±äºæ ˆå†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾æ˜¯ç”±ç¨‹åºè‡ªåŠ¨è¿›è¡Œçš„ï¼Œå› æ­¤å®ƒä»¬çš„æ•ˆç‡éå¸¸é«˜ã€‚

å †æ˜¯ä¸€ç§åŠ¨æ€çš„æ•°æ®ç»“æ„ï¼Œå®ƒä½¿ç”¨ä¸è¿ç»­çš„å†…å­˜å—æ¥å­˜å‚¨ç¨‹åºæ•°æ®ã€‚å †å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾æ˜¯ç”±ç¨‹åºå‘˜æ‰‹åŠ¨ç®¡ç†çš„ï¼Œå®ƒä»¬çš„æ•ˆç‡ç›¸å¯¹è¾ƒä½ã€‚ç”±äºå †å†…å­˜çš„ç”Ÿå‘½å‘¨æœŸä¸åƒæ ˆé‚£æ ·æ˜“äºç¡®å®šï¼Œå› æ­¤åœ¨ä½¿ç”¨å †å†…å­˜æ—¶éœ€è¦æ³¨æ„å†…å­˜æ³„æ¼å’Œæ‚¬å‚æŒ‡é’ˆç­‰é—®é¢˜ã€‚

åœ¨ Rust ä¸­ï¼Œæ ˆä¸Šçš„æ•°æ®æ˜¯å¯ä»¥ç›´æ¥åœ¨æ ˆå¸§ä¸­è¿›è¡Œåˆ†é…å’Œé‡Šæ”¾çš„ï¼Œå› æ­¤ Rust å¯¹æ ˆçš„ç®¡ç†éå¸¸ä¿¡ä»»ã€‚ä½†æ˜¯ï¼Œç”±äºå †ä¸Šçš„æ•°æ®éœ€è¦æ‰‹åŠ¨ç®¡ç†ï¼Œå› æ­¤åœ¨ Rust ä¸­å¯¹å †çš„ç®¡ç†è¦æ›´åŠ è­¦æƒ•ï¼Œä»¥é¿å…å†…å­˜æ³„æ¼å’Œæ‚¬å‚æŒ‡é’ˆç­‰é—®é¢˜ã€‚å› æ­¤ï¼Œåœ¨ Rust ä¸­ä½¿ç”¨å †å†…å­˜æ—¶ï¼Œå¿…é¡»éµå¾ªæ‰€æœ‰æƒè§„åˆ™ï¼Œä»¥ç¡®ä¿æ¯ä¸ªå€¼éƒ½æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå¹¶åœ¨æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾å…¶å†…å­˜ã€‚è¿™ä¹Ÿæ˜¯ Rust ä¸­æ‰€æœ‰æƒç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µã€‚


> Q: é‚£ä¹ˆ, rust å†…å»ºæ•°æ®ç±»å‹ä¸­, å“ªäº›æ˜¯æ ˆ, å“ªäº›æ˜¯å †?

> A: åœ¨ Rust ä¸­ï¼Œå†…å»ºæ•°æ®ç±»å‹å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šæ ˆä¸Šåˆ†é…çš„å€¼å’Œå †ä¸Šåˆ†é…çš„å€¼ã€‚

ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„æ ˆä¸Šåˆ†é…çš„å€¼ï¼š

- æ‰€æœ‰åŸºæœ¬æ•°æ®ç±»å‹ï¼ˆä¾‹å¦‚æ•´æ•°ã€å¸ƒå°”å€¼å’Œæµ®ç‚¹æ•°ï¼‰
- æ•°ç»„å’Œå…ƒç»„ï¼ˆå½“å®ƒä»¬åŒ…å«æ ˆä¸Šåˆ†é…çš„å€¼æ—¶ï¼‰
- å‡½æ•°å’Œé—­åŒ…

ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„å †ä¸Šåˆ†é…çš„å€¼ï¼š

- æ‰€æœ‰æ ‡å‡†åº“é›†åˆç±»å‹ï¼Œä¾‹å¦‚ Vecã€String å’Œ HashMap ç­‰
- Box æ™ºèƒ½æŒ‡é’ˆå’Œ Rc å¼•ç”¨è®¡æ•°æŒ‡é’ˆ
- é—­åŒ…ï¼ˆå¦‚æœå®ƒä»¬æ•è·äº†å †ä¸Šåˆ†é…çš„å€¼ï¼‰


éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒRust ä¸­çš„**æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥åœ¨å †ä¸Šåˆ†é…ï¼Œåªè¦ä½¿ç”¨å †åˆ†é…å™¨**ï¼ˆå¦‚ Boxã€Vec æˆ–è€… Stringï¼‰å³å¯ã€‚ä½†æ˜¯ï¼Œæ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿è¿™äº›å †ä¸Šåˆ†é…çš„å€¼ä»ç„¶éµå¾ªæ‰€æœ‰æƒè§„åˆ™ï¼Œä»¥ç¡®ä¿å†…å­˜å®‰å…¨ã€‚


> Q: æ˜ç™½äº†, ä¹Ÿå°±æ˜¯è¯´ String::from("xyz") æ˜¯å †ä¸Šå†…å­˜, ä½†æ˜¯, "xyz" æ˜¯æ ˆä¸Šå†…å­˜,
é‚£ä¹ˆ, ä¸ºä»€ä¹ˆéƒ½æ˜¯ç”Ÿæˆä¸å¯å˜å­—ç¬¦ä¸², ä¸ºä»€ä¹ˆ Rust è¦æ„å»ºå‡ºå †ä¸Šå­—ç¬¦ä¸² String::from("xyz") ?
é—®é¢˜æ˜¯ String::from("xyz")  æœ‰ä»€ä¹ˆæ¯” "xyz" çš„å¥½å¤„?


> A: æ˜¯çš„ï¼Œæ‚¨çš„ç†è§£æ˜¯æ­£ç¡®çš„ã€‚"xyz" æ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶å¸¸é‡ï¼Œåˆ†é…åœ¨ç¨‹åºçš„æ ˆä¸Šï¼Œå®ƒæ˜¯ä¸€ä¸ªé™æ€åˆ†é…çš„ä¸å¯å˜å­—ç¬¦ä¸²ã€‚è€Œ String::from("xyz") æ˜¯åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†é…çš„å †ä¸Šçš„ä¸€ä¸ªä¸å¯å˜å­—ç¬¦ä¸²ã€‚

Rust ä¹‹æ‰€ä»¥æä¾› String ç±»å‹ï¼Œæ˜¯å› ä¸ºå®ƒå…·æœ‰ä»¥ä¸‹ä¸€äº›ä¼˜ç‚¹ï¼š

- åŠ¨æ€é•¿åº¦ï¼šåœ¨å †ä¸Šåˆ†é…ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒçš„é•¿åº¦å¯ä»¥åœ¨è¿è¡Œæ—¶æ ¹æ®éœ€è¦åŠ¨æ€å¢åŠ æˆ–å‡å°‘ï¼Œè¿™æ˜¯æ ˆä¸Šåˆ†é…çš„é™æ€å­—ç¬¦ä¸²æ‰€ä¸èƒ½åšåˆ°çš„ã€‚
- ä¸°å¯Œçš„å­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½ï¼šString ç±»å‹æä¾›äº†å„ç§å­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½ï¼Œä¾‹å¦‚æ‹¼æ¥ã€åˆ‡å‰²ã€æŸ¥æ‰¾ã€æ›¿æ¢ç­‰ã€‚
- UTF-8 ç¼–ç ï¼šRust ä¸­çš„å­—ç¬¦ä¸²ç±»å‹éƒ½æ˜¯åŸºäº UTF-8 ç¼–ç çš„ï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥è¡¨ç¤ºä¸–ç•Œä¸Šå‡ ä¹æ‰€æœ‰è¯­è¨€ä¸­çš„å­—ç¬¦ï¼ŒåŒ…æ‹¬éæ‹‰ä¸å­—ç¬¦é›†ï¼Œè€Œä¸ä¼šå‡ºç°ç¼–ç é—®é¢˜ã€‚


ä½†æ˜¯ï¼Œç”±äºåŠ¨æ€åˆ†é…å†…å­˜æ¶‰åŠåˆ°å †çš„ä½¿ç”¨ï¼Œè¿™ä¼šå¸¦æ¥ä¸€äº›é¢å¤–çš„å¼€é”€å’Œå¤æ‚æ€§ã€‚å› æ­¤ï¼Œåœ¨ç¼–å†™ Rust ä»£ç æ—¶ï¼Œåº”è¯¥å°½å¯èƒ½åœ°ä½¿ç”¨æ ˆä¸Šåˆ†é…çš„æ•°æ®ç±»å‹æ¥é¿å…å †åˆ†é…çš„å¼€é”€ã€‚ä»…å½“éœ€è¦åŠ¨æ€é•¿åº¦æˆ–å…¶ä»–ç‰¹æ®ŠåŠŸèƒ½æ—¶ï¼Œæ‰åº”è¯¥ä½¿ç”¨å †ä¸Šåˆ†é…çš„ç±»å‹ã€‚


## refer.
> å…¶å®å®˜æ–¹çš„æ–‡æ¡£åƒé€, åŸºæœ¬å¯ä»¥å¹³è¶Ÿ 80% çš„æ—¥å¸¸å¼€å‘äº†...

ä»¥åŠå°†è‡ªå·±ä¼ªè£…æˆä¸€ä¸ªè®¤çœŸåˆå¾ˆç¬¨çš„å­¦å‘˜,
GPT ä»¬å°±å¯ä»¥æ— é™è€å¿ƒçš„åå¤å›ç­”æ‰€æœ‰é—®é¢˜, å½“ç„¶, å¾—é…å¥—è‡ªè¡Œæ£€éªŒä»¥åŠå®˜æ–¹æ–‡æ¡£è¯å®:


- [ä»€ä¹ˆæ˜¯æ‰€æœ‰æƒï¼Ÿ - Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap)
- [ç”Ÿå‘½å‘¨æœŸåŸºç¡€ - Rust By Practice( Rust ç»ƒä¹ å®è·µ )](https://zh.practice.rs/lifetime/basic.html)
- [å­—ç¬¦ä¸²ï¼šstrå’ŒString - Rustå…¥é—¨ç§˜ç±](https://rust-book.junmajinlong.com/ch3/04_str_string.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F)
- [ç†è§£Rustå†…å­˜ç®¡ç† - Rustå…¥é—¨ç§˜ç±](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - [å †ç©ºé—´å’Œæ ˆç©ºé—´ - Rustå…¥é—¨ç§˜ç±](https://rust-book.junmajinlong.com/ch5/01_heap_stack.html)
    - ...
- [ä½¿ç”¨Box<T> æŒ‡å‘å †ä¸Šæ•°æ® - Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ](https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE)


```
     _~`|~~_
 \/ /  = â†’  \ ()
   '_   âˆ§   _'
   / '--~--' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>clear_explanation_rust_modele_system.md</title><link>https://rs.101.so//tip/clear_explanation_rust_modele_system</link><pubDate>Wed, 22 Mar 2023 00:51:38 +0800</pubDate><content:encoded><![CDATA[# æ¸…æ™°è§£é‡ŠRustæ¨¡å—ç³»ç»Ÿ
> tips...é‡è¦ä¹Ÿä¸é‡è¦

åŸæ–‡: [Clear explanation of Rustâ€™s module system](https://www.sheshbabu.com/posts/rust-module-system/)

## å¿«è¯‘



Rustâ€™s module system is surprisingly confusing and causes a lot of frustration for beginners.

In this post, Iâ€™ll explain the module system using practical examples so you get a clear understanding of how it works and can immediately start applying this in your projects.

Since Rustâ€™s module system is quite unique, I request the reader to read this post with an open mind and resist comparing it with how modules work in other languages.

Letâ€™s use this file structure to simulate a real world project:

```
my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â”œâ”€â”€ config.rs
  â”œâ”€â”¬ routes
  â”‚ â”œâ”€â”€ health_route.rs
  â”‚ â””â”€â”€ user_route.rs
  â””â”€â”¬ models
    â””â”€â”€ user_model.rs
```

These are the different ways we should be able to consume our modules:

![rust-module-system-1](https://www.sheshbabu.com/images/2020-rust-module-system/rust-module-system-1.png)


These 3 examples should be sufficient to explain how Rustâ€™s module system works.

------


### Example 1
Letâ€™s start with the first example - importing config.rs in main.rs.

// main.rs
fn main() {
  println!("main");
}
// config.rs
fn print_config() {
  println!("config");
}
The first mistake that everyone makes is just because we have files like config.rs, health_route.rs etc, we think that these files are modules and we can import them from other files.

Hereâ€™s what we see (file system tree) and what the compiler sees (module tree):



Surprisingly, the compiler only sees the crate module which is our main.rs file. This is because we need to explicitly build the module tree in Rust - thereâ€™s no implicit mapping between file system tree to module tree.

We need to explicitly build the module tree in Rust, thereâ€™s no implicit mapping to file system

To add a file to the module tree, we need to declare that file as a submodule using the mod keyword. The next thing that confuses people is that you would assume we declare a file as module in the same file. But we need to declare this in a different file! Since we only have main.rs in the module tree, letâ€™s declare config.rs as a submodule in main.rs.

The mod keyword declares a submodule

The mod keyword has this syntax:

mod my_module;
Here, the compiler looks for my_module.rs or my_module/mod.rs in the same directory.

my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â””â”€â”€ my_module.rs

or

my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â””â”€â”¬ my_module
    â””â”€â”€ mod.rs
Since main.rs and config.rs are in the same directory, letâ€™s declare the config module as follows:

// main.rs
+ mod config;

fn main() {
+ config::print_config();
  println!("main");
}
// config.rs
fn print_config() {
  println!("config");
}
Weâ€™re accessing the print_config function using the :: syntax.

Hereâ€™s how the module tree looks like:



Weâ€™ve successfully declared the config module! But this is not sufficient to be able to call the print_config function inside config.rs. Almost everything in Rust is private by default, we need to make the function public using the pub keyword:

The pub keyword makes things public

// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// config.rs
- fn print_config() {
+ pub fn print_config() {
  println!("config");
}
Now, this works. Weâ€™ve successfully called a function defined in a different file!

------


### Example 2
Letâ€™s try calling the print_health_route function defined in routes/health_route.rs from main.rs.

// main.rs
mod config;

fn main() {
  config::print_config();
  println!("main");
}
// routes/health_route.rs
fn print_health_route() {
  println!("health_route");
}
As we discussed earlier, we can use the mod keyword only for my_module.rs or my_module/mod.rs in the same directory.

So in order to call functions inside routes/health_route.rs from main.rs, we need to do the following things:

Create a file named routes/mod.rs and declare the routes submodule in main.rs
Declare the health_route submodule in routes/mod.rs and make it public
Make the functions inside health_route.rs public
my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â”œâ”€â”€ config.rs
  â”œâ”€â”¬ routes
+ â”‚ â”œâ”€â”€ mod.rs
  â”‚ â”œâ”€â”€ health_route.rs
  â”‚ â””â”€â”€ user_route.rs
  â””â”€â”¬ models
    â””â”€â”€ user_model.rs
// main.rs
mod config;
+ mod routes;

fn main() {
+ routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/mod.rs
+ pub mod health_route;
// routes/health_route.rs
- fn print_health_route() {
+ pub fn print_health_route() {
  println!("health_route");
}
Hereâ€™s how the module tree looks like:



We can now call a function defined in a file inside a folder.

------


### Example 3
Letâ€™s try calling from main.rs => routes/user_route.rs => models/user_model.rs

// main.rs
mod config;
mod routes;

fn main() {
  routes::health_route::print_health_route();
  config::print_config();
  println!("main");
}
// routes/user_route.rs
fn print_user_route() {
  println!("user_route");
}
// models/user_model.rs
fn print_user_model() {
  println!("user_model");
}
We want to call the function print_user_model from print_user_route from main.

Letâ€™s make the same changes as before - declaring submodules, making functions public and adding the mod.rs file.

my_project
â”œâ”€â”€ Cargo.toml
â””â”€â”¬ src
  â”œâ”€â”€ main.rs
  â”œâ”€â”€ config.rs
  â”œâ”€â”¬ routes
  â”‚ â”œâ”€â”€ mod.rs
  â”‚ â”œâ”€â”€ health_route.rs
  â”‚ â””â”€â”€ user_route.rs
  â””â”€â”¬ models
+   â”œâ”€â”€ mod.rs
    â””â”€â”€ user_model.rs
// main.rs
mod config;
mod routes;
+ mod models;

fn main() {
  routes::health_route::print_health_route();
+ routes::user_route::print_user_route();
  config::print_config();
  println!("main");
}
// routes/mod.rs
pub mod health_route;
+ pub mod user_route;
// routes/user_route.rs
- fn print_user_route() {
+ pub fn print_user_route() {
  println!("user_route");
}
// models/mod.rs
+ pub mod user_model;
// models/user_model.rs
- fn print_user_model() {
+ pub fn print_user_model() {
  println!("user_model");
}
Hereâ€™s how the module tree looks like:



Wait, we havenâ€™t actually called print_user_model from print_user_route! So far, weâ€™ve only called the functions defined in other modules from main.rs, how do we do that from other files?

If we look at our module tree, the print_user_model function sits in the crate::models::user_model path. So in order to use a module in files that are not main.rs, we should think in terms of the path necessary to reach that module in the module tree.

// routes/user_route.rs
pub fn print_user_route() {
+ crate::models::user_model::print_user_model();
  println!("user_route");
}
Weâ€™ve successfully called a function defined in a file from a file thatâ€™s not main.rs.

------


### super
The fully qualified name gets too lengthy if our file organization is multiple directories deep. Letâ€™s say for whatever reason, we want to call print_health_route from print_user_route. These are under the paths crate::routes::health_route and crate::routes::user_route respectively.

We can call it by using the fully qualified name crate::routes::health_route::print_health_route() but we can also use a relative path super::health_route::print_health_route();. Notice that weâ€™ve used super to refer to the parent scope.

The super keyword in module path refers to the parent scope

pub fn print_user_route() {
  crate::routes::health_route::print_health_route();
  // can also be called using
  super::health_route::print_health_route();

  println!("user_route");
}

------


### use
It would be tedious to use the fully qualified name or even the relative name in the above examples. In order to shorten the names, we can use the use keyword to bind the path to a new name or alias.

The use keyword is used to shorten the module path

pub fn print_user_route() {
  crate::models::user_model::print_user_model();
  println!("user_route");
}
The above code can be refactored as:

use crate::models::user_model::print_user_model;

pub fn print_user_route() {
  print_user_model();
  println!("user_route");
}
Instead of using the name print_user_model, we can also alias it to something else:

use crate::models::user_model::print_user_model as log_user_model;

pub fn print_user_route() {
  log_user_model();
  println!("user_route");
}

------

### External modules
Dependencies added to Cargo.toml are available globally to all modules inside the project. We donâ€™t need to explicitly import or declare anything to use a dependency.

External dependencies are globally available to all modules inside a project

For example, letâ€™s say we added the rand crate to our project. We can use it in our code directly as:

pub fn print_health_route() {
  let random_number: u8 = rand::random();
  println!("{}", random_number);
  println!("health_route");
}
We can also use use to shorten the path:

use rand::random;

pub fn print_health_route() {
  let random_number: u8 = random();
  println!("{}", random_number);
  println!("health_route");
}

------

### Summary
The module system is explicit - thereâ€™s no 1:1 mapping with file system
We declare a file as module in its parent, not in itself
The mod keyword is used to declare submodules
We need to explicitly declare functions, structs etc as public so they can be consumed in other modules
The pub keyword makes things public
The use keyword is used to shorten the module path
We donâ€™t need to explicitly declare 3rd party modules
Thanks for reading! Feel free to follow me in Twitter for more posts like this :)





```
         _~^*âˆ½~_
     \/ /  # â—µ  \ (/
       '_   â©Œ   _'
       | '--+--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item><item><title>past_ampersand-driven_development.md</title><link>https://rs.101.so//101/past_ampersand-driven_development</link><pubDate>Wed, 22 Mar 2023 00:47:58 +0800</pubDate><content:encoded><![CDATA[# å…‹æœ "& é©±åŠ¨å¼€å‘"
åŸæ–‡: [Getting Past â€œAmpersand-Driven Developmentâ€ in Rust - Blog](https://fiberplane.com/blog/getting-past-ampersand-driven-development-in-rust)

## background

[RR23W10 - é”ˆå‘¨åˆŠ -> Weekly :: China<Rustaceans>](https://weekly.rs.101.so/abt/index.html) ä¸­å‘ç°å¥½æ–‡,
è¯‘æ¥ç»†è¯»....

## å¿«è¯‘
> A little mental model for ownership and borrowing

æ‰€æœ‰æƒå’Œå€Ÿç”¨çš„å°å°å¿ƒæ™ºæ¨¡å‹.

æˆ‘æ˜¯åœ¨ä¸€æ¬¡ [Tad Lispy](https://www.youtube.com/watch?v=lsnksAMpUvM)
çš„æ¼”è®²ä¸­å¬åˆ° "& ç¬¦å·é©±åŠ¨å¼€å‘"è¿™è¯å„¿çš„,
éå¸¸ç²¾ç¡®çš„æ•æ‰åˆ°äº†å¾ˆå¤š Rust æ–°äººå¼€å‘æ—¶,
ä¸‹æ„è¯†çš„éšæœºæ’å…¥ & ç¬¦å·æ¥å®‰æŠšç¼–è¯‘çš„è¡Œä¸º.

æ­¤æ–‡, æè¿°äº†æˆ‘æƒ³å‘ Rust æ–°æ‰‹è§£é‡Šçš„ä¸€ä¸ªå¿ƒæ™ºæ¨¡å‹ï¼Œ
æ¶‰åŠ &,&mut,æ‰€æœ‰æƒ, Rcs å’Œ Arcs ä¹‹é—´çš„åŒºåˆ«;
æˆ‘å¸Œæœ›ä½ æˆ–æ˜¯å…¶å®ƒæœ‰æŠ±è´Ÿçš„ Rustacean ä»¬å¯¹æ­¤æ„Ÿè§‰æœ‰ç”¨.

### å¼•ç”¨ (&variable)

è®©æˆ‘ä»¬ä» & ç¬¦å·å¼€å§‹,
çœŸæ˜¯ä¸ªå¯æ€•çš„ç¬¦å·;
åœ¨ Rust ä¸­éšå¤„å¯è§ --- å¦‚æœä½ é¦–æ¬¡å°è¯•ç¼–å†™ä¸€äº› Rust ä»£ç ,
å¯èƒ½ä¸åˆ° 10 åˆ†é’Ÿ,
Rust ç¼–è¯‘å™¨å°±ä¼šçƒ¦äººçš„æˆ–æ˜¯æœ‰ç”¨çš„å‘Šè¯‰ä½ ,
åœ¨å“ªå„¿éœ€è¦æ”¾ç½®ä¸€ä¸ª &;

æƒ³è±¡ä¸€ä¸‹,æˆ‘ä»¬æœ‰ä¸ªè®¡ç®—å­—ç¬¦ä¸²é•¿åº¦çš„ç®€å•å‡½æ•°;
æ­¤å‡½æ•°éœ€è¦æŸ¥é˜…å­—ç¬¦ä¸²;
ä½†æ˜¯, éœ€è¦æ‰€æœ‰æƒè¿›è¡Œä¿®æ”¹å˜›?ä¸;
å½“é•¿åº¦å‡½æ•°å®Œæˆæ—¶,æˆ‘ä»¬åº”è¯¥ä»å†…å­˜ä¸­åˆ é™¤å­—ç¬¦ä¸²å˜›? ä¹Ÿä¸éœ€è¦;
è¿™æ„å‘³ç€é•¿åº¦å‡½æ•°å˜¦è¯»å–è®¿é—®æƒ,
åªæ˜¯è¦å­—ç¬¦ä¸²çš„ä¸´æ—¶è§†å›¾è€Œä¸æ˜¯æ°¸ä¹…ç‰ˆæœ¬;

è¿™å°±æ˜¯ &å˜é‡ ç¬¦å·åœ¨ Rust ä¸­çš„å«ä¹‰;
æƒ³æƒ³ä¸€ä¸ªå°å­©å­å°†æœ€å–œæ¬¢çš„ç©å…·å€Ÿç»™å¦å¤–ä¸€ä¸ªå­©å­æ—¶è¯´:
"ä½ å¯ä»¥çœ‹, ä½†æ˜¯, ä¸èƒ½æ‘¸; å½“ä½ çœ‹å®Œå, æˆ‘æƒ³ç«‹å³æ‹¿å›æ¥;"
è¿™å°±æ˜¯å…±äº«å¼•ç”¨;

![Midjourney](https://framerusercontent.com/images/5LwiCYhw088dpelWzFCkp9MWSo.png)


> å›¾ç‰‡ç”± Evan Schwartz ä½¿ç”¨ Midjourney åˆ›ä½œ


### å¯å˜å¼• (&mut variable)

é‚£ä¹ˆ &mut å˜é‡åˆæ˜¯æ€ä¹ˆå›äº‹å„¿?

è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹åœ¨ç»™å®šå­—ç¬¦ä¸²å‰è¿½åŠ  "hello" çš„å‡½æ•°,
è€Œä¸æ˜¯æˆ‘ä»¬çš„å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°;
åœ¨è¿™ç§æƒ…å†µä¸­,
æˆ‘ä»¬ç¡¬éª¨å¤´å¸Œæœ›å‡½æ•°ä¿®æ”¹ç»™è¿›æ¥çš„æ•°æ®;
è¿™æ—¶,æˆ‘ä»¬å°±éœ€è¦ &mut æˆ–è¯´ å¯å˜å¼•ç”¨;

æƒ³æƒ³æˆ‘ä»¬çš„å°å­©å­å€Ÿä¸€æœ¬æ¶‚è‰²ä¹¦ç»™æœ‹å‹,
è®©ä»–åœ¨ä¸€é¡µä¸Šè‰²,è¯´:"ä½ å¯ä»¥çœ‹ä»¥åŠæ‘¸---ä½†æ˜¯,
å½“ä½ å®Œæˆå, æˆ‘ä»ç„¶æƒ³è¦å›æ¥";


![Evan Schwartz](https://framerusercontent.com/images/0Y2RBZro7ESbqJzViLGIqfvccY.png)

> å›¾ç‰‡ç”± Evan Schwartz ä½¿ç”¨ Midjourney åˆ›ä½œ


#### å¯å˜å¼•ç”¨æ˜¯ç‹¬å çš„

è¿™é‡Œè§£é‡Šå…³äº Rust å¾®å¦™åˆéå¸¸èªæ˜çš„è®¾è®¡æœ€å¥½çš„åœºæ™¯ä¹‹ä¸€;

å¦‚æœæŸäºº(æˆ–æ˜¯ä½ çš„ä»£ç çš„æŸéƒ¨åˆ†)æœ‰ä¸€ä¸ªå¯¹æŸä¸ªå€¼çš„å¯å˜è¢­ç”¨,
Rust ç¼–è¯‘å™¨ä¼šç¡®ä¿ç»å¯¹æ²¡æœ‰å…¶å®ƒäººå¯ä»¥å†æ¬¡å¼•ç”¨;
ä¸ºä»€ä¹ˆ?
å› ä¸º, å¦‚æœä½ æ­£åœ¨æŸ¥çœ‹æŸä¸ªä½ è®¤ä¸ºä¸å¯å˜çš„å€¼,
å½“ç„¶ä¸ä¼šåœ¨ä½ ä½¿ç”¨å…¶è¿‡ç¨‹ä¸­åˆå’Œç»´å…¶å®ƒäººæ„å¤–çš„å˜æ›´è¿™ä¸ªå¯¹è±¡
(å¯¹äºæˆ‘ä»¬ä¸Šé¢æåŠçš„å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°,
ä½ å°±çŸ¥é“å¦‚æœå…è®¸, é‚£å¾—å¤šä»¤äººå›°æƒ‘?)

å¦å¤–ä¸€å±‚å«ä¹‰æ˜¯,
å¦‚æœä»»ä½•äººå¯¹ä¸€ä¸ªå€¼æœ‰ä¸€ä¸ªä¸å¯å˜è¢­ç”¨,
æˆ‘ä»¬å°±ä¸èƒ½æ›´æ”¹å®ƒ, åˆæˆ–æ˜¯ç»™å‡ºå¦å¤–ä¸€ä¸ªå¯å˜å¼•ç”¨;


### å€¼çš„æ‹¥æœ‰ (variable)

æ¥ä¸‹æ¥,æˆ‘ä»¬å°†è®¨è®º å€¼çš„æ‹¥æœ‰;

Rust çš„å¦å¤–ä¸€ä¸ªèªæ˜ä¹‹å¤„,
åœ¨äºå¦‚ä½•ç¡®å®šä½•æ—¶åº”è¯¥å¿˜è®°æˆ–æ˜¯ä»å†…å­˜ä¸­åˆ é™¤ä¸€ä¸ªå€¼;
æ¯å½“å‡½æ•°å®Œæˆå, å…¶ä¸­å£°æ˜çš„æ‰€æœ‰å€¼éƒ½å°†è¢«åˆ é™¤æˆ–æ˜¯è‡ªåŠ¨æ¸…é™¤;

å¥½å§, è¿™å¹¶ä¸æ˜¯çœŸçš„;
å¦‚æœæˆ‘ä»¬å†æ¬¡è€ƒè™‘å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°,
å°±çŸ¥é“, æˆ‘ä»¬å¹¶ä¸å¸Œæœ›å­—ç¬¦ä¸²åœ¨é•¿åº¦å‡½æ•°å®Œæˆæ—¶å°±è¢«å®Œå…¨é—å¿˜/åˆ é™¤;
å’Œè¿½åŠ  hello å‡½æ•°ç›¸åŒ;
åœ¨è¿™äº›æƒ…å†µä¸­, åªä¼šæ¸…é™¤å¯¹è¯¥å€¼çš„å¼•ç”¨,
ä½†æ˜¯,ä¸ä¼šåˆ é™¤å®é™…å€¼;

é‚£ä¹ˆ, å°†æˆ‘ä»¬å‘ HashMap ä¸­æ’å…¥ä¸€äº›ä¸œè¥¿æ—¶åˆå¦‚ä½•?
åœ¨è¿™ç§åœºæ™¯ä¸­,
æˆ‘ä»¬å¸Œæœ›ç»™å®šçš„å­—ç¬¦ä¸²è¾“å…¥æˆä¸º HashMap çš„ä¸€éƒ¨åˆ†;
å¸Œæœ›è¯¥å€¼ç°åœ¨ç”± HashMap æ‹¥æœ‰;

æƒ³è±¡ä¸€ä¸ªå°å­©èµ é€ä»–ä»¬çš„ç©å…·ä¹‹ä¸€æ—¶è¯´:
"ç»™, ä½ å¯ä»¥æ‹¿æ¥ä½œä»»ä½•ä½ æƒ³ä½œçš„äº‹å„¿,æˆ‘ä¸éœ€è¦æ‹¿å›æ¥äº†,
äº«å—å§!"
(å³ä¾¿æ˜¯æƒ³è±¡ä¸­çš„å­©å­, ä¹Ÿéœ€è¦ç›¸å½“æˆç†Ÿæˆåƒå¯èƒ½ä»¤æ­¤åœºæ™¯å¯ä¿¡å“ª...)


### å¼•ç”¨è®¡æ•°æŒ‡é’ˆ (Rc å’Œ Arc)

æˆ‘ä»¬åœ¨ Rust ä¸­è¿˜æœ‰å¦å¤–ä¸¤ç§å€¼ç±»å‹æ˜¯ Rc å’Œ Arc;

å¯¹äº Rc, æƒ³è±¡å­©å­ç”Ÿæ—¥æ´¾å¯¹ä¸Šçš„è£…é¥°å“,
ä¾‹å¦‚æ°”çƒ;
å½“æ‰€æœ‰äººéƒ½å–ä¿¡åœ¨é‚£é‡Œæ—¶,
æˆ‘ä»¬å¸Œæœ›æ¯ä¸ªäººéƒ½çœ‹ç€, ä½†æ˜¯ä¸è¦è§¦æ‘¸è£…é¥°å“;
æˆ‘ä»¬å¸Œæœ›è£…é¥°å“ä¸€ç›´ä¿æŒåˆ°æœ€åä¸€ä¸ªå­©å­ç¦»å¼€æ—¶;
ä½†æ˜¯, å˜¦æœ€åä¸€ä¸ªç†Šå­©å­ç¦»å¼€,
æˆ‘ä»¬å°±å¯ä»¥ç«‹å³å¼€å§‹æ¸…ç†è£…é¥°å“;
è¿™å°±æ˜¯ä¸€ä¸ª Rc æˆ–æ˜¯å¼•ç”¨è®¡æ•°æŒ‡é’ˆ;

Rc è·Ÿè¸ªæœ‰å¤šå°‘äºº(æˆ–æ˜¯ä»£ç çš„ä¸€éƒ¨åˆ†)
æ­£åœ¨æŸ¥çœ‹, å¹¶ä¿æŒè¯¥å€¼, ç›´åˆ°æœ€åä¸€ä¸ªå¼•ç”¨è¢«åˆ é™¤çš„é‚£ä¸€åˆ»;

å¦‚æœä½ æ­£åœ¨ä½¿ç”¨å¼‚æ­¥æˆ–æ˜¯å¤šçº¿ç¨‹ä»£ç ,
ä½ å°†ä½¿ç”¨ Arc æˆ–æ˜¯åŸå­å¼•ç”¨è®¡æ•°æŒ‡é’ˆ,
ä½†æ˜¯, å’Œ Rc çš„æƒ³æ³•ç›¸åŒ;

æ•ˆæœä¹Ÿæ˜¯: å¤§å®¶çœ‹çœ‹è£…é¥°å“,
æ™šä¼šä¸€ç»“æŸæˆ‘ä»¬å°±æ”¶æ‹¾å¹²å‡€;

### ç»“è®º
ä½œä¸ºæœ€åçš„æ€»ç»“,
ä½ å¯ä»¥æ ¹æ®ä»¥ä¸‹é—®é¢˜, æ¥å†³ç­–åº”è¯¥ä½¿ç”¨é‚£ç§ç±»å‹çš„å€¼:

![Conclusion](https://framerusercontent.com/images/mH73ms5JxUOiNWhWMA8UKtAX7Y.jpg)


------


|                 | &var(ä¸å¯å˜å¼•) | &mut var(å¯å˜å¼•ç”¨) | var(æ‹¥æœ‰å€¼)                              | Rc(å¼•ç”¨è®¡æ•°æŒ‡é’ˆ)         | Arc(åŸå­å¼•ç”¨è®¡æ•°æŒ‡é’ˆ) |
|-----------------|------------------|----------------------|--------------------------------------------|----------------------------|-------------------------|
| å¯è¯»?           | âœ”ï¸               | âœ”ï¸                   | âœ”ï¸                                         | âœ”ï¸                         | âœ”ï¸                      |
| å¯å†™?           | âœ˜                | âœ”ï¸                   | âœ”ï¸                                         | ä»…å½“åŒ…è£…ä¸º Cell/RefCell    | ä»…å½“åŒ…è£…ä¸º Mutex/RwLock |
| å‡½æ•°ç»“æŸæ—¶ä¸¢å¼ƒ? | âœ˜                | âœ˜                    | âœ”ï¸                                         | ä»…åœ¨ Rc æœ€åçš„å…‹éš†è¢«ä¸¢å¼ƒå | ä»…å½“ Arc çš„å…‹éš†è¢«ä¸¢å¼ƒå |
| å¤šçº¿ç¨‹å¯ç”¨?     | âœ˜ æ³¨1            | âœ˜                    | å€¼å¯ä»¥åœ¨çº¿ç¨‹é—´ç§»åŠ¨,ä½†ä¸åŒçº¿ç¨‹ä¸å¯åŒæ—¶è®¿é—® | âœ˜                          | âœ”ï¸                      |



------


> æ³¨1: (é™¤éæœ‰ä¸€ä¸ª 'static ç”Ÿå‘½å‘¨æœŸ, è¿™æ„å‘³ç€åœ¨æ‰€æœ‰çº¿ç¨‹ä¸­å­˜åœ¨,æˆ–æ˜¯åœ¨çº¿ç¨‹ä½œç”¨åŸŸä¸­ä½¿ç”¨)


åœ¨ä» Typescript ç­‰é«˜çº§è¯­è¨€è½¬åˆ° Rust æ—¶,
& ç¬¦å·æ˜¯æœ€å¯æ€•æˆ–æ˜¯æœ€ä¸ç†Ÿæ‚‰çš„éƒ¨åˆ†ä¹‹ä¸€;
ä½†æ˜¯, èƒ½ä¿è¯çš„æ˜¯, ç»è¿‡ä¸€äº›ç»ƒä¹ , åœ¨ç¼–å†™ä»£ç æ—¶,
çŸ¥é“ä¸€ä¸ªå‡½æ•°åº”è¯¥é‡‡ç”¨å¯å˜å¼•ç”¨è¿˜æ˜¯ä¸å¯å˜å¼•ç”¨,
åˆæˆ–æ˜¯çŸ¥é“å…¶å®ƒåº“çš„å‡½æ•°æ˜¯å¦å¯èƒ½éœ€è¦å¼•ç”¨æˆ–æ˜¯æ‹¥æœ‰å€¼,
æ„Ÿè§‰ä¼šæ›´åŠ ç›´è§‚;
ä¹Ÿå°±æ— éœ€ `"& é©±åŠ¨å¼€å‘"` äº†;

æœ‰å…³è¯¦æƒ…, å€¼å¾—æŸ¥é˜… Rust è¯­è¨€æ–‡æ¡£:
[References and Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)
ä»¥åŠ:
 [What is Ownership?](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
 
è¿˜æœ‰ [Evan Schwartz](https://github.com/emschwartz)
æ˜¯ Fiberplane çš„é¦–å¸­ Rust å·¥ç¨‹å¸ˆ;
ä¹Ÿæ˜¯ [Autometrics](https://github.com/autometrics-dev/autometrics-rs)
çš„åˆ›é€ è€…,
ä¸€ä¸ªå…¨æ–°çš„ crate, 
å¯ä»¥è®©ä½ è½»æ¾äº†è§£ä»£ç ä¸­ä»»ä½•å‡½æ•°çš„é”™è¯¯ç‡/å»¶è¿Ÿå’Œç”Ÿäº§ä½¿ç”¨æƒ…å†µ.

## refer.

... TBD



```
          _~`+âˆ½~_
      \/ /  = â—¶  \ (/
        '_   ğŸ‚   _'
        | '-----' /

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```
]]></content:encoded></item><item><title>two_kinds_assert_make_better_code.md</title><link>https://rs.101.so//tip/two_kinds_assert_make_better_code</link><pubDate>Mon, 20 Mar 2023 15:46:43 +0800</pubDate><content:encoded><![CDATA[# ä¸¤ç§'Assert'æ„å»ºæ¸…æ™°ä»£ç 
> tips...é‡è¦ä¹Ÿä¸é‡è¦

åŸæ–‡: [Laurence Tratt: Rust's Two Kinds of 'Assert' Make for Better Code](https://tratt.net/laurie/blog/2023/rusts_two_kinds_of_assert_make_for_better_code.html)


## å¿«è¯‘



Daniel Lemire's recent post "runtime asserts are not free" looks at the run-time cost of assert statements in C and shows that a simple assert in a frequently executed loop can cause significant overhead.
My own opinion on assertions has shifted over the years, from "I don't see the point" to "use them sparingly" to "use them as much as possible". That last shift is largely due to Rust having two kinds of "assert" statement â€“ assert and debug_assert â€“ which has allowed me to accurately express two different kinds of assertions, largely freeing me from performance worries. If you come from a language that only has one kind of assert statement, this distinction can seem pointless, so in this post I want to briefly explain why it helped shift my thinking.

Background
Let me quickly define what I mean by an "assert": it's a programming language statement that checks a property and causes a crash if that property does not hold (conventionally called a "failing assert"). For example, if I have a Python program with a list of people's ages and calculate the minimum age, I might want to check that the youngest person doesn't have a negative age:

ages = [...]
youngest = min(ages)
assert(youngest >= 0)
If ages contains a negative value â€“ or if min doesn't work correctly! â€“ the assert will fail and cause a run-time exception:
Traceback (most recent call last):
  File "/tmp/t.py", line 3, in 
    assert(youngest >= 0)
AssertionError
In other words, writing assert is roughly equivalent to:
ages = [...]
youngest = min(ages)
if not (youngest >= 0):
  raise AssertionError
In practise, asserts are mostly used to check assumptions about a program's state â€” in this case, that at no point has a negative age entered into the system.
There are two major reasons why I might want to check this particular assumption. First, I might have written subsequent code which will only execute correctly with non-negative youngest values: I want to prevent that subsequent code from executing if that property is violated. Second, the assert both documents and checks the property. In other words, I could just have written a comment:

ages = [...]
youngest = min(ages)
# youngest must be non-negative or bad things will happen below
...
That comment accurately describes the program's assumption, but if the assumption is incorrect â€“ perhaps because another part of the program uses -1 to mean "we don't know how old this person is" â€“ the threatened "bad things" will occur. If I'm lucky, the effects will be relatively benign, and perhaps even invisible. But, if I'm unlucky, genuinely bad things will occur, ranging from odd output to security vulnerabilities.
Debugging incorrect assumptions of this sort is hard, because the effect of the assumption's violation is generally only noticed long after the violation occurred. It's not unusual for some poor programmer to spend a day or more hunting down a problem only to find that it was caused by the violation of a simple assumption. In contrast, the assert causes my program to crash predictably, with a clear report, and at the earliest possible opportunity. In general, fixing the causes of failing asserts tends to be relatively simple.

Why asserts are used less often than one might think
As I've described them above, asserts sound like a clear win â€” but most programs use many fewer asserts than one might hope.
The most obvious reason for this is that programmers often don't realise the assumptions they're embedding in their programs, or don't consider the consequences of their assumptions. This tends to be particularly true for junior programmers, who have not yet built up scar tissue from multi-day debugging sessions that were necessary only because they didn't think to use asserts. It took me many years of programming before I realised how much time I was wasting by not thinking about, and checking with asserts, my assumptions about a program's properties.

Sometimes it's also very difficult to work out how to assert the property one cares about. This is particularly true in languages like C where there is no built-in help to express properties such as "no element in the list can be negative". The lengthier, and more difficult, an assert needs to be â€“ particularly if it needs a helper function â€“ the less likely it is to be written down.

Inevitably, some asserts are plain wrong, either expressing an incorrect property, or expressing correct property incorrectly. I think most of us expect such mistakes. However, what many people don't realise is that asserts can change a program's behaviour if they have side effects. I have shot myself in the foot more than once by copying and pasting code such as l[i++] into an assert, causing the program to execute differently depending on whether the assert is compiled in or not. I view this as inevitable stupidity on my part, rather than a flaw in the concept of asserts, but I have heard of at least one organisation that bans (or, at least, banned) asserts because of this issue.

Performance issues
Daniel pointed out a very different reason for avoiding asserts: they can cause serious performance issues when used in the "wrong" places. An assert introduces a branch (i.e. an "if") which must be executed at run-time [1]. The existence of an assert can also cause a compiler to miss compile-time optimisation opportunities [2]. There is a general fear in the programming community about the performance costs of asserts, even though none of us can know how they impact a given program without actually measuring it.
To avoid performance issues, most software is compiled in either "debug" (sometimes called "testing") or "release" modes: in debug mode, asserts are compiled in and checked at run-time; but in release mode, the asserts are not compiled in, and thus not checked at run-time. In languages like C, there isn't a standard concept of "debug" and "release" modes, but many people consider "release" mode to imply adding a flag -DNDEBUG, which causes assert to become a no-op. Rust's standard Cargo build system defaults to debug mode, with --release performing a release build.

Two kinds of asserts
While not compiling (and thus not checking) asserts in release mode removes performance problems, it also weakens the guarantees we have about a program's correctness â€” just because a test suite doesn't violate an assumption doesn't mean that real users won't use the program in a way which does.
These days I thus view asserts as falling into two categories:

Checking problem domain assumptions.
Checking internal assumptions.
That distinction might seem artificial, perhaps even non-existent, so let me give examples of what I mean.
The first category contains assumptions about the "real world" problem my program is trying to help solve. For example, if I'm writing a warehouse stock system, parts of my program might assume properties such as "an item's barcode is never empty".

The second category contains assumptions about the way I've structured my program. For example, I might have written a function which runs much faster if I assume the input integer is greater than 1. It's probable that, at the time I write that function, I won't call it in a way that violates that property: but later programmers (including me!) will quite possibly forget, or not notice, that property. An assertion is thus particularly helpful for future programmers, especially when they're refactoring code, to give them greater confidence that they haven't broken the program in subtle ways.

What it took me years to realise is that I have very different confidence levels about my assumptions in each category. I have high confidence that violations of my assumptions in the second category will be caught during normal testing. However, I have much lower confidence that violations of my assumptions in the first category will be caught during testing.

My differing confidence levels shouldn't be surprising â€” after all, I've been hired because I can program, not because I know much about warehouse stock systems or barcodes! However, since "normal testing" implies "debug mode" and "user is running the program" implies "release mode", it means that the assumptions I am least confident are not exercised when they're most needed.

Two kinds of assert statement
The problem that I've just expressed ultimately occurs because languages like C force us to encode both kinds of assumption with a single assert statement: either all asserts are compiled in or none are.
I long considered this inevitable, but when I moved to Rust several years back, I slowly realised that I now had access to two kinds of assert statement. debug_assert is rather like assert in C, in the sense that the assumptions it expresses are only checked in debug mode. In contrast, assert is "always checked in both debug and release builds, and cannot be disabled."

This might seem like a small difference, but for me it completely unlocked the power of assertions. If you look at a lot of the code I now write, you'll see liberal use of debug_assert, often checking quite minor assumptions, including those I never think likely to be violated. I never even think, let alone worry, about the performance impact of debug_assert. But occasionally you'll spot an assert, sometimes even in fairly frequently executed code â€” those are where I'm checking particularly important assumptions, or assumptions in which I have particularly low confidence. Each time I write assert I think about the possible performance impact, and also about whether there's a way I can increase my confidence in the assumption to the point that I can downgrade it to a debug_assert. Similarly, when it comes to debugging, I often check assert statements quite carefully as they indicate my low confidence in a particular assumption: it's more likely that I have to reconsider an assert than a debug_assert.

Of course, there's no reason why you can't write your own equivalents of assert and debug_assert in C, or any other language, but having them built into a language (or standard library), where their differing motivations are clearly documented and widely understood, makes it much easier to use them freely. I hope languages other than Rust will continue to make this difference in assertions â€” though I would prefer a shorter name than "debug_assert"!






```
          _~`|`~_
      \) /  â† â—·  \ \/
        '_   V   _'
        \ '--âˆ½--' )

...act by ferris-actor v0.2.4 (built on 23.0303.201916)
```]]></content:encoded></item></channel></rss>